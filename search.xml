<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>socket地址API</title>
    <url>/2023/11/29/1-socket%E5%9C%B0%E5%9D%80API/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">    

<h2 id="主机字节序和网络字节序"><a href="#主机字节序和网络字节序" class="headerlink" title="主机字节序和网络字节序"></a>主机字节序和网络字节序</h2><p><strong>大端字节序</strong></p>
<ul>
<li>一个整数的高位字节（23~31bit）存储在内存的低地址处，低位字节（0~7bit）存储在内存的高地址处</li>
<li>也称网络字节序<ul>
<li>在两台使用不同字节序的主机之间传递数据时</li>
<li>发送端总是要把发送的数据转化成大端字节序数据后再发送，而接收端再根据自身采用的字节序决定是否对接收到的数据进行转换</li>
</ul>
</li>
</ul>
<span id="more"></span>
<p><strong>小端字节序</strong></p>
<ul>
<li>整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的地址处</li>
<li>现代PC大多采用小端字节序，因此小端字节序又被称为主机字节序</li>
</ul>
<p><strong>判断机器字节序</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">void</span> <span class="token function">byteorder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">union</span><span class="token punctuation">{</span>
		<span class="token keyword">short</span> value<span class="token punctuation">;</span>
		<span class="token keyword">char</span> union_bytes<span class="token punctuation">[</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>test<span class="token punctuation">;</span>
	test<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token number">0x0102</span><span class="token punctuation">;</span>
	
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span>union_bytes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>test<span class="token punctuation">.</span>union_bytes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"big endian\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span>union_bytes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>test<span class="token punctuation">.</span>union_bytes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"little endian\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"unknown...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">byteorder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>主机字节序和网络字节序之间的转换</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netinet/in.h&gt;</span></span>
<span class="token comment">//htonl = "host to network long",将长整形（32bit）的主机字节序数据转化为网络字节序数据</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">int</span> <span class="token function">htonl</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">int</span> hostlong<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">short</span> <span class="token keyword">int</span> <span class="token function">htons</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span> <span class="token keyword">int</span> hostshort<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">int</span> <span class="token function">ntohl</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">int</span> netlong<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">short</span> <span class="token keyword">int</span> <span class="token function">ntohs</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span> <span class="token keyword">int</span> netshort<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//长整型函数通常用来转换IP地址，短整形函数用来转换端口号</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="通用socket地址"><a href="#通用socket地址" class="headerlink" title="通用socket地址"></a>通用socket地址</h2><p>socket网络编程接口中表示socket地址的是结构体sockaddr</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// sockaddr结构体</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/socket.h&gt;</span></span>
<span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token punctuation">{</span>
	<span class="token class-name">sa_family_t</span> sa_family<span class="token punctuation">;</span>
	<span class="token keyword">char</span> sa_data<span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>sa_family</strong></p>
<ul>
<li><p>地址族类型（sa_family_t）的变量，通常与协议族类型对应</p>
</li>
<li><p>| 协议族   | 地址族   | 描述             |<br>| ———— | ———— | ———————— |<br>| PF_UNIX  | AF_UNIX  | UNIX本地域协议族 |<br>| PF_INET  | AF_INET  | TCP/IPv4协议族   |<br>| PF_INET6 | AF_INET6 | TCP/IPv6协议族   |</p>
</li>
</ul>
<p><strong>sa_data</strong></p>
<ul>
<li><p>用于存放socket地址值</p>
</li>
<li><p>不同的协议族的地址值具有不同的含义和长度</p>
</li>
<li><p>| 协议族   | 地址值含义和长度                                             |<br>| ———— | —————————————————————————————— |<br>| PF_UNIX  | 文件的路径名，长度可达到108字节                              |<br>| PF_INET  | 16bit端口号和32bit IPv4地址，共6字节                         |<br>| PF_INET6 | 16bit端口号，32bit流标识，128bit IPv6地址，32bit范围ID，共26字节 |</p>
</li>
</ul>
<hr>
<p>14字节的sa_data根本无法完全容纳多数协议族的地址值，因此，Linux定义了新的通用socket地址结构体</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/socket.h&gt;</span></span>

<span class="token keyword">struct</span> <span class="token class-name">sockaddr_storage</span><span class="token punctuation">{</span>
	<span class="token class-name">sa_family_t</span> sa_family<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">int</span> __ss_align<span class="token punctuation">;</span>
	<span class="token keyword">char</span> __ss_padding<span class="token punctuation">[</span><span class="token number">128</span><span class="token operator">-</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>__ss_align<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>该结体不仅提供了足够大的空间用于存放地址值，而且是内存对齐的</p>
<h2 id="专用socket地址"><a href="#专用socket地址" class="headerlink" title="专用socket地址"></a>专用socket地址</h2><p>通用的socket地址结构体不好用，设置与获取IP地址和端口号就需要执行烦琐的位操作，Linux为各个协议族提供了专门的socket地址结构体</p>
<h3 id="UNIX本地域协议族"><a href="#UNIX本地域协议族" class="headerlink" title="UNIX本地域协议族"></a><strong>UNIX本地域协议族</strong></h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/un.h&gt;</span></span>
<span class="token keyword">struct</span> <span class="token class-name">sockaddr_un</span><span class="token punctuation">{</span>
	<span class="token class-name">sa_family_t</span> sin_family<span class="token punctuation">;</span> <span class="token comment">//地址族：AF_UNIX</span>
	<span class="token keyword">char</span> sun_path<span class="token punctuation">[</span><span class="token number">108</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 	<span class="token comment">//文件路径名</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a><strong>TCP/IP协议族</strong></h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// IPv4</span>
<span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span><span class="token punctuation">{</span>
	<span class="token class-name">sa_family_t</span> sin_family<span class="token punctuation">;</span>		<span class="token comment">//地址族：AF_INET</span>
	<span class="token class-name">u_int16_t</span> sin_port<span class="token punctuation">;</span>			<span class="token comment">//端口号，要用网络字节序表示</span>
	<span class="token keyword">struct</span> <span class="token class-name">in_addr</span> sin_addr<span class="token punctuation">;</span>	<span class="token comment">//IPv4地址结构体，见下面</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">in_addr</span><span class="token punctuation">{</span>
	<span class="token class-name">u_int32_t</span> s_addr<span class="token punctuation">;</span>			<span class="token comment">//IPv4地址，要用网络字节序表示</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// IPv6</span>
<span class="token keyword">struct</span> <span class="token class-name">sockaddr_in6</span><span class="token punctuation">{</span>
	<span class="token class-name">sa_family_t</span> sin6_family<span class="token punctuation">;</span>
	<span class="token class-name">u_int16_t</span> sin6_port<span class="token punctuation">;</span>		<span class="token comment">//端口号，要用网络字节序表示</span>
	<span class="token class-name">u_int32_t</span> sin6_flowinfo<span class="token punctuation">;</span>	<span class="token comment">//流信息，应设置为0</span>
	<span class="token keyword">struct</span> <span class="token class-name">in6_addr</span> sin6_addr<span class="token punctuation">;</span>	<span class="token comment">//IPv6地址结构体，见下面</span>
	<span class="token class-name">u_int32_t</span> sin6_scope_id<span class="token punctuation">;</span>	<span class="token comment">//scope ID，尚处于实验阶段</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">in6_addr</span>
<span class="token punctuation">{</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">char</span> sa_addr<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>	<span class="token comment">//IPv6地址，要用网络字节序表示</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>所有专用socket地址（以及sockaddr_storage）类型的变量在实际使用时都需要转化为通用socket地址类型sockaddr（强制转换即可）</li>
<li>所有socket编程接口使用的地址参数都是sockaddr</li>
</ul>
<h2 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a>IP地址转换函数</h2><p>通常，人们习惯用可读性好的字符串来表示IP地址，比如用点分十进制字符串表示IPv4地址，以及用十六进制字符串表示IPv6地址。但编程中我们需要先把它们转化为整数（二进制数）方能使用</p>
<p>而记录日志时则相反，我们要把整数表示的IP地址转化为可读的字符串 </p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h&gt;</span></span>

<span class="token comment">/*
inet_addr函数将用点分十进制字符串表示的IPv4地址转化为用网络字节序整数表示的IPv4地址
失败时返回INADDR_NONE
*/</span>
<span class="token class-name">in_addr_t</span> <span class="token function">inet_addr</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> strpte<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*
完成和inet_addr同样的功能
将转化结果存储于参数imp指向的地址结构中
成功时返回1，失败则返回0
*/</span>
<span class="token keyword">int</span> <span class="token function">inet_aton</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> cp<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">in_addr</span><span class="token operator">*</span> inp<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*
将用胃囊螺字节序整数表示的IPv4地址转化为用点分十进制字符串表示的IPv4地址
用一个静态变量存储转化结果，函数的返回值指向该静态内存
因此inet_ntoa是不可重入的
*/</span>
<span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">inet_ntoa</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">in_addr</span> in<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*
将用字符串表示的IP地址src（用点分十进制字符串表示的IPv4地址或用十六进制字符串表示的IPv6地址）转换成用网络字节序整数表示的IP地址，并把转换结构存储于dst指向的内存中
af参数指定地址族，可以是AF_INET或者AF_INET6
成功时返回1，失败则返回0并设置error
*/</span>
<span class="token keyword">int</span> <span class="token function">inet_pton</span><span class="token punctuation">(</span><span class="token keyword">int</span> af<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> src<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> dst<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*
进行与inet_pton相反的转换
前三个参数的含义与inet_pton的参数相同
最后一个参数cnt指明目标存储单元的大小，下面两个宏能帮助我们指定大小
#include &lt;netinet/in.h&gt;
#define INET_ADDRSTRLEN 16
#define INET6_ADDRSTRLEN 46
*/</span>
<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">inet_ntop</span><span class="token punctuation">(</span><span class="token keyword">int</span> af<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> src<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> dst<span class="token punctuation">,</span> <span class="token class-name">socklen_t</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="创建socket"><a href="#创建socket" class="headerlink" title="创建socket"></a>创建socket</h2><p><strong>socket</strong></p>
<ul>
<li>可读、可写、可控制、可关闭的文件描述符</li>
</ul>
<p><strong>创建socket</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">socket</span><span class="token punctuation">(</span><span class="token keyword">int</span> domain<span class="token punctuation">,</span> <span class="token keyword">int</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span> protocol<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li>domain<ul>
<li>告诉系统使用哪个底层协议族</li>
<li>TCP/IP：PF_INET或PF_INET6</li>
<li>UNIX本地域：PF_UNIX</li>
<li>……</li>
</ul>
</li>
<li>type<ul>
<li>指定服务类型</li>
<li>SOCK_STREAM：流服务</li>
<li>SOCK_DGRAM：数据报</li>
<li>对TCP/IP协议族来说<ul>
<li>SOCK_STREAM：传输层使用TCP协议</li>
<li>SOCK_DGRAM：传输层使用UDP协议</li>
</ul>
</li>
<li>可相与的值<ul>
<li>SOCK_NONBLOCK ：新创建的socket设为非阻塞的</li>
<li>SOCK_CLOEXEC  ：用fork调用创建子进程时在子进程中关闭该socket</li>
</ul>
</li>
</ul>
</li>
<li>protocol<ul>
<li>在前两个参数构成的协议集合下，再选择一个具体的协议</li>
<li>该值通常唯一，前两个参数已经完全决定了它的值</li>
<li>几乎在所有情况下，我们都应该把它设置为0，表示使用默认协议</li>
</ul>
</li>
<li>返回一个socket文件描述符，失败则返回-1，并设置error</li>
</ul>
<h2 id="命名socket"><a href="#命名socket" class="headerlink" title="命名socket"></a>命名socket</h2><p><strong>给socket命名</strong></p>
<ul>
<li>将一个socket与socket地址绑定</li>
<li>只有命名后服务器程序才知道该如何连接它</li>
<li>客户端通常不需要命名socket，采用匿名方式，使用操作系统自动分配的socket地址</li>
<li>使用bind系统调用命名</li>
</ul>
<p><strong>bind系统调用</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span> my_addr<span class="token punctuation">,</span> <span class="token class-name">socklen_t</span> addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li>将my_addr所指的socket地址分配给未命名的sockfd文件描述符，addrlen参数指出该socket地址的长度</li>
<li>bind成功返回0，失败则返回-1并设置errno</li>
<li>两种常见的errno<ul>
<li>EACCES<ul>
<li>被绑定的地址时受保护的地址，仅超级用户能够访问</li>
</ul>
</li>
<li>EADDRINUSE<ul>
<li>被绑定的地址正在使用中</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="监听socket"><a href="#监听socket" class="headerlink" title="监听socket"></a>监听socket</h2><p>创建一个监听队列以存放待处理的客户连接</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">listen</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">int</span> backlog<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>sockfd：指定被监听的socket</li>
<li>backlog：提示内核监听队列的最大长度<ul>
<li>监听队列如果超过backlog，服务器将不受理新的客户连接，客户端也将收到ECONNEREFUSED错误信息</li>
<li>所有处于完全连接状态的socket的上限</li>
<li>典型值是5</li>
<li>监听队列的上限通常比backlog略大</li>
</ul>
</li>
<li>成功是返回1，失败则返回-1，并设置errno</li>
</ul>
<h2 id="接受连接"><a href="#接受连接" class="headerlink" title="接受连接"></a>接受连接</h2><p><strong>accept系统调用</strong></p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
int accept(int sockfd, struct sockaddr* addr, socklen_t* addrlen);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li>sockfd：执行listen系统调用的监听socket</li>
<li><p>addr：获取被接受连接的远端socket地址，该socket地址的长度由addrlen参数指出</p>
</li>
<li><p>成功时返回一个新的连接socket，该socket唯一标识了被接受的这个连接，服务器可以通过读写该socket来与被接受连接对应的客户端通信</p>
</li>
<li>失败时返回-1并设置errno</li>
</ul>
<p>accept只是从监听队列中取出连接，而不论连接处于何种状态（如ESTABLISHED和CLOSE_WAIT），更不关心任何网络状况的变化</p>
<h2 id="发起连接"><a href="#发起连接" class="headerlink" title="发起连接"></a>发起连接</h2><p>服务器通过listen调用来被动接受连接，客户端则通过connect来主动与服务器建立连接</p>
<p><strong>connect系统调用</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span> serv_addr<span class="token punctuation">.</span> <span class="token class-name">socklen_t</span> addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li>sockfd：由socket系统调用返回的socket</li>
<li>serv_addr：服务器监听的socket地址，addrlen参数指定这个地址的长度</li>
<li>成功时返回0，一旦成功建立连接，sockfd就唯一地标识了这个连接，客户端就可以通过读写sockfd来与服务器通信 </li>
<li>connect失败则返回-1并设置errno，其中两种常见的errno是ECONNREFUSED和ETIMEDOUT<ul>
<li>ECONNREFUSED：目标端口不存在，连接被拒绝</li>
<li>ETIMEDOUT：连接超时</li>
</ul>
</li>
</ul>
<h2 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h2><p>关闭该连接对应的socket</p>
<p><strong>close系统调用</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li><p>fd：待关闭的socket</p>
</li>
<li><p>close系统调用并非总是立即关闭一个连接，而是将fd引用计数减一，当fd计数为0时，才真正关闭连接</p>
</li>
<li><p>在多进程程序中，一次fork系统调用默认将使父进程中打开的socket的引用计数加1，因此我们必须在父进程和子进程都对该socket执行close调用才能将连接关闭</p>
</li>
</ul>
<hr>
<p><strong>shutdown系统调用</strong></p>
<p>无论如何都要终止连接，而不是将socket引用计数减一，使用shutdown系统调用</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;sys/socket.h&gt;
int shutdown(int sockfd, int howto);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>sockfd：待关闭的socket</li>
<li>howto：<ul>
<li>SHUT_RD<ul>
<li>关闭sockfd上读的这一半，应用程序不能再针对socket文件描述符执行读操作，并且该socket接受缓冲区中的数据都被丢弃</li>
</ul>
</li>
<li>SHUT_WR<ul>
<li>关闭sockfd上写的这一半，sockfd的发送缓冲区中的数据会在真正关闭连接之前全部发送出去，应用程序不可再对该socket文件描述符执行写操作</li>
<li>这种情况下，连接处于半关闭状态</li>
</ul>
</li>
<li>SHUT_RDWR<ul>
<li>同时关闭sockfd上的读和写</li>
</ul>
</li>
</ul>
</li>
<li>成功返回0，失败返回-1并设置errno</li>
</ul>
<h2 id="数据读写"><a href="#数据读写" class="headerlink" title="数据读写"></a>数据读写</h2><p>对文件的读写操作read和write同样适用于socket，但是socket编程接口提供了几个专门用于socket数据读写的系统调用</p>
<h3 id="TCP数据读写"><a href="#TCP数据读写" class="headerlink" title="TCP数据读写"></a>TCP数据读写</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>
<span class="token class-name">ssize_t</span> <span class="token function">recv</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> len<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ssize_t</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> len<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>recv——读取sockfd上的数据<ul>
<li>buf：设置缓冲区的位置</li>
<li>len：设置缓冲区的大小</li>
<li>成功时返回实际读取的数据的长度</li>
<li>返回0表示通信对方已经关闭连接</li>
<li>出错时返回-1并设置errno</li>
</ul>
</li>
<li>send——往sockfd上写入数据<ul>
<li>buf：设置缓冲区的位置</li>
<li>len：设置缓冲区的大小</li>
<li>成功时返回实际写入的数据的长度</li>
<li>失败返回-1并设置errno</li>
</ul>
</li>
</ul>
<hr>
<p><strong>flags参数的可选值</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项名</th>
<th>含义</th>
<th>send</th>
<th>recv</th>
</tr>
</thead>
<tbody>
<tr>
<td>MSG_CONFIRM</td>
<td>指示数据链路层协议痴心监听对方的回应，直到得到答复；仅能用于SOCK_DGRAM和SOCK_RAW类型的socket</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>MSG_DONTROUTE</td>
<td>不查看路由表，直接将数据发送给本地局域网络内的主机，表示发送者确切地知道目标主机就在本地网络上</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>MSG_DONTWAIT</td>
<td>对socket的此次操作将是非阻塞的</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>MSG_MORE</td>
<td>告诉内核应用程序还有更多数据要发送，内核将等待新数据写入TCP发送缓冲区后一并发送；这样可防止TCP发送过多小的报文端，从而提高传输效率</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>MSG_WAITALL</td>
<td>读操作仅在读取到指定数量的字节后才返回</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>MSG_PEEK</td>
<td>窥探读缓冲中的数据，此次读操作不会导致这些数据被清除</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>MSG_OOB</td>
<td>发送或接受紧急数据</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>MSG_NOSIGNAL</td>
<td>往读端关闭的管道或者socket连接中写数据时不引发SIGPIPE信号</td>
<td>Y</td>
<td>N</td>
</tr>
</tbody>
</table>
</div>
<h3 id="UDP数据读写"><a href="#UDP数据读写" class="headerlink" title="UDP数据读写"></a>UDP数据读写</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>
<span class="token class-name">ssize_t</span> <span class="token function">recvfrom</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> len<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span> src_addr<span class="token punctuation">,</span> <span class="token class-name">socklen_t</span><span class="token operator">*</span> addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ssize_t</span> <span class="token function">sendto</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> len<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span> dest_addr<span class="token punctuation">,</span> <span class="token class-name">socklen_t</span> addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>recvfrom读取sockfd上的数据，buf和len参数分别指定读缓冲区的位置和大小。因为UDP通信没有连接的概念，所以我们每次读取数据都需要获取发送端的socket地址，即参数src_addr所指的内容，addrlen参数则指定该地址的长度  </li>
<li>sendto往sockfd上写入数据，buf和len参数分别指定写缓冲区的位置和大小。dest_addr参数指定接收端的socket地址，addrlen参数则指定该地址的长度 </li>
<li>这两个系统调用的flags参数以及返回值的含义均与send/recv系统调用的flags参数及返回值相同 </li>
<li>recvfrom/sendto系统调用也可以用于面向连接（STREAM）的socket的数据读写，只需要把最后两个参数都设置为NULL以忽略发送端/接收端的socket地址（因为我们已经和对方建立了连接，所以已经知道其socket地址了）  </li>
</ul>
<h3 id="通用数据读写函数"><a href="#通用数据读写函数" class="headerlink" title="通用数据读写函数"></a>通用数据读写函数</h3><p>既能用于TCP流数据，也能用于UDP数据报</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>
<span class="token class-name">ssize_t</span> <span class="token function">recvmsg</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">msghdr</span><span class="token operator">*</span> msg<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ssize_t</span> <span class="token function">sendmsg</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">msghdr</span><span class="token operator">*</span> msg<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>sockfd参数指定被操作的目标socket</p>
</li>
<li><p>msg参数是msghdr结构体类型的指针</p>
<ul>
<li><p>msghdr结构体定义</p>
</li>
<li><p>```c<br>struct msghdr{</p>
<pre><code>void* msg_name;/*socket地址*/
socklen_t msg_namelen;/*socket地址的长度*/
struct iovec* msg_iov;/*分散的内存块，见后文*/
int msg_iovlen;/*分散内存块的数量*/
void* msg_control;/*指向辅助数据的起始位置*/
socklen_t msg_controllen;/*辅助数据的大小*/
int msg_flags;/*复制函数中的flags参数，并在调用过程中更新*/
</code></pre><p>};</p>
<pre class="line-numbers language-none"><code class="language-none">
- msg_name指向一个socket地址结构变量，指定通信对方的socket地址；对于面向连接的TCP协议，该成员没有意义，必须被设置位NULL，因为对方的地址已经知道

- msg_iov成员是iovec结构体类型的指针，结构体定义如下

- ```c
  struct iovec
  {
  	void* iov_base;/*内存起始地址*/
  	size_t iov_len;/*这块内存的长度*/
  };<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>msg_iovlen指定这样的iovec结构对象有多少个；对于recvmsg而言，数据将被读取并存放在msg_iovlen块分散的内存中，这些内存的位置和长度则由msg_iov指向的数组指定，这称为分散读（scatter read）；对于sendmsg而言，msg_iovlen块分散内存中的数据将被一并发送，这称为集中写（gather write）</p>
</li>
<li><p>recvmsg/sendmsg的flags参数以及返回值的含义均与send/recv的flags参数及返回值相同 </p>
</li>
</ul>
</li>
</ul>
<h2 id="带外标志"><a href="#带外标志" class="headerlink" title="带外标志"></a>带外标志</h2><p>在实际应用中，我们通常无法预期带外数据何时到来，好在Linux内核检测到TCP紧急标志时，将通知应用程序有带外数据需要接收</p>
<p>~注：TCP带外数据，即紧急模式下的接收和发送~</p>
<p><strong>两种常见方式</strong></p>
<ul>
<li>I/O复用产生的异常事件</li>
<li>SIGURG信号</li>
</ul>
<p><strong>sockatmark系统调用</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span>  <span class="token string">&lt;sys/socket.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">sockatmark</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>该系统调用判断sockfd是否处于带外标记，即下一个被读取到的数据是否是带外数据</li>
<li>如果是返回1，此时可以利用带MSG_OOB标志的recv调用来接收带外数据</li>
<li>如果不是，返回0</li>
</ul>
<h2 id="地址信息函数"><a href="#地址信息函数" class="headerlink" title="地址信息函数"></a>地址信息函数</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token expression">＜sys<span class="token operator">/</span>socket<span class="token punctuation">.</span>h＞</span></span>

<span class="token keyword">int</span> <span class="token function">getsockname</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span> address<span class="token punctuation">,</span> <span class="token class-name">socklen_t</span><span class="token operator">*</span> addresss_len<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">getpeername</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span> address<span class="token punctuation">,</span> <span class="token class-name">socklen_t</span><span class="token operator">*</span> address_len<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>getsockname获取sockfd对应的本端socket地址，并将其存储于address参数指定的内存中，该socket地址的长度则存储于address_len参数指向的变量中。如果实际socket地址的长度大于address所指内存区的大小，那么该socket地址将被截断  <ul>
<li>getsockname成功时返回0，失败返回-1并设置errno  </li>
</ul>
</li>
<li>getpeername获取sockfd对应的远端socket地址，其参数及返回值的含义与getsockname的参数及返回值相同  </li>
</ul>
<h2 id="socket选项"><a href="#socket选项" class="headerlink" title="socket选项"></a>socket选项</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/socket.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">getsockopt</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">int</span> level<span class="token punctuation">,</span> <span class="token keyword">int</span> option_name<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> option_value<span class="token punctuation">,</span> <span class="token class-name">socklen_t</span><span class="token operator">*</span> optlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">setsockopt</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">int</span> level<span class="token punctuation">,</span> <span class="token keyword">int</span> optionm_name<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> option_value<span class="token punctuation">,</span> <span class="token class-name">socklen_t</span> option_len<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li>sockfd指定被操作的目标socket</li>
<li>level指定要操作哪个协议的选项，比如IPv4、IPv6、TCP等</li>
<li>option_name 参数则指定选项的名字<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202312271554454.png" alt="image-20231227155435128"></li>
</ul>
</li>
<li>option_value指被操作选项的值</li>
<li>option_len指被操作选项的长度</li>
<li>两个函数成功时都返回0，失败是返回-1并设置errno</li>
</ul>
]]></content>
      <tags>
        <tag>C++ socket</tag>
      </tags>
  </entry>
  <entry>
    <title>多进程编程</title>
    <url>/2023/11/29/10-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">    

<h2 id="fork系统调用"><a href="#fork系统调用" class="headerlink" title="fork系统调用"></a>fork系统调用</h2><p>Linux创建新进程的系统调用是fork</p>
<span id="more"></span>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token class-name">pid_t</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li>该函数每次调用都返回两次，在父进程中返回的是子进程的PID，在子进程中则返回0</li>
<li>失败时返回-1并设置errno</li>
</ul>
<hr>
<ul>
<li>fork函数复制当前进程，在内核进程表中创建一个新的进程表项，新的进程表项有很多属性和原进程相同，比如堆指针、栈指针（复制了堆指针和栈指针，也就是父子进程的堆栈指针的值相同，但是堆栈指针都是虚拟地址，所以实际上父子进程拥有不同的堆栈空间）和标志寄存器的值，但也有许多属性被赋予新的值，比如该进程的PPID被设置成原进程的PID，信号位图被清除（原进程设置的信号处理函数不再堆新进程起作用）</li>
<li>子进程的代码和父进程完全相同，同时它还会复制父进程的数据（堆数据、栈数据和静态数据），数据的复制采用的是所谓的写时复制，即只有在任一进程（父进程或子进程）对数据执行了写操作，复制才会发生（先是缺页中断，然后操作系统给子进程分配内存并复制父进程的数据）</li>
<li>创建子进程后，父进程中打开的文件描述符默认在子进程中也是打开的，且文件描述符的引用计数加1，父进程的用户根目录、当前工作目录等变量的引用计数均会加1</li>
</ul>
<h2 id="exec系列系统调用"><a href="#exec系列系统调用" class="headerlink" title="exec系列系统调用"></a>exec系列系统调用</h2><p>exec系列函数用于在子进程中执行其他程序，即替换当前进程映像</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token keyword">extern</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> environ<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">execl</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> path<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> arg<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">execlp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> file<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> arg<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">execle</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> path<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> arg<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span><span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> envp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">execv</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> path<span class="token punctuation">,</span><span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">execvp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> file<span class="token punctuation">,</span><span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">execve</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> path<span class="token punctuation">,</span><span class="token keyword">char</span><span class="token operator">*</span>  <span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> envp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>path参数指定可执行文件的完整路径</li>
<li>file参数可以接受文件名，该文件的具体位置则仔环境变量PATH中搜寻</li>
<li>arg接受可变参数，argv则接受参数数组，它们都会被传递给新程序的main函数</li>
<li>envp参数用于设置新程序的环境变量，如果未设置，则新程序将使用由全局变量environ指定的环境变量</li>
<li>一般不返回结果，出错时返回-1并设置errno，如果不出错，则源程序exec调用之后的代码都不会执行</li>
<li>exec函数不会关闭原程序打开的文件描述符，除非该文件描述符被设置了类似SOCK_CLOEXEC的属性</li>
</ul>
<h2 id="处理僵尸进程"><a href="#处理僵尸进程" class="headerlink" title="处理僵尸进程"></a>处理僵尸进程</h2><p><strong>僵尸态</strong></p>
<ul>
<li>当子进程结束运行时，内核不会立即释放该进程的进程表项，以满足父进程后续对该子进程退出信息的查询，在子进程结束运行之后，父进程读取其退出状态之前，该子进程处于僵尸态</li>
<li>父进程结束或异常终止，而子进程仍在继续运行，此时子进程也处于僵尸态，此时子进程的PPID将被操作系统设置为1，即init进程</li>
</ul>
<hr>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h&gt;</span></span>
<span class="token class-name">pid_t</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> stat_loc<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">pid_t</span> <span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> stat_loc<span class="token punctuation">,</span> <span class="token keyword">int</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>wait函数将阻塞进程，直到该进程的某个子进程结束运行为止，它返回结束运行的子进程的PID，并将该子进程的退出状态信息存储于stat_loc参数指向的内存中</li>
<li><p>子进程退出状态信息</p>
<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202401131401231.png" alt="image-20240113140045724"></li>
</ul>
</li>
<li><p>waitpid函数只等待由pid参数指定的子进程，如果pid为-1，则与wait函数相同，等待任意一个子进程结束</p>
</li>
<li>options参数可以控制waitpid函数的行为，最常用的参数取值是WNOHANG，此时waitpid调用将是非阻塞的，如果pid指定的目标子进程还没有结束或意外终止，则waitpid立即返回0，如果目标子进程正常退出了，则返回该子进程的PID</li>
<li>waitpid失败时返回-1并设置errno</li>
</ul>
<hr>
<p><strong>SIGCHLD信号</strong></p>
<ul>
<li>当一个进程结束时，它将给其父进程发送一个SIGCHLD信号</li>
</ul>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道能在父子进程之间传递数据，因为fork调用之后两个管道文件描述符都保持打开，一对管道文件描述符只能保证父子进程间一个方向的数据传输，父子进程必须有一个关闭fd[0]，另一个关闭fd[1]，如果要实现双向数据传输，就必须使用两个管道</p>
<p>socket编程接口提供了一个创建全双工管道的系统调用：socketpair</p>
<p>管道只能用于有关联的两个进程间的通信，而FIFO管道（命名管道）可以用于无关联进程之间的通信，但在网络编程中使用不多</p>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/202401131412121.png" alt="image-20240113141217711"></p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><h3 id="信号量原语"><a href="#信号量原语" class="headerlink" title="信号量原语"></a>信号量原语</h3><p><strong>临界区（关键代码段）</strong></p>
<ul>
<li>当多个进程同时访问系统上的某个资源时或者同时修改某个文件，就需要考虑进程的同步问题，以确保任一时刻只有一个进程可以拥有对资源的独占式访问</li>
<li>程序对共享资源的访问的代码只是很短的一段，但就是这一段代码引发了进程之间的竞态条件，这段代码被称为关键代码段或者临界区</li>
</ul>
<p><strong>信号量</strong></p>
<ul>
<li>信号量时一种特殊的变量，它只能取自然数值并且只支持两种操作<ul>
<li>等待（wait）-P操作（passeren，传递）</li>
<li>信号（signal）-V操作（vrijgeven，释放）</li>
</ul>
</li>
<li>假设有信号量SV<ul>
<li>P(SV)，如果SV的值大于0，就将它减一；如果SV的值为0，则挂起进程的执行</li>
<li>V(SV)，如果有其他进程因为等待SV而挂起，则唤醒其中一个；如果没有，则将SV的值加一</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202401131429356.png" alt="image-20240113142952934"></li>
</ul>
</li>
</ul>
<h3 id="semget系统调用"><a href="#semget系统调用" class="headerlink" title="semget系统调用"></a>semget系统调用</h3><p>semget系统调用用于创建一个新的信号量集，或者获取一个已经存在的信号量集</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/sem.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">semget</span><span class="token punctuation">(</span><span class="token class-name">key_t</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> num_sems<span class="token punctuation">,</span> <span class="token keyword">int</span> sem_flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>key参数是一个键值，用来表示一个全局唯一的信号量集，要通过信号量通信的进程需要使用相同的键值来创建/获取该信号量</li>
<li>num_sems参数指定要创建/获取的信号量集中信号量的数目<ul>
<li>如果是创建信号量，则该值必须被指定</li>
<li>如果是获取已经存在的信号量，则可以设置为0</li>
</ul>
</li>
<li>sem_flags参数指定一组标志<ul>
<li>低端的9个比特是该信号量的权限，其格式和含义都与系统调用open的mode参数相同</li>
<li>可以和IPC_CREAT标志做按位或以创建新的信号量集，此时即使信号量已经存在（返回原先存在的信号集），也不会产生错误</li>
<li>可以联合使用IPC_CREAT和IPC_EXCL标志来确保创建一组新的、唯一的信号量集，如果信号量集已经存在，则返回错误并设置errno为EEXIST</li>
</ul>
</li>
<li>成功时返回一个正整数值，它是信号量集的标识符</li>
<li>失败时返回-1并设置errno</li>
</ul>
<hr>
<p>如果semget用于创建信号量集，则与之关联的内核数据结构体semid_ds将被创建并初始化</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/sem.h&gt;</span></span>
<span class="token comment">/*该结构体用于描述IPC对象(信号量、共享内存和消息队列)的权限*/</span>
<span class="token keyword">struct</span> <span class="token class-name">ipc_perm</span><span class="token punctuation">{</span>
    <span class="token class-name">key_t</span> key<span class="token punctuation">;</span><span class="token comment">/*键值*/</span>
    <span class="token class-name">uid_t</span> uid<span class="token punctuation">;</span><span class="token comment">/*所有者的有效用户ID*/</span>
    <span class="token class-name">gid_t</span> gid<span class="token punctuation">;</span><span class="token comment">/*所有者的有效组ID*/</span>
    <span class="token class-name">uid_t</span> cuid<span class="token punctuation">;</span><span class="token comment">/*创建者的有效用户ID*/</span>
    <span class="token class-name">gid_t</span> cgid<span class="token punctuation">;</span><span class="token comment">/*创建者的有效组ID*/</span>
    <span class="token class-name">mode_t</span> mode<span class="token punctuation">;</span><span class="token comment">/*访问权限*/</span>
    <span class="token comment">/*省略其他填充字段*/</span>
<span class="token punctuation">}</span>
<span class="token keyword">struct</span> <span class="token class-name">semid_ds</span><span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">ipc_perm</span> sem_perm<span class="token punctuation">;</span><span class="token comment">/*信号量的操作权限*/</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">int</span> sem_nsems<span class="token punctuation">;</span><span class="token comment">/*该信号量集中的信号量数目*/</span>
    <span class="token class-name">time_t</span> sem_otime<span class="token punctuation">;</span><span class="token comment">/*最后一次调用semop的时间*/</span>
    <span class="token class-name">time_t</span> sem_ctime<span class="token punctuation">;</span><span class="token comment">/*最后一次调用semctl的时间*/</span>
    <span class="token comment">/*省略其他填充字段*/</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>初始化包括</p>
<ul>
<li>将sem_perm.cuid和sem_prem.uid设置为调用进程的有效用户ID</li>
<li>将sem_perm.cgid和sem_perm.gid设置为调用进程的有效组ID</li>
<li>将sem_perm.mode的最低9位设置为sem_flags参数的最低9位</li>
<li>将sem_nsems设置位num_sems</li>
<li>将sem_otime设置为0</li>
<li>将sem_ctime设置为当前的系统时间</li>
</ul>
<h3 id="semop系统调用"><a href="#semop系统调用" class="headerlink" title="semop系统调用"></a>semop系统调用</h3><p><strong>每个信号量关联的一些重要的内核变量</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">short</span> semval<span class="token punctuation">;</span>
<span class="token comment">/*信号量的值*/</span>
<span class="token keyword">unsigned</span> <span class="token keyword">short</span> semzcnt<span class="token punctuation">;</span>
<span class="token comment">/*等待信号量值变为0的进程数量*/</span>
<span class="token keyword">unsigned</span> <span class="token keyword">short</span> semncnt<span class="token punctuation">;</span>
<span class="token comment">/*等待信号量值增加的进程数量*/</span>
<span class="token class-name">pid_t</span> sempid<span class="token punctuation">;</span>
<span class="token comment">/*最后一次执行semop操作的进程ID*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<p><strong>semop系统调用改变信号量的值，即执行P、V操作</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">semop</span><span class="token punctuation">(</span><span class="token keyword">int</span> sem_id<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sembuf</span><span class="token operator">*</span> sem_ops<span class="token punctuation">,</span> <span class="token class-name">size_t</span> num_sem_ops<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li><p>sem_id参数是由semget调用返回的信号量集标识符，用以指定被操作的目标信号量集</p>
</li>
<li><p>semops参数指向一个sembuf结构体类型的数组</p>
<ul>
<li>```c<br>struct sembuf{<pre><code>unsigned short int sem_num;
short int sem_op;
short int sem_flg;
</code></pre>}<pre class="line-numbers language-none"><code class="language-none">
  - sem_num成员是信号量集中信号量的编号

    - 0表示信号量集中的第一个编号

  - sem_flg的可选值

    - IPC_NOWAIT，无论信号量操作是否成功，semop调用都将立即返回，类似无阻塞I/O操作
    - SEM_UNDO，当进程退出时取消正在进行的semop操作

  - sem_op成员指定操作类型

    - 可选值为0、正负整数
    - 每种类型的操作的行为收到sem_flg成员的影响
    - sem_op大于0，则semop将被操作的信号量的值semval增加sem_op，该操作要求调用进程对被操作信号量集拥有写权限，此时若设置了SEM_UNDO标志，则系统将更新进程的semadj变量（用以根据进程对信号量的修改情况）
    - sme_op等于0，则表示这是一个”等待0“操作，该操作要求调用进程对被操作信号量集拥有读权限，如果此时信号量的值是0，则调用立即成功返回，如果不是0，则semop失败或者阻塞进程以等待信号量变为0，并且：
      - 当IPC_NOWAIT标志被指定时，semop立即返回一个错误，并设置errno为EAGAIN
      - 如果未指定IPC_NOWAIT标志，则信号量的semzcnt值加1，进程被投入睡眠直到（三者其中之一发生）
        1. 信号量的值semval变为0，此时系统将该信号量的semzcnt减一
        2. 被操作信号量所在的信号量集被进程移除，此时semop调用失败，errno被设置为EIDRM
        3. 调用被信号中断，此时semop调用失败返回，errno被设置为EINTR，同时系统将该信号量的semzcnt值减一
    - sem_op小于0，则表示对该信号量值进行减操作，即期望获得该信号量，该操作要求调用进程对被操作信号集拥有写权限
      - 如果信号量的值semval大于或等于sem_op的绝对值，则semop操作成功，调用进程立即获得信号量，并且系统将该信号量的semval值减去sem_op的绝对值
        - 如果此时设置了SEM_UNDO标志，则系统将更新进程的semadj变量
      - 如果信号量的值semval小于sem_op的绝对值，则semop失败返回或者阻塞进程以等待信号量可用
        - 当IPC_NOWAIT标志被指定时，semop立即返回一个错误，并设置errno未EAGAIN
        - 未指定IPC_NOWAIT时，信号量的semncnt值加1，进程被投入睡眠直到（三者其中之一发生）：
          1. 信号量的值semval变得大于或等于sem_op的绝对值，此时系统将信号量的semncnt值减一，并将semval减去sem_op的绝对值，同时如果SEM_UNDO被设置，则系统更新semadj变量
          2. 被操作信号量所在的信号量集被进程移除，此时semop调用失败返回，errno被设置未EIDRM
          3. 调用被信号中断，此时semop调用失败返回，errno被设置未EINTR，同时系统将该信号量的semncnt值减一

- num_sem_ops指定要执行的操作个数，即sem_ops数组中元素的个数，semop对sem_ops中的每个成员按照数组顺序依次执行操作，并且该过程是原子操作，以避免别的进程在同一时刻按照不同的顺序对该信号集中的信号量执行semop操作

- 成功时返回0，失败时返回-1并设置errno，失败时，sem_ops数组中指定的所有操作都不被执行

### semctl系统调用

semctl系统调用允许调用者对信号量进行直接控制

```c
#include &lt;sys/sem.h&gt;
int semctl(int sem_id, int sem_num, int command, ...);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p>sem_id参数是由semget调用返回的信号量集标识符，用以指定被操作的信号量集</p>
</li>
<li><p>sem_num参数指定被操作的信号量在信号量集中的编号</p>
</li>
<li><p>command参数指定要执行的命令，有的命令需要调用者传递第四个参数</p>
<ul>
<li><p>支持的命令</p>
</li>
<li><p><img src="https://gitee.com/renmale-sztu/image/raw/master/202401131555515.png" alt="image-20240113155503582"></p>
</li>
<li><p>第四个参数</p>
</li>
<li><p>```c<br>union semun{</p>
<pre><code>int val;/*用于SETVAL命令*/
struct semid_ds*buf;/*用于IPC_STAT和IPC_SET命令*/
unsigned short*array;/*用于GETALL和SETALL命令*/
struct seminfo*__buf;/*用于IPC_INFO命令*/
</code></pre><p>};<br>struct seminfo{</p>
<pre><code>int semmap;/*Linux内核没有使用*/
int semmni;/*系统最多可以拥有的信号量集数目*/
int semmns;/*系统最多可以拥有的信号量数目*/
int semmnu;/*Linux内核没有使用*/
int semmsl;/*一个信号量集最多允许包含的信号量数目*/
int semopm;/*semop一次最多能执行的sem_op操作数目*/
int semume;/*Linux内核没有使用*/
int semusz;/*sem_undo结构体的大小*/
int semvmx;/*最大允许的信号量值*/
/*最多允许的UNDO次数(带SEM_UNDO标志的semop操作的次数)*/
int semaem;
</code></pre><p>};</p>
<pre class="line-numbers language-none"><code class="language-none">
- 成功时返回值取决于command参数，失败时返回-1并设置errno

### 特殊键值IPC_PRIVATE

semget的调用者可以给其key参数传递一个特殊的键值IPC_PRIVATE（其值为0），这样无论该信号量是否已经存在，semget都将创建创建一个新的信号量

名字有些误导，应该称为IPC_NEW

---

**使用IPC_PRIVATE信号量**

```c
#include &lt;sys/sem.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/wait.h&gt;

union semun{
    int val;
    struct semid_ds* buf;
    unsigned short int* array;
    struct seminfo* __buf;
};

/*op为-1时执行P操作,op为1时执行V操作*/
void pv(int sem_id,int op){
    struct sembuf sem_b;
    sem_b.sem_num=0;
    sem_b.sem_op=op;
    sem_b.sem_flg=SEM_UNDO;
    semop(sem_id,&amp;sem_b,1);
}

int main(int argc,char* argv[]){
    //创建一个新的信号量
	int sem_id=semget(IPC_PRIVATE,1,0666);
	union semun sem_un;
	sem_un.val=1;
    //设置信号量的值为1
	semctl(sem_id,0,SETVAL,sem_un);
    //创建子进程
	pid_t id=fork();
	if(id&lt;0){
        //创建失败
		return 1;
	}
	else if(id==0){
        //子进程
		printf("child try to get binary sem\n");
		/*在父、子进程间共享IPC_PRIVATE信号量的关键就在于二者都可以操作该信号量的标识符sem_id*/
		pv(sem_id,-1);
		printf("child get the sem and would release it after 5 seconds\n");
		sleep(5);
		pv(sem_id,1);
		exit(0);
	}
	else{
        //父进程
		printf("parent try to get binary sem\n");
		pv(sem_id,-1);
		printf("parent get the sem and would release it after 5 seconds\n");
        sleep(5);
        pv(sem_id,1);
	}
	waitpid(id,NULL,0);
	semctl(sem_id,0,IPC_RMID,sem_un);/*删除信号量*/
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>共享内存是最高效的IPC机制，因为它不涉及进程之间的任何数据传输，这种高效率带来的问题是，我们必须用其他辅助手段来同步进程对共享内存的访问，否则会产生竞态条件</p>
<h3 id="shmget系统调用"><a href="#shmget系统调用" class="headerlink" title="shmget系统调用"></a>shmget系统调用</h3><p>shmget系统调用创建一段新的共享内存，或者获取一段已经存在的共享内存</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/shm.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">shmget</span><span class="token punctuation">(</span><span class="token class-name">key_t</span> key<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token keyword">int</span> shmflg<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>key参数是一个键值，用来标识一段全局唯一的共享内存</li>
<li>size参数指定共享内存的大小，单位是字节，如果是创建新的共享内存，则size值必须被指定，如果是获取，可以设置为0</li>
<li>sgmflg参数的使用和含义于semget系统调用的sem_flags参数相同，不过shmget支持两个额外的标志<ul>
<li>SHM_HUGETLB，系统将使用”大页面“来为共享内存分配空间</li>
<li>SHM_NORESERVE，不为共享内存保留交换分区（swap空间），这样，当物理内存不足的时候，对该共享内存执行写操作将触发SIGSEGV信号</li>
</ul>
</li>
<li>成功时返回一个正整数值，是共享内存的标识符，失败时返回-1并设置errno</li>
</ul>
<hr>
<p>如果shmget用于创建共享内存，则这段内存的所有字节都被初始化为0，与之关联的内核数据结构shmid_ds将被创建并初始化</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">shmid_ds</span><span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">ipc_perm</span> shm_perm<span class="token punctuation">;</span><span class="token comment">/*共享内存的操作权限*/</span>
    <span class="token class-name">size_t</span> shm_segsz<span class="token punctuation">;</span><span class="token comment">/*共享内存大小,单位是字节*/</span>
    __time_t shm_atime<span class="token punctuation">;</span><span class="token comment">/*对这段内存最后一次调用shmat的时间*/</span>
    __time_t shm_dtime<span class="token punctuation">;</span><span class="token comment">/*对这段内存最后一次调用shmdt的时间*/</span>
    __time_t shm_ctime<span class="token punctuation">;</span><span class="token comment">/*对这段内存最后一次调用shmctl的时间*/</span>
    __pid_t shm_cpid<span class="token punctuation">;</span><span class="token comment">/*创建者的PID*/</span>
    __pid_t shm_lpid<span class="token punctuation">;</span><span class="token comment">/*最后一次执行shmat或shmdt操作的进程的PID*/</span>
    <span class="token class-name">shmatt_t</span> shm_nattach<span class="token punctuation">;</span><span class="token comment">/*目前关联到此共享内存的进程数量*/</span>
    <span class="token comment">/*省略一些填充字段*/</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">ipc_perm</span><span class="token punctuation">{</span>
    <span class="token class-name">key_t</span> key<span class="token punctuation">;</span><span class="token comment">/*键值*/</span>
    <span class="token class-name">uid_t</span> uid<span class="token punctuation">;</span><span class="token comment">/*所有者的有效用户ID*/</span>
    <span class="token class-name">gid_t</span> gid<span class="token punctuation">;</span><span class="token comment">/*所有者的有效组ID*/</span>
    <span class="token class-name">uid_t</span> cuid<span class="token punctuation">;</span><span class="token comment">/*创建者的有效用户ID*/</span>
    <span class="token class-name">gid_t</span> cgid<span class="token punctuation">;</span><span class="token comment">/*创建者的有效组ID*/</span>
    <span class="token class-name">mode_t</span> mode<span class="token punctuation">;</span><span class="token comment">/*访问权限*/</span>
    <span class="token comment">/*省略其他填充字段*/</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>初始化包括</p>
<ul>
<li>将shm_prem.cuid和shm_perm.uid设置为调用进程的有效用户ID</li>
<li>将shm_perm.cgid和shm_perm.gid设置为调用进程的有效组ID</li>
<li>将shm_perm.mode的最低9位设置位shmflg参数的最低9位</li>
<li>将shm_segsz设置为size</li>
<li>将shm_lpid、shm_nattach、shm_atime、shm_dtime设置为0</li>
<li>将shm_ctime设置为当前时间</li>
</ul>
<h3 id="shmat和shmdt系统调用"><a href="#shmat和shmdt系统调用" class="headerlink" title="shmat和shmdt系统调用"></a>shmat和shmdt系统调用</h3><p>共享内存被创建后，需要先将它关联到进程的地址空间中，使用完共享内存后，也需要将它总进程地址空间中分离</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/shm.h&gt;</span></span>
<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">shmat</span><span class="token punctuation">(</span><span class="token keyword">int</span> shm_id<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> shm_addr<span class="token punctuation">,</span> <span class="token keyword">int</span> shmflg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">shmdt</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> shm_addr<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li>shm_id参数是由shemget调用返回的共享内存标识符</li>
<li>shm_addr参数指定将共享内存关联到进程的哪块地址空间，最终效果还受到shmflg参数的可选标志SHM_RND的影响<ul>
<li>如果shm_addr为NULL，则被关联的地址由操作系统选择（推荐做法）</li>
<li>如果shm_addr非空，并且SHM_RND标志未被设置，则共享内存被关联到addr指定的地址处</li>
<li>如果shm_addr非空，并且设置了SHM_RND标志，则被关联的地址是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="35.985ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 15905.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(278,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(747,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g><g data-mml-node="msub" transform="translate(1323,0)"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(911,-150) scale(0.707)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g></g><g data-mml-node="mi" transform="translate(2658.1,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mi" transform="translate(3178.1,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mi" transform="translate(3698.1,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(4371.3,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mo" transform="translate(5371.5,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(5760.5,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(6229.5,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g><g data-mml-node="msub" transform="translate(6805.5,0)"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(911,-150) scale(0.707)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g></g><g data-mml-node="mi" transform="translate(8140.6,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mi" transform="translate(8660.6,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mi" transform="translate(9180.6,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(9631.6,0)"><path data-c="25" d="M465 605Q428 605 394 614T340 632T319 641Q332 608 332 548Q332 458 293 403T202 347Q145 347 101 402T56 548Q56 637 101 693T202 750Q241 750 272 719Q359 642 464 642Q580 642 650 732Q662 748 668 749Q670 750 673 750Q682 750 688 743T693 726Q178 -47 170 -52Q166 -56 160 -56Q147 -56 142 -45Q137 -36 142 -27Q143 -24 363 304Q469 462 525 546T581 630Q528 605 465 605ZM207 385Q235 385 263 427T292 548Q292 617 267 664T200 712Q193 712 186 709T167 698T147 668T134 615Q132 595 132 548V527Q132 436 165 403Q183 385 203 385H207ZM500 146Q500 234 544 290T647 347Q699 347 737 292T776 146T737 0T646 -56Q590 -56 545 0T500 146ZM651 -18Q679 -18 707 24T736 146Q736 215 711 262T644 309Q637 309 630 306T611 295T591 265T578 212Q577 200 577 146V124Q577 -18 647 -18H651Z"></path></g><g data-mml-node="mi" transform="translate(10464.6,0)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path></g><g data-mml-node="mi" transform="translate(11109.6,0)"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mi" transform="translate(11997.6,0)"><path data-c="1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"></path></g><g data-mml-node="mi" transform="translate(13048.6,0)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mi" transform="translate(13729.6,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g><g data-mml-node="mi" transform="translate(14488.6,0)"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mo" transform="translate(15238.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(15627.6,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g></g></g></svg></mjx-container>，SHMLBA的含义是”段低端边界地址倍数“，它必须是内存页面大小的整数倍，在Linux内核中，它等于一个内存页的大小，SHM_RND的含义是圆整（round），即将共享内存被关联的地址向下圆整到离shm_addr最近SHMLBA的整数倍地址处</li>
</ul>
</li>
<li>除了SHM_RND外，shmflg还支持如下标志<ul>
<li>SHM_RDONLY，进程仅能读取共享内存中的内容</li>
<li>SHM_REMAP，如果地址shmaddr已经被关联到一段共享内存中，则重新关联</li>
<li>SHM_EXEC，指定对共享内存段的执行权限，对共享内存而言，执行权限实际上和读权限是一样的</li>
</ul>
</li>
</ul>
<hr>
<p>shmat成功时返回共享内存被关联的地址，失败则返回(void*)-1并设置errno</p>
<p>shmat成功时，将修改内核数据结构shmid_ds的部分字段：</p>
<ul>
<li>将shm_nattach加一</li>
<li>将shm_lpid设置为调用进程的PID</li>
<li>将shm_atime设置为当前的时间</li>
</ul>
<hr>
<p>shmdt将关联到shm_addr处的共享内存从进程中分离，成功时返回0，失败时返回-1并设置errno</p>
<p>shmdt在成功调用时将修改内核数据结构shmid_ds的部分字段：</p>
<ul>
<li>将shm_nattach减一</li>
<li>将shm_lpid设置为调用进程的PID</li>
<li>将shm_atime设置为当前的时间</li>
</ul>
<h3 id="shmctl系统调用"><a href="#shmctl系统调用" class="headerlink" title="shmctl系统调用"></a>shmctl系统调用</h3><p>shmctl系统调用控制共享内存的某些属性</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/shm.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">shmctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> shm_id<span class="token punctuation">,</span> <span class="token keyword">int</span> command<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">shmid_ds</span><span class="token operator">*</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>shm_id参数是由shmget调用返回的共享内存标识符</li>
<li>command参数指定要执行的命令<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202401141509684.png" alt="image-20240114150951584"></li>
</ul>
</li>
<li>成功时的返回值取决于command参数，失败时返回-1，并设置errno</li>
</ul>
<h3 id="共享内存的POSIX方法"><a href="#共享内存的POSIX方法" class="headerlink" title="共享内存的POSIX方法"></a>共享内存的POSIX方法</h3><p>mmap函数利用MAP_ANONYMOUS标志可以实现父、子进程之间的匿名内存共享，通过打开同一个文件，mmap也可以实现无关进程之间的内存共享，Linux提供了另外一种利用mmap在无关进程之间共享内存的方式，这种方式无须任何文件的支持，但需要先使用如下函数来创建或打开一个POSIX共享内存对象</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/mman.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">shm_open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> oflag<span class="token punctuation">,</span> <span class="token class-name">mode_t</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>name参数指定要创建/打开的共享内存对象</li>
<li>oflag参数指定创建方式，可以是一下标志的一个或多个的按位或：<ul>
<li>O_RDONLY，以只读方式打开共享内存对象</li>
<li>O_RDWR，以可读、可写方式打开共享内存对象</li>
<li>O_CREAT，如果共享内存对象不存在，则创建之，此时mode参数的最低9位将指定该共享内存对象的访问权限，共享内存被创建时，其初始长度为0</li>
<li>O_EXCL，和O_CREAT一起使用，如果由name指定的共享内存对象已经存在，则shm_open调用返回错误，否则就创建一个新的共享内存对象</li>
<li>O_TRUNC，如果共享内存对象已经存在，则把它截断，使其长度为0</li>
</ul>
</li>
<li>成功时返回一个文件描述符，该文件描述符可用于后续的mmap调用，从而将共享内存关联到调用进程，失败时返回-1，并设置errno</li>
</ul>
<hr>
<p>由shm_open创建的共享内存对象使用完之后需要被删除</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/mman.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">shm_unlink</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>该函数将name参数指定的共享内存对象标记为等待删除，当所有使用该共享内存对象的进程都是用ummap将它从进程中分离后，系统将销毁这个共享内存对象所占据的资源</li>
</ul>
<hr>
<p>如果代码中使用了POSIX共享内存函数，则编译的时候需要指定连接选项-lrt</p>
<h3 id="共享内存实例"><a href="#共享内存实例" class="headerlink" title="共享内存实例"></a>共享内存实例</h3><p><strong>使用共享内存的聊天室服务器程序（客户端见前面文章）</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netinet/in.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;errno.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/epoll.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/mman.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">USER_LIMIT</span> <span class="token expression"><span class="token number">5</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BUFFER_SIZE</span> <span class="token expression"><span class="token number">1024</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FD_LIMIT</span> <span class="token expression"><span class="token number">65535</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_EVENT_NUMBER</span> <span class="token expression"><span class="token number">1024</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PROCESS_LIMIT</span> <span class="token expression"><span class="token number">65536</span></span></span>

<span class="token comment">/*处理一个客户连接必要的数据*/</span>
<span class="token keyword">struct</span> <span class="token class-name">client_data</span><span class="token punctuation">{</span>
    sockaddr_in address<span class="token punctuation">;</span><span class="token comment">/*客户端的socket地址*/</span>
    <span class="token keyword">int</span> connfd<span class="token punctuation">;</span><span class="token comment">/*socket文件描述符*/</span>
    <span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span><span class="token comment">/*处理这个连接的子进程的PID*/</span>
    <span class="token keyword">int</span> pipefd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">/*和父进程通信用的管道*/</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> shm_name<span class="token operator">=</span><span class="token string">"/my_shm"</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> sig_pipefd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> epollfd<span class="token punctuation">;</span>
<span class="token keyword">int</span> listenfd<span class="token punctuation">;</span>
<span class="token keyword">int</span> shmfd<span class="token punctuation">;</span>
<span class="token keyword">char</span><span class="token operator">*</span> share_mem<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token comment">/*客户连接数组。进程用客户连接的编号来索引这个数组,即可取得相关的客户连接数据*/</span>
client_data<span class="token operator">*</span>users<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token comment">/*子进程和客户连接的映射关系表。用进程的PID来索引这个数组,即可取得该进程所处理的客户连接的编号*/</span>
<span class="token keyword">int</span><span class="token operator">*</span>sub_process<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token comment">/*当前客户数量*/</span>
<span class="token keyword">int</span> user_count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
bool stop_child<span class="token operator">=</span>false<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">setnonblocking</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> old_option<span class="token operator">=</span><span class="token function">fcntl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>F_GETFL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> new_option<span class="token operator">=</span>old_option<span class="token operator">|</span>O_NONBLOCK<span class="token punctuation">;</span>
    <span class="token function">fcntl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>F_SETFL<span class="token punctuation">,</span>new_option<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> old_option<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">addfd</span><span class="token punctuation">(</span><span class="token keyword">int</span> epollfd<span class="token punctuation">,</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">{</span>
    epoll_event event<span class="token punctuation">;</span>
    event<span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd<span class="token operator">=</span>fd<span class="token punctuation">;</span>
    <span class="token comment">//以边沿触发模式监听可读事件</span>
    event<span class="token punctuation">.</span>events<span class="token operator">=</span>EPOLLIN<span class="token operator">|</span>EPOLLET<span class="token punctuation">;</span>
    <span class="token function">epoll_ctl</span><span class="token punctuation">(</span>epollfd<span class="token punctuation">,</span>EPOLL_CTL_ADD<span class="token punctuation">,</span>fd<span class="token punctuation">,</span><span class="token operator">&amp;</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setnonblocking</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">sig_handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> save_errno<span class="token operator">=</span>errno<span class="token punctuation">;</span>
    <span class="token keyword">int</span> msg<span class="token operator">=</span>sig<span class="token punctuation">;</span>
    <span class="token function">send</span><span class="token punctuation">(</span>sig_pipefd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>msg<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    errno<span class="token operator">=</span>save_errno<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">addsig</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">,</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span>handler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span>bool restart<span class="token operator">=</span>true<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">sigaction</span> sa<span class="token punctuation">;</span>
    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sa<span class="token punctuation">,</span><span class="token char">'\0'</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>sa<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    sa<span class="token punctuation">.</span>sa_handler<span class="token operator">=</span>handler<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>restart<span class="token punctuation">)</span><span class="token punctuation">{</span>
    	sa<span class="token punctuation">.</span>sa_flags<span class="token operator">|=</span>SA_RESTART<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
	<span class="token function">sigfillset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sa<span class="token punctuation">.</span>sa_mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span><span class="token function">sigaction</span><span class="token punctuation">(</span>sig<span class="token punctuation">,</span><span class="token operator">&amp;</span>sa<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">del_resource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">close</span><span class="token punctuation">(</span>sig_pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>sig_pipefd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>epollfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">shm_unlink</span><span class="token punctuation">(</span>shm_name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    delete<span class="token punctuation">[</span><span class="token punctuation">]</span>users<span class="token punctuation">;</span>
    delete<span class="token punctuation">[</span><span class="token punctuation">]</span>sub_process<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*停止一个子进程*/</span>
<span class="token keyword">void</span> <span class="token function">child_term_handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">)</span><span class="token punctuation">{</span>
	stop_child<span class="token operator">=</span>true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*子进程运行的函数。参数idx指出该子进程处理的客户连接的编号,users是保存所有客户连接数据的数组,参数share_mem指出共享内存的起始地址*/</span>
<span class="token keyword">int</span> <span class="token function">run_child</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">,</span>client_data<span class="token operator">*</span> users<span class="token punctuation">,</span><span class="token keyword">char</span><span class="token operator">*</span> share_mem<span class="token punctuation">)</span><span class="token punctuation">{</span>
	epoll_event events<span class="token punctuation">[</span>MAX_EVENT_NUMBER<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token comment">/*子进程使用I/O复用技术来同时监听两个文件描述符:客户连接socket、与父进程通信的管道文件描述符*/</span>
    <span class="token keyword">int</span> child_epollfd<span class="token operator">=</span><span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>child_epollfd<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> connfd<span class="token operator">=</span>users<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span>connfd<span class="token punctuation">;</span>
    <span class="token function">addfd</span><span class="token punctuation">(</span>child_epollfd<span class="token punctuation">,</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> pipefd<span class="token operator">=</span>users<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span>pipefd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">addfd</span><span class="token punctuation">(</span>child_epollfd<span class="token punctuation">,</span>pipefd<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> ret<span class="token punctuation">;</span>
	<span class="token comment">/*子进程需要设置自己的信号处理函数*/</span>
	<span class="token function">addsig</span><span class="token punctuation">(</span>SIGTERM<span class="token punctuation">,</span>child_term_handler<span class="token punctuation">,</span>false<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stop_child<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">int</span> number<span class="token operator">=</span><span class="token function">epoll_wait</span><span class="token punctuation">(</span>child_epollfd<span class="token punctuation">,</span>events<span class="token punctuation">,</span>MAX_EVENT_NUMBER<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>number<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>errno<span class="token operator">!=</span>EINTR<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"epoll failure\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>number<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">int</span> sockfd<span class="token operator">=</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd<span class="token punctuation">;</span>
            <span class="token comment">/*本子进程负责的客户连接有数据到达*/</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>sockfd<span class="token operator">==</span>connfd<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events<span class="token operator">&amp;</span>EPOLLIN<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token function">memset</span><span class="token punctuation">(</span>share_mem<span class="token operator">+</span>idx<span class="token operator">*</span>BUFFER_SIZE<span class="token punctuation">,</span><span class="token char">'\0'</span><span class="token punctuation">,</span>BUFFER_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">/*将客户数据读取到对应的读缓存中。该读缓存是共享内存的一段,它开始于idx*BUFFER_SIZE处,长度为BUFFER_SIZE字节。因此,各个客户连接的读缓存是共享的*/</span>
                ret<span class="token operator">=</span><span class="token function">recv</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span>share_mem<span class="token operator">+</span>idx<span class="token operator">*</span>BUFFER_SIZE<span class="token punctuation">,</span>BUFFER_SIZE<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token keyword">if</span><span class="token punctuation">(</span>errno<span class="token operator">!=</span>EAGAIN<span class="token punctuation">)</span><span class="token punctuation">{</span>
                        stop_child<span class="token operator">=</span>true<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    stop_child<span class="token operator">=</span>true<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">else</span><span class="token punctuation">{</span>
                    <span class="token comment">/*成功读取客户数据后就通知主进程(通过管道)来处理*/</span>
                    <span class="token function">send</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>idx<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token comment">/*主进程通知本进程(通过管道)将第client个客户的数据发送到本进程负责的客户端*/</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>sockfd<span class="token operator">==</span>pipefd<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events<span class="token operator">&amp;</span>EPOLLIN<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">int</span> client<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
                <span class="token comment">/*接收主进程发送来的数据,即有客户数据到达的连接的编号*/</span>
                ret<span class="token operator">=</span><span class="token function">recv</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>client<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>client<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token keyword">if</span><span class="token punctuation">(</span>errno<span class="token operator">!=</span>EAGAIN<span class="token punctuation">)</span><span class="token punctuation">{</span>
                        stop_child<span class="token operator">=</span>true<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    stop_child<span class="token operator">=</span>true<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">else</span><span class="token punctuation">{</span>
                    <span class="token function">send</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span>share_mem<span class="token operator">+</span>client<span class="token operator">*</span>BUFFER_SIZE<span class="token punctuation">,</span>
BUFFER_SIZE<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span><span class="token punctuation">{</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">close</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>child_epollfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span><span class="token keyword">char</span><span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>argc<span class="token operator">&lt;=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"usage:%s ip_address port_number\n"</span><span class="token punctuation">,</span><span class="token function">basename</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> ip<span class="token operator">=</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> port<span class="token operator">=</span><span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> ret<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> address<span class="token punctuation">;</span>
	<span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	address<span class="token punctuation">.</span>sin_family<span class="token operator">=</span>AF_INET<span class="token punctuation">;</span>
	<span class="token function">inet_pton</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span>ip<span class="token punctuation">,</span><span class="token operator">&amp;</span>address<span class="token punctuation">.</span>sin_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	address<span class="token punctuation">.</span>sin_port<span class="token operator">=</span><span class="token function">htons</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>
	listenfd<span class="token operator">=</span><span class="token function">socket</span><span class="token punctuation">(</span>PF_INET<span class="token punctuation">,</span>SOCK_STREAM<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>listenfd<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	ret<span class="token operator">=</span><span class="token function">bind</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>ret<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	ret<span class="token operator">=</span><span class="token function">listen</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>ret<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//用户连接数量</span>
	user_count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">//用户数据</span>
	users<span class="token operator">=</span>new client_data<span class="token punctuation">[</span>USER_LIMIT<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	sub_process<span class="token operator">=</span>new <span class="token keyword">int</span><span class="token punctuation">[</span>PROCESS_LIMIT<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>PROCESS_LIMIT<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>
		sub_process<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
    <span class="token comment">//epoll事件表</span>
	epoll_event events<span class="token punctuation">[</span>MAX_EVENT_NUMBER<span class="token punctuation">]</span><span class="token punctuation">;</span>
	epollfd<span class="token operator">=</span><span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>epollfd<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">addfd</span><span class="token punctuation">(</span>epollfd<span class="token punctuation">,</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//创建双向管道</span>
    ret<span class="token operator">=</span><span class="token function">socketpair</span><span class="token punctuation">(</span>PF_UNIX<span class="token punctuation">,</span>SOCK_STREAM<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>sig_pipefd<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>ret<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//设置写端无阻塞</span>
	<span class="token function">setnonblocking</span><span class="token punctuation">(</span>sig_pipefd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//监听读端</span>
    <span class="token function">addfd</span><span class="token punctuation">(</span>epollfd<span class="token punctuation">,</span>sig_pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//SIGCHLD信号：子进程状态发生变化</span>
	<span class="token function">addsig</span><span class="token punctuation">(</span>SIGCHLD<span class="token punctuation">,</span>sig_handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//SIGTERM信号：终止进程</span>
	<span class="token function">addsig</span><span class="token punctuation">(</span>SIGTERM<span class="token punctuation">,</span>sig_handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//SIGINT信号：键盘输入以中断进程（Ctrl+C）</span>
	<span class="token function">addsig</span><span class="token punctuation">(</span>SIGINT<span class="token punctuation">,</span>sig_handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//SIGPIPE信号：往读端被关闭的管道或者socket连接中写数据</span>
	<span class="token function">addsig</span><span class="token punctuation">(</span>SIGPIPE<span class="token punctuation">,</span>SIG_IGN<span class="token punctuation">)</span><span class="token punctuation">;</span>
	bool stop_server<span class="token operator">=</span>false<span class="token punctuation">;</span>
	bool terminate<span class="token operator">=</span>false<span class="token punctuation">;</span>
	<span class="token comment">/*创建共享内存,作为所有客户socket连接的读缓存*/</span>
	shmfd<span class="token operator">=</span><span class="token function">shm_open</span><span class="token punctuation">(</span>shm_name<span class="token punctuation">,</span>O_CREAT<span class="token operator">|</span>O_RDWR<span class="token punctuation">,</span><span class="token number">0666</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>shmfd<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//ftruncate函数：改变文件大小</span>
	ret<span class="token operator">=</span><span class="token function">ftruncate</span><span class="token punctuation">(</span>shmfd<span class="token punctuation">,</span>USER_LIMIT<span class="token operator">*</span>BUFFER_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>ret<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//PORT_READ|PORT_WRITE：可读可写</span>
    <span class="token comment">//MAP_SHARED：进程间共享，POSIX</span>
	share_mem<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">mmap</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span>USER_LIMIT<span class="token operator">*</span>BUFFER_SIZE<span class="token punctuation">,</span>PROT_READ<span class="token operator">|</span>PROT_WRITE<span class="token punctuation">,</span>MAP_SHARED<span class="token punctuation">,</span>shmfd<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>share_mem<span class="token operator">!=</span>MAP_FAILED<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">close</span><span class="token punctuation">(</span>shmfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stop_server<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//阻塞等待某事件发生</span>
		<span class="token keyword">int</span> number<span class="token operator">=</span><span class="token function">epoll_wait</span><span class="token punctuation">(</span>epollfd<span class="token punctuation">,</span>events<span class="token punctuation">,</span>MAX_EVENT_NUMBER<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>number<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>errno<span class="token operator">!=</span>EINTR<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"epoll failure\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>number<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">int</span> sockfd<span class="token operator">=</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd<span class="token punctuation">;</span>
            <span class="token comment">/*新的客户连接到来*/</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>sockfd<span class="token operator">==</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> client_address<span class="token punctuation">;</span>
                <span class="token class-name">socklen_t</span> client_addrlength<span class="token operator">=</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>client_address<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">int</span> connfd<span class="token operator">=</span><span class="token function">accept</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>client_address<span class="token punctuation">,</span><span class="token operator">&amp;</span>client_addrlength<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span><span class="token punctuation">(</span>connfd<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"errno is:%d\n"</span><span class="token punctuation">,</span>errno<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">continue</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">if</span><span class="token punctuation">(</span>user_count<span class="token operator">&gt;=</span>USER_LIMIT<span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> info<span class="token operator">=</span><span class="token string">"too many users\n"</span><span class="token punctuation">;</span>
                    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token function">send</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span>info<span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token function">close</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token keyword">continue</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
                <span class="token comment">/*保存第user_count个客户连接的相关数据*/</span>
                users<span class="token punctuation">[</span>user_count<span class="token punctuation">]</span><span class="token punctuation">.</span>address<span class="token operator">=</span>client_address<span class="token punctuation">;</span>
                users<span class="token punctuation">[</span>user_count<span class="token punctuation">]</span><span class="token punctuation">.</span>connfd<span class="token operator">=</span>connfd<span class="token punctuation">;</span>
                <span class="token comment">/*在主进程和子进程间建立管道,以传递必要的数据*/</span>
                ret<span class="token operator">=</span><span class="token function">socketpair</span><span class="token punctuation">(</span>PF_UNIX<span class="token punctuation">,</span>SOCK_STREAM<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>users<span class="token punctuation">[</span>user_count<span class="token punctuation">]</span><span class="token punctuation">.</span>pipefd<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">assert</span><span class="token punctuation">(</span>ret<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">pid_t</span> pid<span class="token operator">=</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span><span class="token punctuation">(</span>pid<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token function">close</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">continue</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>pid<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token function">close</span><span class="token punctuation">(</span>epollfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token function">close</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token function">close</span><span class="token punctuation">(</span>users<span class="token punctuation">[</span>user_count<span class="token punctuation">]</span><span class="token punctuation">.</span>pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token function">close</span><span class="token punctuation">(</span>sig_pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token function">close</span><span class="token punctuation">(</span>sig_pipefd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token function">run_child</span><span class="token punctuation">(</span>user_count<span class="token punctuation">,</span>users<span class="token punctuation">,</span>share_mem<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token function">munmap</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>share_mem<span class="token punctuation">,</span>USER_LIMIT<span class="token operator">*</span>BUFFER_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
                	<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
				<span class="token keyword">else</span><span class="token punctuation">{</span>
                    <span class="token function">close</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token function">close</span><span class="token punctuation">(</span>users<span class="token punctuation">[</span>user_count<span class="token punctuation">]</span><span class="token punctuation">.</span>pipefd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token function">addfd</span><span class="token punctuation">(</span>epollfd<span class="token punctuation">,</span>users<span class="token punctuation">[</span>user_count<span class="token punctuation">]</span><span class="token punctuation">.</span>pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    users<span class="token punctuation">[</span>user_count<span class="token punctuation">]</span><span class="token punctuation">.</span>pid<span class="token operator">=</span>pid<span class="token punctuation">;</span>
					<span class="token comment">/*记录新的客户连接在数组users中的索引值,建立进程pid和该索引值之间的映射关系*/</span>
                    sub_process<span class="token punctuation">[</span>pid<span class="token punctuation">]</span><span class="token operator">=</span>user_count<span class="token punctuation">;</span>
                    user_count<span class="token operator">++</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			<span class="token comment">/*处理信号事件*/</span>
			<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>sockfd<span class="token operator">==</span>sig_pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events<span class="token operator">&amp;</span>EPOLLIN<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">int</span> sig<span class="token punctuation">;</span>
                <span class="token keyword">char</span> signals<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                ret<span class="token operator">=</span><span class="token function">recv</span><span class="token punctuation">(</span>sig_pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>signals<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>signals<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                	<span class="token keyword">continue</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
				<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
					<span class="token keyword">continue</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">else</span><span class="token punctuation">{</span>
					<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>ret<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>
						<span class="token keyword">switch</span><span class="token punctuation">(</span>signals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                            <span class="token comment">/*子进程退出,表示有某个客户端关闭了连接*/</span>
                            <span class="token keyword">case</span> SIGCHLD<span class="token operator">:</span><span class="token punctuation">{</span>
                                <span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>
                                <span class="token keyword">int</span> stat<span class="token punctuation">;</span>
                                <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pid<span class="token operator">=</span><span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>stat<span class="token punctuation">,</span>WNOHANG<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                                    <span class="token comment">/*用子进程的pid取得被关闭的客户连接的编号*/</span>
                                    <span class="token keyword">int</span> del_user<span class="token operator">=</span>sub_process<span class="token punctuation">[</span>pid<span class="token punctuation">]</span><span class="token punctuation">;</span>
                                    sub_process<span class="token punctuation">[</span>pid<span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
									<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>del_user<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">||</span><span class="token punctuation">(</span>del_user<span class="token operator">&gt;</span>USER_LIMIT<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                                    	<span class="token keyword">continue</span><span class="token punctuation">;</span>
                                    <span class="token punctuation">}</span>
									<span class="token comment">/*清除第del_user个客户连接使用的相关数据*/</span>
                                    <span class="token function">epoll_ctl</span><span class="token punctuation">(</span>epollfd<span class="token punctuation">,</span>EPOLL_CTL_DEL<span class="token punctuation">,</span>users<span class="token punctuation">[</span>del_user<span class="token punctuation">]</span><span class="token punctuation">.</span>pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                                    <span class="token function">close</span><span class="token punctuation">(</span>users<span class="token punctuation">[</span>del_user<span class="token punctuation">]</span><span class="token punctuation">.</span>pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                                    users<span class="token punctuation">[</span>del_user<span class="token punctuation">]</span><span class="token operator">=</span>users<span class="token punctuation">[</span><span class="token operator">--</span>user_count<span class="token punctuation">]</span><span class="token punctuation">;</span>
                                    sub_process<span class="token punctuation">[</span>users<span class="token punctuation">[</span>del_user<span class="token punctuation">]</span><span class="token punctuation">.</span>pid<span class="token punctuation">]</span><span class="token operator">=</span>del_user<span class="token punctuation">;</span>
								<span class="token punctuation">}</span>
								<span class="token keyword">if</span><span class="token punctuation">(</span>terminate<span class="token operator">&amp;&amp;</span>user_count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                                	stop_server<span class="token operator">=</span>true<span class="token punctuation">;</span>
                                <span class="token punctuation">}</span>
								<span class="token keyword">break</span><span class="token punctuation">;</span>
							<span class="token punctuation">}</span>
                            <span class="token keyword">case</span> SIGTERM<span class="token operator">:</span>
                            <span class="token keyword">case</span> SIGINT<span class="token operator">:</span><span class="token punctuation">{</span>
                                <span class="token comment">/*结束服务器程序*/</span>
                                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"kill all the clild now\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                                <span class="token keyword">if</span><span class="token punctuation">(</span>user_count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                                    stop_server<span class="token operator">=</span>true<span class="token punctuation">;</span>
                                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                                <span class="token punctuation">}</span>
                                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>user_count<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>
                                    <span class="token keyword">int</span> pid<span class="token operator">=</span>users<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>pid<span class="token punctuation">;</span>
                                    <span class="token function">kill</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span>SIGTERM<span class="token punctuation">)</span><span class="token punctuation">;</span>
                                <span class="token punctuation">}</span>
                                terminate<span class="token operator">=</span>true<span class="token punctuation">;</span>
                                <span class="token keyword">break</span><span class="token punctuation">;</span>
                            <span class="token punctuation">}</span>
							<span class="token keyword">default</span><span class="token operator">:</span><span class="token punctuation">{</span>
								<span class="token keyword">break</span><span class="token punctuation">;</span>
							<span class="token punctuation">}</span>
						<span class="token punctuation">}</span>
					<span class="token punctuation">}</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
            <span class="token comment">/*某个子进程向父进程写入了数据*/</span>
			<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events<span class="token operator">&amp;</span>EPOLLIN<span class="token punctuation">)</span><span class="token punctuation">{</span>
				<span class="token keyword">int</span> child<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
				<span class="token comment">/*读取管道数据,child变量记录了是哪个客户连接有数据到达*/</span>
				ret<span class="token operator">=</span><span class="token function">recv</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>child<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"read data from child accross pipe\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                	<span class="token keyword">continue</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
				<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
					<span class="token keyword">continue</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">else</span><span class="token punctuation">{</span>
					<span class="token comment">/*向除负责处理第child个客户连接的子进程之外的其他子进程发送消息,通知它们有客户数据要写*/</span>
					<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>user_count<span class="token punctuation">;</span><span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span>
						<span class="token keyword">if</span><span class="token punctuation">(</span>users<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">!=</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">{</span>
                            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"send data to child accross pipe\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token function">send</span><span class="token punctuation">(</span>users<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>child<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
						<span class="token punctuation">}</span>
					<span class="token punctuation">}</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token function">del_resource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列时两个进程之间传递二进制数据的一种简单有效的方式，每个数据块都有一个特定的类型，接收方可以根据类型来选择地接收数据</p>
<h3 id="msgget系统调用"><a href="#msgget系统调用" class="headerlink" title="msgget系统调用"></a>msgget系统调用</h3><p>msgget系统调用创建一个消息队列，或者获取一个已有的消息队列</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/msg.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">msgget</span><span class="token punctuation">(</span><span class="token class-name">key_t</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> msgflg<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>key参数是一个键值，用来标识一个全局唯一的消息队列</li>
<li>msgflg参数的使用和含义于semget系统调用的sem_flgs参数相同</li>
<li>成功时返回一个正整数值，是消息队列的标识符，失败时返回-1，并设置errno</li>
</ul>
<hr>
<p>如果msgget用于创建消息队列，则与之关联的内核数据结构msqid_ds将被创建并初始化</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">msqid_ds</span><span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">ipc_perm</span> msg_perm<span class="token punctuation">;</span><span class="token comment">/*消息队列的操作权限*/</span>
    <span class="token class-name">time_t</span> msg_stime<span class="token punctuation">;</span><span class="token comment">/*最后一次调用msgsnd的时间*/</span>
    <span class="token class-name">time_t</span> msg_rtime<span class="token punctuation">;</span><span class="token comment">/*最后一次调用msgrcv的时间*/</span>
    <span class="token class-name">time_t</span> msg_ctime<span class="token punctuation">;</span><span class="token comment">/*最后一次被修改的时间*/</span>
    <span class="token keyword">unsigned</span> long__msg_cbytes<span class="token punctuation">;</span><span class="token comment">/*消息队列中已有的字节数*/</span>
    <span class="token class-name">msgqnum_t</span> msg_qnum<span class="token punctuation">;</span><span class="token comment">/*消息队列中已有的消息数*/</span>
    <span class="token class-name">msglen_t</span> msg_qbytes<span class="token punctuation">;</span><span class="token comment">/*消息队列允许的最大字节数*/</span>
    <span class="token class-name">pid_t</span> msg_lspid<span class="token punctuation">;</span><span class="token comment">/*最后执行msgsnd的进程的PID*/</span>
    <span class="token class-name">pid_t</span> msg_lrpid<span class="token punctuation">;</span><span class="token comment">/*最后执行msgrcv的进程的PID*/</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="msgsnd系统调用"><a href="#msgsnd系统调用" class="headerlink" title="msgsnd系统调用"></a>msgsnd系统调用</h3><p>msgsnd系统调用把一条信息添加到消息队列中</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/msg.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">msgsnd</span><span class="token punctuation">(</span><span class="token keyword">int</span> msqid<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> msg_ptr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> msg_sz<span class="token punctuation">,</span> <span class="token keyword">int</span> msgflg<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li><p>msqid参数是msgget调用返回的消息队列标识符</p>
</li>
<li><p>msg_ptr参数指向一个准备发送的消息，消息必须被定义为如下类型</p>
<ul>
<li>```c<br>struct msgbuf{<pre><code>long mtype;/*消息类型*/
char mtext[512];/*消息数据*/
</code></pre>};<pre class="line-numbers language-none"><code class="language-none">
  - mtype必须是一个正整数

- msg_sz是mtext的长度

- msgflg参数控制msgsnd的行为，通常仅支持IPC_NOWAIT标志，即以非阻塞的方式发送数据

  - 默认情况下，发送消息时如果消息队列满了，则msgsnd将阻塞，若IPC_NOWAIT标志被指定，则msgsnd将立即返回并设置errno为EAGAIN

- 处于阻塞状态的msgsnd调用可能被如下两种异常情况所中断

  - 消息队列被移除，此时msgsnd调用将立即返回并设置errno为EIDRM
  - 程序接收到信号，此时msgsnd调用将立即返回并设置errno为EINTR

- msgsnd成功时返回0，失败则返回-1并设置errno，成功时将修改内核数据结构msqid_ds的部分字段

  - 将msg_qnum加一
  - 将msg_lspid设置为调用进程的PID
  - 将msg_stime设置为当前的时间

###  msgrcv系统调用

msgrcv系统调用从消息队列中获取消息

```c
#include &lt;sys/msg.h&gt;
int msgrcv(int msqid, void* msg_ptr, size_t msg_sz, long int msgtype, int msgflg);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p>msqid参数是由msgget调用返回的消息队列标识符</p>
</li>
<li>msg_ptr参数用于存储接收的消息</li>
<li>msg_sz参数指的是消息数据部分的长度</li>
<li>msgtype参数指定接收何种类型的消息<ul>
<li>等于0，读取消息队列中的第一个消息</li>
<li>大于0，读取消息队列中第一个类型为msgtype的消息，除非指定了标志MSG_EXCEPT</li>
<li>小于0，读取消息队列中第一个类型值比msgtype的绝对值小的消息</li>
</ul>
</li>
<li>msgflg参数控制msgrcv的行为，可以是一下标志的按位或<ul>
<li>IPC_NOWAIT，如果消息队列中没有消息，则msgrcv调用立即返回并设置errno为ENOMSG</li>
<li>MSG_EXCEPT，如果msgtype大于0，则接收消息队列中第一个非msgtype类型的消息</li>
<li>MSG_NOERROR，如果消息数据部分的长度超过了msg_sz，就将他截断</li>
</ul>
</li>
<li>处于阻塞状态的msgrcv调用还可能被如下两种异常情况所中断<ul>
<li>消息队列被移除，此时msgsnd调用将立即返回并设置errno为EIDRM</li>
<li>程序接收到信号，此时msgsnd调用将立即返回并设置errno为EINTR</li>
</ul>
</li>
<li>成功时返回0，失败则返回-1并设置errno，msgrcv成功时将修改内核数据结构msqid_ds的部分字段<ul>
<li>将msg_qnum减一</li>
<li>将msg_lspid设置为调用进程的PID</li>
<li>将msg_stime设置为当前的时间</li>
</ul>
</li>
</ul>
<h3 id="msgctl系统调用"><a href="#msgctl系统调用" class="headerlink" title="msgctl系统调用"></a>msgctl系统调用</h3><p>msgctl系统调用烤制消息队列的某些属性</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/msg.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">msgctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> msqid<span class="token punctuation">,</span> <span class="token keyword">int</span> command<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">msqid_ds</span><span class="token operator">*</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>msqid参数时由msgget调用返回的共享内存标识符</li>
<li>command参数指定要执行的命令<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202401141646446.png" alt="image-20240114164652483"></li>
</ul>
</li>
<li>成功时返回值取决于command参数，失败时返回-1并设置errno</li>
</ul>
<h2 id="IPC命令"><a href="#IPC命令" class="headerlink" title="IPC命令"></a>IPC命令</h2><p>上述三种System V IPC进程间通信方式都使用一个全局唯一的键值对来描述一个共享资源，Linux提供了ipcs命令，以观察当前系统上拥有那些共享资源实例</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> ipcs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="在进程间传递文件描述符"><a href="#在进程间传递文件描述符" class="headerlink" title="在进程间传递文件描述符"></a>在进程间传递文件描述符</h2><p>传递一个文件描述符并不是传递一个文件描述符的值，而是要在接收进程中创建一个新的文件描述符，并且该文件描述符和发送进程中被传递的文件描述符指向内核中相同的文件表项</p>
<p>我们可以利用UNIX域socket在进程间传递特殊的辅助数据，实现在两个不相干的进程之间传递文件描述符</p>
<hr>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> CONTROL_LEN<span class="token operator">=</span><span class="token function">CMSG_LEN</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*发送文件描述符,fd参数是用来传递信息的UNIX域socket,fd_to_send参数是待发送的文件描述符*/</span>
<span class="token keyword">void</span> <span class="token function">send_fd</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span><span class="token keyword">int</span> fd_to_send<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">iovec</span> iov<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">msghdr</span> msg<span class="token punctuation">;</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    iov<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>iov_base<span class="token operator">=</span>buf<span class="token punctuation">;</span>
    iov<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>iov_len<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
    msg<span class="token punctuation">.</span>msg_name<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
    msg<span class="token punctuation">.</span>msg_namelen<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    msg<span class="token punctuation">.</span>msg_iov<span class="token operator">=</span>iov<span class="token punctuation">;</span>
    msg<span class="token punctuation">.</span>msg_iovlen<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
    cmsghdr cm<span class="token punctuation">;</span>
    cm<span class="token punctuation">.</span>cmsg_len<span class="token operator">=</span>CONTROL_LEN<span class="token punctuation">;</span>
    cm<span class="token punctuation">.</span>cmsg_level<span class="token operator">=</span>SOL_SOCKET<span class="token punctuation">;</span>
    cm<span class="token punctuation">.</span>cmsg_type<span class="token operator">=</span>SCM_RIGHTS<span class="token punctuation">;</span>
	<span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">CMSG_DATA</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cm<span class="token punctuation">)</span><span class="token operator">=</span>fd_to_send<span class="token punctuation">;</span>
    msg<span class="token punctuation">.</span>msg_control<span class="token operator">=</span><span class="token operator">&amp;</span>cm<span class="token punctuation">;</span><span class="token comment">/*设置辅助数据*/</span>
    msg<span class="token punctuation">.</span>msg_controllen<span class="token operator">=</span>CONTROL_LEN<span class="token punctuation">;</span>
    <span class="token function">sendmsg</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span><span class="token operator">&amp;</span>msg<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*接收目标文件描述符*/</span>
<span class="token keyword">int</span> <span class="token function">recv_fd</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">iovec</span> iov<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">msghdr</span> msg<span class="token punctuation">;</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    iov<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>iov_base<span class="token operator">=</span>buf<span class="token punctuation">;</span>
    iov<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>iov_len<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
    msg<span class="token punctuation">.</span>msg_name<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
    msg<span class="token punctuation">.</span>msg_namelen<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    msg<span class="token punctuation">.</span>msg_iov<span class="token operator">=</span>iov<span class="token punctuation">;</span>
    msg<span class="token punctuation">.</span>msg_iovlen<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
    cmsghdr cm<span class="token punctuation">;</span>
    msg<span class="token punctuation">.</span>msg_control<span class="token operator">=</span><span class="token operator">&amp;</span>cm<span class="token punctuation">;</span>
    msg<span class="token punctuation">.</span>msg_controllen<span class="token operator">=</span>CONTROL_LEN<span class="token punctuation">;</span>
    <span class="token function">recvmsg</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span><span class="token operator">&amp;</span>msg<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> fd_to_read<span class="token operator">=</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">CMSG_DATA</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cm<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> fd_to_read<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> pipefd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> fd_to_pass<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">/*创建父、子进程间的管道,文件描述符pipefd[0]和pipefd[1]都是UNIX域socket*/</span>
    <span class="token keyword">int</span> ret<span class="token operator">=</span><span class="token function">socketpair</span><span class="token punctuation">(</span>PF_UNIX<span class="token punctuation">,</span>SOCK_DGRAM<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>pipefd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>ret<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">pid_t</span> pid<span class="token operator">=</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>pid<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>pid<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">close</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        fd_to_pass<span class="token operator">=</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">,</span>O_RDWR<span class="token punctuation">,</span><span class="token number">0666</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">/*子进程通过管道将文件描述符发送到父进程。如果文件test.txt打开失败,则子进程将标准输入文件描述符发送到父进程*/</span>
        <span class="token function">send_fd</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">(</span>fd_to_pass<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">?</span>fd_to_pass<span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">close</span><span class="token punctuation">(</span>fd_to_pass<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
    <span class="token function">close</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    fd_to_pass<span class="token operator">=</span><span class="token function">recv_fd</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*父进程从管道接收目标文件描述符*/</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">memset</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span><span class="token char">'\0'</span><span class="token punctuation">,</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">read</span><span class="token punctuation">(</span>fd_to_pass<span class="token punctuation">,</span>buf<span class="token punctuation">,</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*读目标文件描述符,以验证其有效性*/</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I got fd%d and data%s\n"</span><span class="token punctuation">,</span>fd_to_pass<span class="token punctuation">,</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>fd_to_pass<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <tags>
        <tag>C++ socket</tag>
      </tags>
  </entry>
  <entry>
    <title>进程池和线程池</title>
    <url>/2023/11/29/12-%E8%BF%9B%E7%A8%8B%E6%B1%A0%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">    

<h2 id="进程池和线程池概述"><a href="#进程池和线程池概述" class="headerlink" title="进程池和线程池概述"></a>进程池和线程池概述</h2><p>进程池和线程池类似，下面以进程池为例进行介绍</p>
<span id="more"></span>
<hr>
<p>进程池是由服务器预先创建的一组子进程，这些子进程的数目在3~10个之间（典型情况），httpd守护进程就是使用包含7个子进程的进程池来实现并发的，线程池中的线程数量应该和CPU数量差不多。</p>
<p>进程池中的所有子进程都运行着相同的代码，并具有相同的属性，比如优先级、PGID等。因为进程池在服务器启动之初就创建好了，所以每个子进程都相对“干净”，即它们没有打开不必要的文件描述符（从父进程继承而来），也不会错误地使用大块的堆内存（从父进程复制得到）。</p>
<p>当有新的任务到来时，主进程将通过某种方式选择进程池中的某一个子进程来为之服务。相比于动态创建子进程，选择一个已经存在的子进程的代价显然要小得多。至于主进程选择哪个子进程来为新任务服务，则有两种方式：</p>
<ul>
<li>主进程使用某种算法来主动选择子进程，最简单、最常用得算法时随机算法和Round Robin（轮流选取）算法，但更优秀、更智能的算法将使任务在各个工作进程中更均匀地分配，从而减轻服务器地整体压力。</li>
<li>主进程和所有子进程通过一个共享的工作队列来同步，子进程都睡眠在该工作队列上。当有新的任务到来时，主进程将任务添加到工作队列中。这将唤醒正在等待任务的子进程，不过只有一个子进程将获得新任务的“接管权”，它可以从工作队列中取出任务并执行之，而其他子进程将继续睡眠在工作队列上。</li>
</ul>
<p>当选择好子进程后，主进程还需要使用某种通知机制来告诉目标子进程有新任务需要处理，并传递必要的数据。最简单的方法是，在父进程和子进程之间预先建立好一条管道，然后通过该管道来实现所有的进程间通信（当然，要预先定义好一套协议来规范管道的使用）。在父线程和子线程之间传递数据就要简单得多，因为我们可以把这些数据定义为全局的，那么它们本身就是被所有线程共享的。</p>
<hr>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/202401212210450.png" alt="image-20240121221048372"></p>
<h2 id="处理多客户"><a href="#处理多客户" class="headerlink" title="处理多客户"></a>处理多客户</h2><p>在使用进程池处理多客户任务时,首先要考虑的一个问题是：监听socket和连接socket是否都由主进程来统一管理</p>
<p><strong>半同步/半反应堆模式</strong></p>
<ul>
<li>由主进程统一管理这两种socket</li>
<li>主进程接受新的连接以得到连接socket，然后它需要将该socket传递给子进程（对于线程池而言，父线程将socket传递给子线程是很简单的，因为它们可以很容易地共享该socket。但对于进程池而言，必须使用在多进程编程中提到的UNIX域来传递该socket）</li>
</ul>
<p><strong>高效的半同步/半异步模式或领导者/追随者模式</strong></p>
<ul>
<li>是由主进程管理所有监听socket，而各个子进程分别管理属于自己的连接socket的</li>
<li>子进程可以自己调用accept来接受新的连接，这样父进程就无须向子进程传递socket</li>
</ul>
<hr>
<p>在设计进程池时还需要考虑：一个客户连接上的所有任务是否始终由一个子进程来处理。如果说客户任务是无状态的，那么我们可以考虑使用不同的子进程来为该客户的不同请求服务</p>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/202401212234619.png" alt="image-20240121223422684"></p>
<p>如果客户任务是存在上下文关系的，则最好一直用同一个子进程来为之服务，否则实现起来将比较麻烦，因为我们不得不在各子进程之间传递上下文数据</p>
<p>epoll的EPOLLONESHOT事件能够确保一个客户连接在整个生命周期中仅被一个线程处理</p>
]]></content>
      <tags>
        <tag>C++ socket</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程编程</title>
    <url>/2023/11/29/11-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">    

<h2 id="Linux线程概述"><a href="#Linux线程概述" class="headerlink" title="Linux线程概述"></a>Linux线程概述</h2><h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><p><strong>线程</strong></p>
<ul>
<li>程序中完成一个独立任务的完整执行序列，即一个可调度的实体</li>
</ul>
<p><strong>用户线程</strong></p>
<ul>
<li>运行在用户空间，由线程库来调度</li>
</ul>
<p><strong>内核线程</strong></p>
<ul>
<li>有的系统也称为LWP（Light Weight Process，轻量级进程），运行在内核空间，由内核来调度</li>
<li>当进程的一个内核线程获得CPU的使用权时，它就加载并允许一个用户线程，内核线程相当于用户线程运行的“容器”</li>
</ul>
<span id="more"></span>
<hr>
<ul>
<li><p>一个进程可以拥有M个内核线程和N个用户线程，其中<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.312ex;" xmlns="http://www.w3.org/2000/svg" width="7.404ex" height="1.857ex" role="img" focusable="false" viewBox="0 -683 3272.6 821"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"></path></g><g data-mml-node="mo" transform="translate(1328.8,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(2384.6,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g></g></g></svg></mjx-container></p>
</li>
<li><p>在一个系统的所有进程中，M和N的比值都是固定的</p>
</li>
<li>按照M:N的取值，线程的实现方式可以分为三种模式<ul>
<li>完全在用户空间实现<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202401162120134.jpeg" alt="img" style="zoom:25%;"></li>
</ul>
</li>
<li>完全由内核调度<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202401162119949.jpeg" alt="img" style="zoom:25%;"></li>
</ul>
</li>
<li>双层调度<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202401162113033.jpeg" alt="img" style="zoom: 25%;"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Linux线程库"><a href="#Linux线程库" class="headerlink" title="Linux线程库"></a>Linux线程库</h3><ul>
<li><p>Linux上最有名的两个线程库是LinuxThreads和NPTL，它们都是采用1:1的方式实现的</p>
</li>
<li><p>线代Linux默认使用的线程库时NPTL</p>
</li>
<li><p>查看当前系统使用的线程库</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">getconf GNU_LIBPTHREAD_VERSION<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ul>
<h3 id="创建线程和结束线程"><a href="#创建线程和结束线程" class="headerlink" title="创建线程和结束线程"></a>创建线程和结束线程</h3><h4 id="pthread-create创建线程"><a href="#pthread-create创建线程" class="headerlink" title="pthread_create创建线程"></a>pthread_create创建线程</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token class-name">pthread_t</span><span class="token operator">*</span> thread<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token class-name">pthread_attr_t</span><span class="token operator">*</span> attr<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span>start_routine<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li><p>thread参数是新线程的标识符，后续pthread_*函数通过它来引用新线程</p>
<ul>
<li>```c<h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <bits></bits></h1>typedef unsigned long int pthread_t;<pre class="line-numbers language-none"><code class="language-none">
- attr参数用于设置新线程的属性，给它传递NULL表示使用默认线程属性

- start_routine参数指定新线程运行的函数

- arg参数指定函数运行的参数

- 成功时返回0，失败时返回错误码

#### pthread_exit结束进程

```c
#include &lt;pthread.h&gt;
void pthread_exit(void* retval);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p>线程函数在结束时最好调用该函数，以确保安全、干净地退出</p>
</li>
<li>该函数通过retval参数项线程地回收者传递其退出信息</li>
<li>执行完之后不会返回到调用者，永远不会失败</li>
</ul>
<h4 id="pthread-join回收线程"><a href="#pthread-join回收线程" class="headerlink" title="pthread_join回收线程"></a>pthread_join回收线程</h4><p>等待其他线程结束，类似回收进程的wait和waitpid系统调用</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">pthread_join</span><span class="token punctuation">(</span><span class="token class-name">pthread_t</span> thread<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span> retval<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>thread参数事目标线程的标识符</li>
<li>retval参数事目标线程返回的退出信息</li>
<li>该函数会一直阻塞直到被回收的线程结束为止</li>
<li>成功时返回0，失败则返回错误码<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202401192326337.png" alt="image-20240119232636350"></li>
</ul>
</li>
</ul>
<h4 id="pthread-cancel"><a href="#pthread-cancel" class="headerlink" title="pthread_cancel"></a>pthread_cancel</h4><p>异常终止一个线程</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">pthread_cancel</span><span class="token punctuation">(</span><span class="token class-name">pthread_t</span> thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>thread参数时目标线程的标识符</li>
<li>成功时返回0，失败则返回错误码</li>
</ul>
<hr>
<p>接受到取消请求的目标线程可以决定是否允许被取消以及如何取消</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">pthread_setcancelstate</span><span class="token punctuation">(</span><span class="token keyword">int</span> state<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> oldstate<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pthread_setcanceltype</span><span class="token punctuation">(</span><span class="token keyword">int</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> oldtype<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li>第一个参数分别用于设置线程的取消状态（是否允许取消）和取消类型（如何取消）<ul>
<li>state<ul>
<li>PTHREAD_CANCEL_ENABLE，允许线程被取消，线程创建时的默认取消状态</li>
<li>PTHREAD_CANCEL_DISABLE，禁止线程被取消，如果一个线程收到取消请求，则它会将请求挂起，直到该线程允许被取消</li>
</ul>
</li>
<li>type<ul>
<li>PTHREAD_CANCEL_ASYNCHRONOUS，线程随时都可以被取消，使得接收到取消请求的目标线程立即采取行动</li>
<li>PTHREAD_CANCEL_DEFERRED，允许目标线程推迟行动，直到它调用下面几个所谓的取消点函数中的一个<ul>
<li>pthread_join</li>
<li>pthread_testcancel</li>
<li>pthread_cond_wait</li>
<li>pthread_cond_timewait</li>
<li>sem_wait</li>
<li>sigwait</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>第二个线程分别记录线程原来的取消状态和取消类型</li>
<li>成功时返回0，失败则返回错误码</li>
</ul>
<h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><p>pthread_attr_t结构体定义了一套完整的线程属性</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/pthreadtypes.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span><span class="token expression">__SIZEOF_PTHREAD_ATTR_T <span class="token number">36</span></span></span>
<span class="token keyword">typedef</span> <span class="token keyword">union</span><span class="token punctuation">{</span>
    char__size<span class="token punctuation">[</span>__SIZEOF_PTHREAD_ATTR_T<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">long</span> int__align<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token class-name">pthread_attr_t</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>各种线程属性都包含在一个字符数组中</li>
</ul>
<hr>
<p>线程库定义了一系列函数来操作pthread_attr_t类型的变量，以方便我们获取和设置线程属性</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token comment">/*初始化线程属性对象*/</span>
<span class="token keyword">int</span> <span class="token function">pthread_attr_init</span><span class="token punctuation">(</span><span class="token class-name">pthread_attr_t</span><span class="token operator">*</span>attr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/*销毁线程属性对象。被销毁的线程属性对象只有再次初始化之后才能继续使用*/</span>
<span class="token keyword">int</span> <span class="token function">pthread_attr_destroy</span><span class="token punctuation">(</span><span class="token class-name">pthread_attr_t</span><span class="token operator">*</span>attr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/*下面这些函数用于获取和设置线程属性对象的某个属性*/</span>
<span class="token keyword">int</span> <span class="token function">pthread_attr_getdetachstate</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">pthread_attr_t</span><span class="token operator">*</span> attr<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">*</span> detachstate<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pthread_attr_setdetachstate</span><span class="token punctuation">(</span><span class="token class-name">pthread_attr_t</span><span class="token operator">*</span> attr<span class="token punctuation">,</span><span class="token keyword">int</span> detachstate<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pthread_attr_getstackaddr</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">pthread_attr_t</span><span class="token operator">*</span> attr<span class="token punctuation">,</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span> stackaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pthread_attr_setstackaddr</span><span class="token punctuation">(</span><span class="token class-name">pthread_attr_t</span><span class="token operator">*</span> attr<span class="token punctuation">,</span><span class="token keyword">void</span><span class="token operator">*</span> stackaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pthread_attr_getstacksize</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">pthread_attr_t</span><span class="token operator">*</span>attr<span class="token punctuation">,</span><span class="token class-name">size_t</span><span class="token operator">*</span> stacksize<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pthread_attr_setstacksize</span><span class="token punctuation">(</span><span class="token class-name">pthread_attr_t</span><span class="token operator">*</span> attr<span class="token punctuation">,</span><span class="token class-name">size_t</span> stacksize<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pthread_attr_getstack</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">pthread_attr_t</span><span class="token operator">*</span> attr<span class="token punctuation">,</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span> stackaddr<span class="token punctuation">,</span><span class="token class-name">size_t</span><span class="token operator">*</span> stacksize<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pthread_attr_setstack</span><span class="token punctuation">(</span><span class="token class-name">pthread_attr_t</span><span class="token operator">*</span> attr<span class="token punctuation">,</span><span class="token keyword">void</span><span class="token operator">*</span> stackaddr<span class="token punctuation">,</span><span class="token class-name">size_t</span> stacksize<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pthread_attr_getguardsize</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">pthread_attr_t</span><span class="token operator">*</span> __attr<span class="token punctuation">,</span><span class="token class-name">size_t</span><span class="token operator">*</span> guardsize<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pthread_attr_setguardsize</span><span class="token punctuation">(</span><span class="token class-name">pthread_attr_t</span><span class="token operator">*</span> attr<span class="token punctuation">,</span><span class="token class-name">size_t</span> guardsize<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pthread_attr_getschedparam</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">pthread_attr_t</span><span class="token operator">*</span> attr<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">sched_param</span><span class="token operator">*</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pthread_attr_setschedparam</span><span class="token punctuation">(</span><span class="token class-name">pthread_attr_t</span><span class="token operator">*</span> attr<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_param</span><span class="token operator">*</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pthread_attr_getschedpolicy</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">pthread_attr_t</span><span class="token operator">*</span> attr<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">*</span> policy<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pthread_attr_setschedpolicy</span><span class="token punctuation">(</span><span class="token class-name">pthread_attr_t</span><span class="token operator">*</span> attr<span class="token punctuation">,</span><span class="token keyword">int</span> policy<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pthread_attr_getinheritsched</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">pthread_attr_t</span><span class="token operator">*</span> attr<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">*</span> inherit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pthread_attr_setinheritsched</span><span class="token punctuation">(</span><span class="token class-name">pthread_attr_t</span><span class="token operator">*</span> attr<span class="token punctuation">,</span><span class="token keyword">int</span> inherit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pthread_attr_getscope</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">pthread_attr_t</span><span class="token operator">*</span> attr<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">*</span> scope<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pthread_attr_setscope</span><span class="token punctuation">(</span><span class="token class-name">pthread_attr_t</span><span class="token operator">*</span> attr<span class="token punctuation">,</span><span class="token keyword">int</span> scope<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<p><strong>各个线程属性的含义</strong></p>
<ol>
<li>detachstate，线程的脱离状态<ul>
<li>PTHREAD_CREATE_JOINABLE，指定线程是可以回收的，默认值</li>
<li>PTHREAD_CREATE_DETACH，使调用线程脱离于进程中其他线程的同步<ul>
<li>脱离了与其他线程同步的线程称为“脱离线程”，脱离线程在退出时将自行释放其占用的系统资源</li>
<li>可以使用pthread_detach函数将线程设置为脱离线程</li>
</ul>
</li>
</ul>
</li>
<li>stackaddr和stacksize，线程堆栈的起始地址和大小</li>
<li>guardsize，保护区域大小<ul>
<li>大于0，则系统创建线程的时候会在其堆栈的尾部额外分配guardsize字节的空间，作为保护堆栈不被错误地覆盖的区域</li>
<li>等于0，则系统不为新创建的线程设置堆栈保护区</li>
<li>如果使用者通过pthread_attr_setstackaddr或pthread_attr_setstack函数手动设置线程的堆栈，则该属性将被忽略</li>
</ul>
</li>
<li>schedparam，线程调度参数<ul>
<li>其类型是sched_param结构体，该结构体只有一个整形类型的成员——sched_priority，表示线程运行优先级</li>
</ul>
</li>
<li>schedpolicy，线程调度策略<ul>
<li>SCHED_FIFO，先进先出</li>
<li>SCHED_RR，时间片轮转</li>
<li>SCHED_OTHER，默认</li>
</ul>
</li>
<li>inheritsched，是否继承调用线程的调度属性<ul>
<li>PTHREAD_INHERIT_SCHED，新线程沿用其创建者的线程调度参数，这种情况下设置新线程的调度参数属性没有任何效果</li>
<li>PTHREAD_EXPLICIT_SCHED，表示调用者要明确地指定新线程地调度参数</li>
</ul>
</li>
<li>scope，线程间竞争CPU的范围，即线程优先级的有效范围<ul>
<li>PTHREAD_SCOPE_SYSTEM，目标线程与系统中所有线程一起竞争CPU的使用</li>
<li>PTHREAD_SCOPE_PROCESS，目标线程仅与其他隶属于同一进程的线程竞争CPU的使用</li>
<li>LINUX只支持第一种</li>
</ul>
</li>
</ol>
<h2 id="POSIX信号量"><a href="#POSIX信号量" class="headerlink" title="POSIX信号量"></a>POSIX信号量</h2><p>常用的POSIX信号量函数</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;semaphore.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">sem_init</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span><span class="token operator">*</span> sem<span class="token punctuation">,</span> <span class="token keyword">int</span> pshared<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">sem_destory</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span><span class="token operator">*</span> sem<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">sem_wait</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span><span class="token operator">*</span> sem<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">sem_trywait</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span><span class="token operator">*</span> sem<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">sem_post</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span><span class="token operator">*</span> sem<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>sem参数指向被操作的信号量</li>
<li>sem_init函数<ul>
<li>用于初始化一个未命名的信号量（POSIX信号量API支持命名信号量）</li>
<li>pshared参数指定信号量的类型，为0表示该信号量是当前进程的局部信号量，否则该信号量可以在多个进程之间共享</li>
<li>value参数指定信号量的初始值</li>
</ul>
</li>
<li><p>sem_destory函数</p>
<ul>
<li>用于销毁信号量</li>
</ul>
</li>
<li><p>sem_wait函数</p>
<ul>
<li>以原子操作的方式将信号量的值减一</li>
<li>如果信号量的值为0，则将被阻塞</li>
</ul>
</li>
<li>sem_trywait函数<ul>
<li>sem_wait函数的非阻塞版</li>
<li>信号量为0时返回-1并设置errno为EAGAIN</li>
</ul>
</li>
<li>sem_post函数<ul>
<li>以原子操作的方式将信号量的值加一</li>
<li>当信号量的值大于0时，其他正在调用sem_wait等待信号量的线程将被唤醒</li>
</ul>
</li>
<li>成功时返回0，失败时返回-1并设置errno</li>
</ul>
<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><h3 id="互斥锁基础API"><a href="#互斥锁基础API" class="headerlink" title="互斥锁基础API"></a>互斥锁基础API</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span><span class="token class-name">pthread_mutex_t</span><span class="token operator">*</span> mutex<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token class-name">pthread_mutexattr_t</span><span class="token operator">*</span> mutexattr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pthread_mutex_destroy</span><span class="token punctuation">(</span><span class="token class-name">pthread_mutex_t</span><span class="token operator">*</span> mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token class-name">pthread_mutex_t</span><span class="token operator">*</span> mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pthread_mutex_trylock</span><span class="token punctuation">(</span><span class="token class-name">pthread_mutex_t</span><span class="token operator">*</span> mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token class-name">pthread_mutex_t</span><span class="token operator">*</span> mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>mutex参数指向要操作的目标互斥锁，互斥锁的类型是pthread_mutex_t结构体</p>
</li>
<li><p>pthread_mutex_init函数</p>
<ul>
<li><p>用于初始化互斥锁</p>
</li>
<li><p>mutexattr参数指定互斥锁的属性，为NULL时表示使用默认属性</p>
</li>
<li><p>初始化互斥锁的另一种方式</p>
<ul>
<li>```c<br>pthread_mutex_t mutex=PTHREAD_MUTEX_INITIALIZER;<pre class="line-numbers language-none"><code class="language-none">
    - 宏PTHREAD_MUTEX_INITIALIZER实际上只是把互斥锁的各个字段都初始化为0

- pthread_mutex_destory函数

  - 用于销毁互斥锁

- pthread_mutex_lock函数

  - 以原子操作的方式给一个互斥锁加锁
  - 如果已被锁上，则阻塞

- pthread_mutex_trylock函数

  - pthread_mutex_lock函数的非阻塞版
  - 如果已经被锁上返回错误码EBUSY
  - 以上针对普通锁

- pthread_mutex_unlock函数

  - 以原子操作的方式给一个互斥锁解锁

- 成功时返回0，失败时返回错误码

### 互斥锁属性

**主要函数**

```c
#include &lt;pthread.h&gt;
/*初始化互斥锁属性对象*/
int pthread_mutexattr_init(pthread_mutexattr_t*attr);
/*销毁互斥锁属性对象*/
int pthread_mutexattr_destroy(pthread_mutexattr_t*attr);
/*获取和设置互斥锁的pshared属性*/
int pthread_mutexattr_getpshared(const pthread_mutexattr_t* attr,int* pshared);
int pthread_mutexattr_setpshared(pthread_mutexattr_t* attr,int pshared);
/*获取和设置互斥锁的type属性*/
int pthread_mutexattr_gettype(const pthread_mutexattr_t* attr,int* type);
int pthread_mutexattr_settype(pthread_mutexattr_t* attr,int ype);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>pshared属性，指定是否允许跨进程共享互斥锁</p>
<ul>
<li>PTHREAD_PROCESS_SHARED，互斥锁可以被跨进程共享</li>
<li>PTHREAD_PROCESS_PRIVATE，互斥锁只能被和锁的初始化线程隶属于同一个进程的线程共享</li>
</ul>
</li>
<li>type属性<ul>
<li>PTHREAD_MUTEX_NORMAL，普通锁，互斥锁默认的类型<ul>
<li>当一个线程对一个普通锁加锁以后,其余请求该锁的线程将形成一个等待队列，并在该锁解锁后按优先级获得它</li>
<li>一个线程如果对一个已经加锁的普通锁再次加锁，将引发死锁;对一个已经被其他线程加锁的普通锁解锁，或者对一个已经解锁的普通锁再次解锁,将导致不可预期的后果</li>
</ul>
</li>
<li>PTHREAD_MUTEX_ERRORCHECK，检错锁<ul>
<li>一个线程如果对一个已经加锁的检错锁再次加锁，则加锁操作返回EDEADLK</li>
<li>对一个已经解锁的检错锁再次解锁,则解锁操作返回EPERM</li>
</ul>
</li>
<li>PTHREAD_MUTEX_RECURSIVE，嵌套锁<ul>
<li>允许一个线程在释放锁之前多次对它加锁而不发生死锁。不过其他线程如果要获得这个锁,则当前锁的拥有者必须执行相应次数的解锁操作</li>
<li>对一个已经被其他线程加锁的嵌套锁解锁，或者对一个已经解锁的嵌套锁再次解锁,则解锁操作返回EPERM</li>
</ul>
</li>
<li>PTHREAD_MUTEX_DEFAULT，默认锁<ul>
<li>一个线程如果对一个已经加锁的默认锁再次加锁，或者对一个已经被其他线程加锁的默认锁解锁，或者对一个已经解锁的默认锁再次解锁,将导致不可预期的后果</li>
<li>这种锁在实现的时候可能被映射为上面三种锁之一</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>如果说互斥锁是用于同步线程对共享数据的访问的话，那么条件变量则是用于在线程之间同步共享数据的值</p>
<p>条件变量提供了一种线程间的通知机制：当某个共享数据达到某个值的时候，唤醒等待这个共享数据的线程</p>
<hr>
<p><strong>主要函数</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">pthread_cond_init</span><span class="token punctuation">(</span><span class="token class-name">pthread_cond_t</span><span class="token operator">*</span> cond<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token class-name">pthread_condattr_t</span><span class="token operator">*</span> cond_attr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pthread_cond_destroy</span><span class="token punctuation">(</span><span class="token class-name">pthread_cond_t</span><span class="token operator">*</span> cond<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pthread_cond_broadcast</span><span class="token punctuation">(</span><span class="token class-name">pthread_cond_t</span><span class="token operator">*</span> cond<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pthread_cond_signal</span><span class="token punctuation">(</span><span class="token class-name">pthread_cond_t</span><span class="token operator">*</span> cond<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pthread_cond_wait</span><span class="token punctuation">(</span><span class="token class-name">pthread_cond_t</span><span class="token operator">*</span> cond<span class="token punctuation">,</span><span class="token class-name">pthread_mutex_t</span><span class="token operator">*</span> mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>cond参数指向要操作的目标条件变量，条件变量的类型时pthread_cond结构体</p>
</li>
<li><p>pthread_cond_init函数用于初始化条件变量</p>
<ul>
<li><p>cond_attr参数指定条件变量的属性，若为NULL，则表示使用默认属性</p>
</li>
<li><p>另一种初始化方式</p>
<ul>
<li>```c<br>pthread_cond_t cond=PTHREAD_COND_INITIALIZER;<pre class="line-numbers language-none"><code class="language-none">
    - 宏PTHREAD_COND_INITIALIZER实际上只是把条件变量的各个字段都初始化为0

- pthread_cond_destroy函数用于销毁条件变量

  - 销毁一个正在被等待的条件变量将失败并返回EBUSY

- pthread_cond_broadcast函数以广播的方式唤醒所有等待目标条件变量的线程

- pthread_coond_signal函数用于唤醒一个等待目标条件变量的线程

  - 哪个线程被唤醒取决于线程的优先级和调度策略

- pthread_cond_wait函数用于等待目标条件变量

  - mutex参数是用于保护条件变量的互斥锁，以确保pthread_cond_wait操作的原子性
    - 在调用前，**必须**确保互斥锁mutex已经加锁
  - pthread_cond_wait函数执行时，首先把调用线程放入条件变量的等待队列中，然后将互斥锁mutex解锁
  - 当pthread_cond_wait函数成功返回时，互斥锁mutex将再次被锁上

- 成功时返回0，失败则返回错误码

## 线程同步机制包装类

```c++
#ifndef LOCKER_H
#define LOCKER_H
#include &lt;exception&gt;
#include &lt;pthread.h&gt;
#include &lt;semaphore.h&gt;
/*封装信号量的类*/
class sem{
public:
	/*创建并初始化信号量*/
	sem(){
        if(sem_init(&amp;m_sem,0,0)!=0){
            /*构造函数没有返回值,可以通过抛出异常来报告错误*/
            throw std::exception();
		}
	}
    /*销毁信号量*/
    ~sem(){
		sem_destroy(&amp;m_sem);
	}
    /*等待信号量*/
    bool wait(){
        return sem_wait(&amp;m_sem)==0;
	}
    /*增加信号量*/
    bool post(){
		return sem_post(&amp;m_sem)==0;
	}
private:
	sem_t m_sem;
};

/*封装互斥锁的类*/
class locker{
	public:
	/*创建并初始化互斥锁*/
	locker(){
		if(pthread_mutex_init(&amp;m_mutex,NULL)!=0){
			throw std::exception();
		}
	}
	/*销毁互斥锁*/
	~locker(){
		pthread_mutex_destroy(&amp;m_mutex);
	}
	/*获取互斥锁*/
	bool lock(){
		return pthread_mutex_lock(&amp;m_mutex)==0;
	}
	/*释放互斥锁*/
	bool unlock(){
		return pthread_mutex_unlock(&amp;m_mutex)==0;
	}
private:
	pthread_mutex_t m_mutex;
};

/*封装条件变量的类*/
class cond{
	public:
	/*创建并初始化条件变量*/
	cond(){
		if(pthread_mutex_init(&amp;m_mutex,NULL)!=0){
			throw std::exception();
		}
		if(pthread_cond_init(&amp;m_cond,NULL)!=0){
            /*构造函数中一旦出现问题,就应该立即释放已经成功分配了的资源*/
            pthread_mutex_destroy(&amp;m_mutex);
            throw std::exception();
		}
	}
	/*销毁条件变量*/
    ~cond(){
        pthread_mutex_destroy(&amp;m_mutex);
        pthread_cond_destroy(&amp;m_cond);
    }
    /*等待条件变量*/
    bool wait(){
        int ret=0;
        pthread_mutex_lock(&amp;m_mutex);
        ret=pthread_cond_wait(&amp;m_cond,&amp;m_mutex);
        pthread_mutex_unlock(&amp;m_mutex);
        return ret==0;
	}
    /*唤醒等待条件变量的线程*/
    bool signal(){
		return pthread_cond_signal(&amp;m_cond)==0;
	}
private:
    pthread_mutex_t m_mutex;
    pthread_cond_t m_cond;
};
#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="多线程环境"><a href="#多线程环境" class="headerlink" title="多线程环境"></a>多线程环境</h2><h3 id="可重入函数"><a href="#可重入函数" class="headerlink" title="可重入函数"></a>可重入函数</h3><p>如果一个函数能被多个线程同时调用且不发生竞态条件，则我们称它是线程安全的(thread safe)，或者说它是可重入函数</p>
<p>在多线程程序中调用库函数，一定要使用其可重入版本</p>
<h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><p>思考这样一个问题：如果一个多线程程序的某个线程调用了fork函数，那么新创建的子进程是否将自动创建和父进程相同数量的线程呢？</p>
<hr>
<p>答案是“否”，正如我们期望的那样。子进程只拥有一个执行线程，它是调用fork的那个线程的完整复制。并且子进程将自动继承父进程中互斥锁（条件变量与之类似）的状态。也就是说，父进程中已经被加锁的互斥锁在子进程中也是被锁住的</p>
<p>这就引起了一个问题：子进程可能不清楚从父进程继承而来的互斥锁的具体状态（是加锁状态还是解锁状态）。这个互斥锁可能被加锁了，但并不是由调用fork函数的那个线程锁住的,而是由其他线程锁住的。如果是这种情况，则子进程若再次对该互斥锁执行加锁操作就会导致死锁</p>
<hr>
<p>pthread提供了一个专门的函数pthread_atfork，以确保fork调用后父进程和子进程都拥有一个清楚的锁状态</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">pthread_atfork</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span>prepare<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span>parent<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span>child<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>该函数建立3个fork句柄来帮助我们清理互斥锁的状态</li>
<li>prepare句柄将在fork调用创建出子进程之前被执行，可以用来锁住所有父进程中的互斥锁</li>
<li>parent句柄则是fork调用创建出子进程之后，而fork返回之前，在父进程中被执行，释放所有在prepare句柄中被锁住的互斥锁</li>
<li>child句柄是fork返回之前，在子进程中被执行，作用与parent句柄一样</li>
<li>成功时返回0，失败则返回错误码</li>
</ul>
<h3 id="线程和信号"><a href="#线程和信号" class="headerlink" title="线程和信号"></a>线程和信号</h3><p>每个线程都可以独立地设置信号掩码</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">pthread_sigmask</span><span class="token punctuation">(</span><span class="token keyword">int</span> how<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token class-name">sigset_t</span><span class="token operator">*</span> newmask<span class="token punctuation">,</span> <span class="token class-name">sigset_t</span><span class="token operator">*</span> oldmask<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li>该函数参数的含义与sigprocmask的参数完全相同</li>
<li>成功时返回0，失败则返回错误码</li>
</ul>
<hr>
<p>由于进程中的所有线程共享该进程的信号，所以线程库将根据线程掩码决定把信号发送给哪个具体的线程。因此，如果我们在每个子线程中都单独设置信号掩码，就很容易导致逻辑错误。此外，所有线程共享信号处理函数。也就是说，当我们在一个线程中设置了某个信号的信号处理函数后，它将覆盖其他线程为同一个信号设置的信号处理函数。这两点都说明,我们应该定义一个专门的线程来处理所有的信号</p>
<p><strong>步骤：</strong></p>
<ol>
<li><p>在主线程创建出其他子线程之前就调用pthread_sigmask来设置好信号掩码，所有新创建的子线程都将自动继承这个信号掩码。这样做之后，实际上所有线程都不会响应被屏蔽的信号了。</p>
</li>
<li><p>在某个线程中调用如下函数来等待信号并处理之：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">sigwait</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">sigset_t</span><span class="token operator">*</span> set<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>set参数指定要等待的信号的集合</li>
<li>sig指向的整数用于存储该函数返回的信号值</li>
<li>成功时返回0，失败则返回错误码</li>
<li>如果我们使用了sigwait，就不应该再为信号设置信号处理函数了。这是因为当程序接收到信号时，二者中只能有一个起作用</li>
</ul>
</li>
</ol>
<hr>
<p>pthread还提供了下面的方法，使得我们可以明确地将一个信号发送给指定的线程：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">pthread_kill</span><span class="token punctuation">(</span><span class="token class-name">pthread_t</span> thread<span class="token punctuation">,</span> <span class="token keyword">int</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>thread参数指定目标线程</li>
<li>sig参数指定待发送的信号</li>
<li>如果sig为0，则pthread_kill不发送信号，但它仍然会执行错误检查，可以利用这种方式来检测目标线程是否存在</li>
<li>成功时返回0，失败则返回错误码</li>
</ul>
]]></content>
      <tags>
        <tag>C++ socket</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux服务器程序规范</title>
    <url>/2023/11/29/3-Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">    


<ul>
<li>Linux服务器程序一般以后台进程形式运行，后台进程又称守护进程，没有控制终端，因而不会意外接收到用户输入，守护进程的父进程通常是init进程</li>
<li>Linux服务器程序通常有一套日志系统，它至少能输出日志到文件，有的高级服务器还能输出日志到专门的UDP服务器。大部分后台进程都在/var/log目录下拥有自己的日志目录</li>
<li>Linux服务器程序一般以某个专门的非root身份运行，比如mysqld、httpd、syslogd等后台进程，分别拥有自己的运行账户mysql、apache和syslog</li>
<li>Linux服务器程序通常是可配置的。服务器程序通常能处理很多命令行选项，如果运行的选项太多，则可以用配置文件来管理。绝大多数服务器程序都有配置文件，并存放在/etc目录下</li>
<li>Linux服务器进程通常会在启动的时候生成一个PID文件并存入/var/run目录中，以记录改后台进程的PID</li>
<li>Linux服务器程序需要考虑系统资源和限制，已预测自身能承受多大负荷，比如进程可用文件描述符总数和内存总量</li>
</ul>
<span id="more"></span>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="Linux系统日志"><a href="#Linux系统日志" class="headerlink" title="Linux系统日志"></a>Linux系统日志</h3><p>linux提供一个守护进程来处理系统日志——rsyslogd</p>
<ul>
<li>rsyslogd守护进程既能接收用户进程输出的日志，又能接收内核日志<ul>
<li>用户进程是通过调用syslog函数生成系统日志，改函数将日志输出到一个UNIX本地域socket类型（AF_UNIX）的文件/dev/log中，rsyslogd则监听改文件以获取用户进程的输出</li>
<li>内核日志由printk等函数打印至内核的环状缓存中，环状缓存的内容直接映射到/proc/kmsg文件中，rsyslogd则通过读取该文件以获得内核日志</li>
</ul>
</li>
<li>rsyslogd守护进程在接收到用户进程或内核输入的日志后，会把它们输出至某些特定的日志文件<ul>
<li>普通信息保存至/var/log/messages文件</li>
<li>内核信息保存至/var/log/kern.log文件</li>
<li>可在rsyslogd的配置文件中设置，配置文件为/etc/rsyslog.conf</li>
</ul>
</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202312311545712.png" alt="image-20231231154522607"></li>
</ul>
<h3 id="syslog函数"><a href="#syslog函数" class="headerlink" title="syslog函数"></a>syslog函数</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;syslog.h&gt;</span></span>
<span class="token keyword">void</span> <span class="token function">syslog</span><span class="token punctuation">(</span><span class="token keyword">int</span> priority<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> message<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li><p>应用程序使用syslog函数与rsyslogd守护进程通信</p>
</li>
<li><p>该函数采用可变参数（第二个参数message和第三个参数…）来结构化输出</p>
</li>
<li><p>priority参数是所谓的设施至与日志级别的按位或，设施值默认值为LOG_USER</p>
<ul>
<li><p>日志级别有如下几个：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token expression">＜syslog<span class="token punctuation">.</span>h＞</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LOG_EMERG</span> <span class="token expression"><span class="token number">0</span></span><span class="token comment">/*系统不可用*/</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LOG_ALERT</span> <span class="token expression"><span class="token number">1</span></span><span class="token comment">/*报警，需要立即采取动作*/</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LOG_CRIT</span> <span class="token expression"><span class="token number">2</span></span><span class="token comment">/*非常严重的情况*/</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LOG_ERR</span> <span class="token expression"><span class="token number">3</span></span><span class="token comment">/*错误*/</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LOG_WARNING</span> <span class="token expression"><span class="token number">4</span></span><span class="token comment">/*警告*/</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LOG_NOTICE</span> <span class="token expression"><span class="token number">5</span></span><span class="token comment">/*通知*/</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LOG_INFO</span> <span class="token expression"><span class="token number">6</span></span><span class="token comment">/*信息*/</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LOG_DEBUG</span> <span class="token expression"><span class="token number">7</span></span><span class="token comment">/*调试*/</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
</ul>
<hr>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;syslog.h&gt;</span></span>
<span class="token keyword">void</span> <span class="token function">openlog</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> ident<span class="token punctuation">,</span> <span class="token keyword">int</span> logopt<span class="token punctuation">,</span> <span class="token keyword">int</span> facility<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li><p>该函数可以改变syslog的默认输出方式，进一步结构化日志内容</p>
</li>
<li><p>ident 参数指定的字符串将被添加到日志消息的日期和时间之后，通常被设置为程序的名字</p>
</li>
<li><p>logopt 参数对后续syslog调用的行为进行配置，可取下列值得按位或：</p>
<ul>
<li>```c<h1 id="define-LOG-PID-0x01-在日志消息中包含程序PID"><a href="#define-LOG-PID-0x01-在日志消息中包含程序PID" class="headerlink" title="define LOG_PID 0x01/在日志消息中包含程序PID/"></a>define LOG_PID 0x01/<em>在日志消息中包含程序PID</em>/</h1><h1 id="define-LOG-CONS-0x02-如果消息不能记录到日志文件，则打印至终端"><a href="#define-LOG-CONS-0x02-如果消息不能记录到日志文件，则打印至终端" class="headerlink" title="define LOG_CONS 0x02/如果消息不能记录到日志文件，则打印至终端/"></a>define LOG_CONS 0x02/<em>如果消息不能记录到日志文件，则打印至终端</em>/</h1><h1 id="define-LOG-ODELAY-0x04-延迟打开日志功能直到第一次调用syslog"><a href="#define-LOG-ODELAY-0x04-延迟打开日志功能直到第一次调用syslog" class="headerlink" title="define LOG_ODELAY 0x04/延迟打开日志功能直到第一次调用syslog/"></a>define LOG_ODELAY 0x04/<em>延迟打开日志功能直到第一次调用syslog</em>/</h1><h1 id="define-LOG-NDELAY-0x08-不延迟打开日志功能"><a href="#define-LOG-NDELAY-0x08-不延迟打开日志功能" class="headerlink" title="define LOG_NDELAY 0x08/不延迟打开日志功能/"></a>define LOG_NDELAY 0x08/<em>不延迟打开日志功能</em>/</h1><pre class="line-numbers language-none"><code class="language-none">
- facility 参数可用来修改syslog函数中的默认设施值

-----

```c
#include &lt;syslog.h&gt;
int setlogmask(int maskpri);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p>该函数用于设置syslog的日志掩码，用于过滤日志</p>
</li>
<li>maskpri参数指定日志掩码值，日志级别大于日志掩码的日志信息将被系统忽略</li>
<li>该函数始终会成功，返回调用进程先前的日志掩码值</li>
</ul>
<hr>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;syslog.h&gt;</span></span>
<span class="token keyword">void</span> <span class="token function">closelog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>该函数用户关闭日志功能</li>
</ul>
<h2 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h2><h3 id="UID、EUID、GID和EGID"><a href="#UID、EUID、GID和EGID" class="headerlink" title="UID、EUID、GID和EGID"></a>UID、EUID、GID和EGID</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token expression">＜sys<span class="token operator">/</span>types<span class="token punctuation">.</span>h＞</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token expression">＜unistd<span class="token punctuation">.</span>h＞</span></span>
<span class="token class-name">uid_t</span> <span class="token function">getuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*获取真实用户ID*/</span>
<span class="token class-name">uid_t</span> <span class="token function">geteuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*获取有效用户ID*/</span>
<span class="token class-name">gid_t</span> <span class="token function">getgid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*获取真实组ID*/</span>
<span class="token class-name">gid_t</span> <span class="token function">getegid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*获取有效组ID*/</span>
<span class="token keyword">int</span> <span class="token function">setuid</span><span class="token punctuation">(</span><span class="token class-name">uid_t</span> uid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*设置真实用户ID*/</span>
<span class="token keyword">int</span> <span class="token function">seteuid</span><span class="token punctuation">(</span><span class="token class-name">uid_t</span> uid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*设置有效用户ID*/</span>
<span class="token keyword">int</span> <span class="token function">setgid</span><span class="token punctuation">(</span><span class="token class-name">gid_t</span> gid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*设置真实组ID*/</span>
<span class="token keyword">int</span> <span class="token function">setegid</span><span class="token punctuation">(</span><span class="token class-name">gid_t</span> gid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*设置有效组ID*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>UID——真实用户ID</li>
<li>EUID——有效用户ID</li>
<li>GID——真实组ID</li>
<li>EGID——有效组ID</li>
</ul>
<hr>
<p><strong>EUID和EGID的作用</strong>——方便资源访问，使运行程序的用户拥有该程序的有效用户的权限</p>
<pre class="line-numbers language-none"><code class="language-none">比如su程序，任何用户都可以使用它来修改自己的账户信息，但修改账户时su程序不得不访问/etc/passwd文件，而访问该文件是需要root权限的。那么以普通用户身份启动的su程序如何能访问/etc/passwd文件呢？窍门就在EUID。用ls命令可以查看到，su程序的所有者是root，并且它被设置了set-user-id标志。这个标志表示，任何普通用户运行su程序时，其有效用户就是该程序的所有者root。那么，根据有效用户的含义，任何运行su程序的普通用户都能够访问/etc/passwd文件。有效用户为root的进程称为特权进程（privilegedprocesses）。EGID的含义与EUID类似：给运行目标程序的组用户提供有效组的权限<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><p><strong>将root身份启动的进程切换为以一个普通用户身份运行</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> bool <span class="token function">switch_to_user</span><span class="token punctuation">(</span><span class="token class-name">uid_t</span> user_id<span class="token punctuation">,</span><span class="token class-name">gid_t</span> gp_id<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">/*先确保目标用户不是root*/</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>user_id<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>gp_id<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    	<span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/*确保当前用户是合法用户：root或者目标用户*/</span>
    <span class="token class-name">gid_t</span> gid<span class="token operator">=</span><span class="token function">getgid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">uid_t</span> uid<span class="token operator">=</span><span class="token function">getuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>gid<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">||</span><span class="token punctuation">(</span>uid<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span>gid<span class="token operator">!=</span>gp_id<span class="token punctuation">)</span><span class="token operator">||</span><span class="token punctuation">(</span>uid<span class="token operator">!=</span>user_id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    	<span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/*如果不是root，则已经是目标用户*/</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>uid<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    	<span class="token keyword">return</span> true<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/*切换到目标用户*/</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">setgid</span><span class="token punctuation">(</span>gp_id<span class="token punctuation">)</span>＜<span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">||</span><span class="token punctuation">(</span><span class="token function">setuid</span><span class="token punctuation">(</span>user_id<span class="token punctuation">)</span>＜<span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    	<span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="进程间关系"><a href="#进程间关系" class="headerlink" title="进程间关系"></a>进程间关系</h2><h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token class-name">pid_t</span> <span class="token function">getpgid</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>Linux下每个进程都隶属于一个进程组，因此进程除了PID信息外，还有进程组ID（PGID），可以使用该函数来获取指定进程的PGID</li>
<li>成功时返回进程pid所属进程组的PGID，失败时返回-1并设置errno</li>
<li>每个进程组都有一个首领进程，其PGID和PID相同，进程组将一直存在直到其中所有进程都退出或者加入到其他进程组</li>
</ul>
<hr>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">setpgid</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">,</span> <span class="token class-name">pid_t</span> pgid<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>该函数将PID为pid的进程的PGID设置为pgid</li>
<li>如果pid和pgid相同，则由pid指定的进程将被设置为进程组首领</li>
<li>如果pid为0，则表示设置当前进程的PGID为pgid</li>
<li>如果pgid为0，则使用pid作为目标PGID</li>
<li>成功时返回0，失败时返回-1并设置errno</li>
<li>一个进程只能设置自己或者其子进程的PGID，并且当子进程调用exec系列函数后，我们也不能再在父进程中对它设置PGID</li>
</ul>
<h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>一些有关联的进程组形成一个会话</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token class-name">pid_t</span> <span class="token function">setsid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>该函数用于创建一个会话</li>
<li>该函数不能由进程组的首领进程调用，否则将产生一个错误</li>
<li><p>对于非首领的进程</p>
<ul>
<li>调用进程成为会话的首领，此时该进程时新会话的唯一成员</li>
<li>新建一个进程组，其PGID就是调用进程的PID，调用进程成为该组的首领</li>
<li>调用进程将甩开终端（如果有的话）</li>
</ul>
</li>
<li><p>成功时返回新的进程组的PGID，失败时返回-1并设置errno</p>
</li>
<li>该函数常用于创建守护进程，通过调用该函数，守护进程可以脱离终端和控制终端的会话，独立运行，并且不受终端会话的影响（即不受父进程影响）</li>
</ul>
<hr>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token class-name">pid_t</span> <span class="token function">getsid</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>Linux进程并未提供所谓会话ID（SID）的概念，Linux系统认为它等同于会话首领所在进程组的PGID，该函数用于读取SID</li>
</ul>
<h3 id="用ps命令查看进程关系"><a href="#用ps命令查看进程关系" class="headerlink" title="用ps命令查看进程关系"></a>用ps命令查看进程关系</h3><p>执行ps命令可查看进程、进程组和会话之间的关系</p>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/202312311740160.png" alt="image-20231231174040212"></p>
<hr>
<p><strong>书本示例</strong></p>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/202312311741255.png" alt="image-20231231174139348"></p>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/202312311741583.png" alt="image-20231231174153746"></p>
<p>在bash shell下执行ps和less命令的，所以ps和less命令的父进程是bash命令，这可以从PPID（父进程PID）一列看出。这3条命令创建了1个会话（SID是1943）和2个进程组（PGID分别是1943和2298）。bash命令的PID、PGID和SID都相同，很明显它既是会话的首领，也是组1943的首领。ps命令则是组2298的首领，因为其PID也是2298</p>
<p>~注：默认情况下，子进程与父进程同属一个进程组~</p>
<h2 id="系统资源限制"><a href="#系统资源限制" class="headerlink" title="系统资源限制"></a>系统资源限制</h2><p>Linux上运行的程序都会收到资源限制的影响，比如物理设备限制（CPU数量、内存数量等）、系统策略限制（CPU时间等），以及具体实现的限制（比如文件名的最大长度），Linux系统资源限制可以通过如下一堆函数来读取和设置</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/resource.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">getrlimit</span><span class="token punctuation">(</span><span class="token keyword">int</span> resource<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">rlimit</span><span class="token operator">*</span> rlim<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">setrlimit</span><span class="token punctuation">(</span><span class="token keyword">int</span> resource<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">rlimit</span><span class="token operator">*</span> rlim<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>rlim参数时rlimit结构体类型指针</p>
<ul>
<li>```c<br>struct rlimit{<pre><code>rlim_t rlim_cur;
rlim_t rlim_max;
</code></pre>};<pre class="line-numbers language-none"><code class="language-none">
  - rlim_t是一个整数类型，描述资源级别

  - rlim_cur成员指定资源的软限制，是一个建议性的、最好不要超越的限制，如果超越，系统可能向进程发送信号以终止其运行

  - rlim_max成员指定资源的硬限制，一般是软限制的上限，普通程序可以减小硬限制，而只有以root身份运行的程序才能增加硬限制

  - 用户将只能将软限制更改为0~硬限制之间的某个值，或者降低硬限制

- resource参数指定资源限制类型

  - ![image-20231231181318589](https://gitee.com/renmale-sztu/image/raw/master/202312311813347.png)

- 成功时返回0，失败时返回-1并设置errno

## 改变工作目录和根目录

```c
#include &lt;unistd.h&gt;
char* getcwd(char* buf, size_t size);//获取进程当前工作目录
int chdir(const char* path);//改变进程工作目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p>getcwd</p>
<ul>
<li>buf参数指向的内存用于存储进程当前工作目录的绝对路径名，其大小由size参数决定<ul>
<li>如果当前工作目录的决定路径的长度（加上一个结束字符“\0”）超过了size，而getcwd将返回NULL，并设置errno为ERANGE</li>
<li>如果buf为NULL并且size非0，则getcwd可能在内部使用malloc动态分配内存，并将进程的当前工作目录存储在其中</li>
</ul>
</li>
<li>成功时返回一个指向目标存储区（buf指向的缓存器或者函数内部动态创建的缓存区</li>
<li>失败时返回NULL并设置errno</li>
</ul>
</li>
<li>chdir<ul>
<li>path参数指定要切换到的目标目录</li>
<li>成功时返回0，失败时返回-1并设置errno</li>
</ul>
</li>
</ul>
<hr>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">chroot</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//改变进程根目录</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>path参数指定要切换到的目标根目录</li>
<li>成功时返回0，，失败时返回-1并设置errno</li>
<li>chroot并不改变进程的当前工作目录，所以调用chroot之后，我们仍需要使用chdir(“/“)来将工作目录切换至新的根目录</li>
<li>改变进程根目录之后，程序可能无法访问类似/dev的文件，但是进程原先打开的文件描述符依然生效</li>
<li>只有特权进程才能改变根目录~有效用户为root的进程~</li>
</ul>
<h2 id="服务器程序后台化"><a href="#服务器程序后台化" class="headerlink" title="服务器程序后台化"></a>服务器程序后台化</h2><p><strong>将服务器程序以守护进程的方式运行</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">bool <span class="token function">daemonize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">/*创建子进程，关闭父进程，这样可以使程序在后台运行*/</span>
    <span class="token class-name">pid_t</span> pid<span class="token operator">=</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>pid＜<span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    	<span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>pid＞<span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    	<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/*设置文件权限掩码。当进程创建新文件（使用open(const char*pathname,intflags,mode_t mode)系统调用）时，文件的权限将是mode＆0777*/</span>
    <span class="token function">umask</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/*创建新的会话，设置本进程为进程组的首领*/</span>
    <span class="token class-name">pid_t</span> sid<span class="token operator">=</span><span class="token function">setsid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>sid＜<span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    	<span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/*切换工作目录*/</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">chdir</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>＜<span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    	<span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/*关闭标准输入设备、标准输出设备和标准错误输出设备*/</span>
    <span class="token function">close</span><span class="token punctuation">(</span>STDIN_FILENO<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>STDOUT_FILENO<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>STDERR_FILENO<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/*关闭其他已经打开的文件描述符，代码省略*/</span>
    <span class="token comment">/*将标准输入、标准输出和标准错误输出都定向到/dev/null文件*/</span>
    <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/null"</span><span class="token punctuation">,</span>O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/null"</span><span class="token punctuation">,</span>O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/null"</span><span class="token punctuation">,</span>O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<p>linux提供了完成上述功能的库函数</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">daemon</span><span class="token punctuation">(</span><span class="token keyword">int</span> nochdir<span class="token punctuation">,</span> <span class="token keyword">int</span> noclose<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>nochdir参数用于指定是否改变工作目录，为0时，工作目录将被设置为”/“（根目录），否则继续使用当前目录</li>
<li>noclose参数为0时，标准输入、标准输出和标准错误都被重定向到/dev/null文件中，否则依然使用原来的设备</li>
<li>成功时返回0，失败时返回-1并设置errno</li>
</ul>
]]></content>
      <tags>
        <tag>C++ socket</tag>
      </tags>
  </entry>
  <entry>
    <title>高性能服务器程序框架</title>
    <url>/2023/11/29/4-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">    

<h1 id="高性能服务器程序框架"><a href="#高性能服务器程序框架" class="headerlink" title="高性能服务器程序框架"></a>高性能服务器程序框架</h1><p><strong>服务器的桑格主要模块</strong></p>
<ul>
<li>I/O处理单元</li>
<li>逻辑单元</li>
<li>存储单元</li>
</ul>
<span id="more"></span>
<h2 id="服务器模型"><a href="#服务器模型" class="headerlink" title="服务器模型"></a>服务器模型</h2><h3 id="C-S模型"><a href="#C-S模型" class="headerlink" title="C/S模型"></a>C/S模型</h3><p><img src="https://gitee.com/renmale-sztu/image/raw/master/202401022340788.png" alt="image-20240102234004705"></p>
<hr>
<ul>
<li>服务器启动后，首先创建一/多个监听socket并调用bind函数将其绑定刀服务器感兴趣的端口上，然后调用listen函数等待客户连接</li>
<li><p>客户端调用connect函数向服务器发起连接</p>
</li>
<li><p>客户连接请求是随机到达的异步事件，服务器需要使用某种I/O模型来监听这一事件</p>
</li>
<li>服务器监听到连接请求后，需要调用accept函数接受它，并分配一个逻辑单元为新的连接服务，逻辑单元可以是新创建的子进程、子线程或者其他</li>
<li>逻辑单元读取客户请求，处理该请求，然后将处理结果返回给客户端</li>
<li>服务器再处理一个客户请求的同时还会继续监听其他客户请求</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202401031908326.png" alt="image-20240103190410942"></li>
</ul>
<hr>
<p><strong>优点：</strong></p>
<ul>
<li>非常适合资源相对集中的场合</li>
<li>实现简单</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>服务器是通信的中心，当访问量过大时，可能所有客户都将得到很慢的响应</li>
</ul>
<h3 id="P2P模型"><a href="#P2P模型" class="headerlink" title="P2P模型"></a>P2P模型</h3><p><img src="https://gitee.com/renmale-sztu/image/raw/master/202401031910231.png" alt="image-20240103191009526"></p>
<hr>
<ul>
<li>每台机器在消耗服务的同时也给别人提供服务</li>
<li>典范：云计算机群</li>
<li>主机之间很难互相法向，实际使用的P2P模型通常带有一个专门的发现服务器，这个发现服务器通常还提供查找服务<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202401031917128.png" alt="image-20240103191755238"></li>
</ul>
</li>
</ul>
<hr>
<p><strong>优点</strong></p>
<ul>
<li>资源能够充分、自由地共享</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>当用户之间传输地请求过多时，网络地负载将加重</li>
</ul>
<h2 id="服务器编程框架"><a href="#服务器编程框架" class="headerlink" title="服务器编程框架"></a>服务器编程框架</h2><p><img src="https://gitee.com/renmale-sztu/image/raw/master/202401031919932.png" alt="image-20240103191927126"></p>
<p><strong>服务器基本模块功能描述</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">模块</th>
<th style="text-align:left">单个服务器程序</th>
<th style="text-align:left">服务器机群</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">I/O处理单元</td>
<td style="text-align:left">处理客户连接，读写网络数据</td>
<td style="text-align:left">作为接入服务器，实现负载均衡</td>
</tr>
<tr>
<td style="text-align:center">逻辑单元</td>
<td style="text-align:left">业务进程或线程</td>
<td style="text-align:left">逻辑服务器</td>
</tr>
<tr>
<td style="text-align:center">网络存储单元</td>
<td style="text-align:left">本地数据库、文件或缓存</td>
<td style="text-align:left">数据库服务器</td>
</tr>
<tr>
<td style="text-align:center">请求队列</td>
<td style="text-align:left">各单元之间的通信方式</td>
<td style="text-align:left">各服务器之间的永久TCP连接</td>
</tr>
</tbody>
</table>
</div>
<h2 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h2><p><strong>阻塞I/O</strong></p>
<ul>
<li>针对阻塞I/O执行的系统调用可能无法立即完成而被操作系统挂起，直到等待的事件发生为止</li>
<li>比如客户端通过connect向服务器发起连接时，connect将首先发送同步报文段给服务器，然后等待服务器返回确认报文段。如果服务器的确认报文段没有立即到达客户端，则connect调用将被挂起，直到客户端收到确认报文段并唤醒connect调用</li>
<li>socket基础API中，可能被阻塞的系统调用包括accept、send、recv和connect</li>
</ul>
<p><strong>非阻塞I/O</strong></p>
<ul>
<li>针对非阻塞I/O执行的系统调用总是立即返回，而不管事件是否已经发生，如果事件没有发生，这些系统调用就返回-1，和出错的情况一样，此时需要根据errno来区分这两种情况</li>
<li>对于accept、send、recv而言，事件未发生时errno通常被设置未<strong>EAGAIN</strong>或者<strong>EWOULDBLOCK</strong></li>
<li>对于connect而言，errno则被设置为<strong>EINPROGRESS</strong></li>
<li>只有在事件已经发生的情况下操作非阻塞I/O时，才能提高程序的效率，因此，非阻塞I/O通常要和其他I/O通知机制一起使用，比如I/O复用和SIGIO信号</li>
</ul>
<p><strong>I/O复用</strong></p>
<ul>
<li>应用程序通过I/O复用函数向内核注册一组事件，内核通过I/O复用程序把其中就绪的事件通知给应用程序</li>
<li>Linux上常用的I/O复用函数是select、poll和epoll_wait</li>
<li>I/O复用函数本身是阻塞的，它们能提高程序效率的原因在于它们具有同时监听多个I/O事件的能力</li>
</ul>
<p><strong>SIGIO信号</strong></p>
<ul>
<li>我们可以为一个目标文件描述符指定宿主进程，那么被指定的宿主进程将捕获到SIGIO信号，这样，当目标文件描述符上有事件发生时，SIGIO信号的信号处理函数将被触发，我们也就可以在该信号处理函数中对目标文件描述符执行非阻塞I/O操作</li>
</ul>
<p><strong>异步I/O</strong></p>
<ul>
<li>用户可以直接对I/O执行读写操作，这些操作告诉内核用户读写缓冲区的位置，以及I/O操作完成之后内核通知应用程序的方式</li>
<li>异步I/O的读写操作总是立即返回，而不论是否是阻塞的，因为真正的读写操作已经有内核接管</li>
<li>同步I/O模型要求用户代码自行执行I/O操作（将数据从内核缓冲区读入用户缓冲区，或将数据从用户缓冲区写入内核缓冲区），而异步I/O机制则由内核来执行I/O操作（数据在内核缓冲区和用户缓冲区之间的移动是由内核在”后台“完成的）</li>
<li>同步I/O向应用程序通知的是I/O就绪事件，异步I/O向应用程序通知的是I/O完成事件</li>
</ul>
<hr>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">I/O模型</th>
<th style="text-align:left">读写操作和阻塞阶段</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">阻塞I/O</td>
<td style="text-align:left">程序阻塞于读写函数</td>
</tr>
<tr>
<td style="text-align:center">I/O复用</td>
<td style="text-align:left">程序阻塞于I/O复用系统调用，但可同时监听多个I/O事件。对于I/O本身的读写操作是非阻塞的</td>
</tr>
<tr>
<td style="text-align:center">SIGIO信号</td>
<td style="text-align:left">信号触发读写就绪事件，用户程序执行读写操作。程序没有阻塞阶段</td>
</tr>
<tr>
<td style="text-align:center">异步I/O</td>
<td style="text-align:left">内核执行读写操作并触发读写完成事件。程序没有阻塞阶段</td>
</tr>
</tbody>
</table>
</div>
<h2 id="两种高效的事件处理模式"><a href="#两种高效的事件处理模式" class="headerlink" title="两种高效的事件处理模式"></a>两种高效的事件处理模式</h2><h3 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h3><p>Reactor模式要求主线程（I/O处理单元）只负责监听文件描述符上是否有事件发生，有的话就立即将该事件通知工作线程（逻辑单元）。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。</p>
<hr>
<p><strong>工作流程</strong></p>
<ul>
<li>主线程往epoll内核事件表中注册socket上的读就绪事件</li>
<li>主线程调用epoll_wait等待socket上有数据可读</li>
<li>当socket上有数据可读是，epoll_wait通知主线程，主线程则将socket可读事件放入请求队列</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件</li>
<li>主线程调用epoll_wait等待socket可写</li>
<li>当socket可写时，epoll_wait通知主线程，主线程将socket可写事件放入请求队列</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果</li>
</ul>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/202401041926282.png" alt="image-20240104192642172"></p>
<p>工作线程从请求队列中取出事件后，将根据事件的类型来决定如何处理它，因此没必要区分所谓的”读工作线程“和”写工作线程“</p>
<h3 id="Proactor模式"><a href="#Proactor模式" class="headerlink" title="Proactor模式"></a>Proactor模式</h3><p>与Reactor模式不同，Proactor模式将所有I/O操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑</p>
<hr>
<p><strong>使用异步I/O模型实现Proactor模式的工作流程（以aio_read和aio_write为例）</strong></p>
<ul>
<li>主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序（这里以信号为例）</li>
<li>主线程继续处理其他逻辑</li>
<li>当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用</li>
<li>应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用aio_write函数向内核注册socket上的写完成事件，并告诉内核用户写缓存区的位置，以及写操作完成时如何通知应用程序</li>
<li>主线程继续处理其他逻辑</li>
<li>当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据以及发送完毕</li>
<li>应用程序预先定义好的信号处理函数选择一个工作线程来坐善后处理，比如决定是否关闭socket</li>
</ul>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/202401042004762.png" alt="image-20240104200456610"></p>
<h3 id="模拟Proactor模式"><a href="#模拟Proactor模式" class="headerlink" title="模拟Proactor模式"></a>模拟Proactor模式</h3><p><strong>使用同步I/O方式模拟Proactor原理</strong></p>
<p>主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一”完成事件“，那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理</p>
<hr>
<p><strong>工作流程</strong></p>
<ul>
<li>主线程往epoll内核事件表中注册socket上的读就绪事件</li>
<li>主线程调用epoll_wait等待socket上有数据可读</li>
<li>当socket上有数据可读时，epoll_wait通知主线程。主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册socket上的写就绪事件</li>
<li>主线程调用epoll_wait等待socket可写</li>
<li>当socket可写时，epoll_wait通知主线程，主线程往socket上写入服务器处理客户请求的结果</li>
</ul>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/202401042201628.png" alt="image-20240104220134342"></p>
<h2 id="两种高效的并发模式"><a href="#两种高效的并发模式" class="headerlink" title="两种高效的并发模式"></a>两种高效的并发模式</h2><p><strong>并发模式</strong></p>
<p>指I/O处理单元和多个逻辑单元之间协调完成任务的方法</p>
<h3 id="半同步-半异步模式"><a href="#半同步-半异步模式" class="headerlink" title="半同步/半异步模式"></a>半同步/半异步模式</h3><p><strong>同步</strong></p>
<ul>
<li>程序完全按照代码序列的顺序执行</li>
</ul>
<p><strong>异步</strong></p>
<ul>
<li>程序的执行需要系统事件来驱动</li>
<li>常见的系统事件包括中断、信号等</li>
</ul>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/202401042210726.png" alt="image-20240104221015851"></p>
<hr>
<p><strong>同步线程</strong></p>
<ul>
<li>按照同步方式运行的线程</li>
<li>效率相对较低，实时性较差，但逻辑简单</li>
</ul>
<p><strong>异步线程</strong></p>
<ul>
<li>按照异步方式运行的线程</li>
<li>执行效率高，实时性强，但程序复杂，难以调试和扩展，不适合大量的并发</li>
</ul>
<p><strong>半同步/半异步模式</strong></p>
<ul>
<li>同时使用同步线程和异步线程</li>
<li>既有较好的实时性，又能同时处理多个客户请求</li>
</ul>
<hr>
<p><strong>半同步/半异步模式</strong></p>
<ul>
<li>同步线程用于处理客户逻辑，相当于逻辑单元</li>
<li>异步线程用于处理I/O事件，相当于I/O处理单元</li>
<li>工作流程<ul>
<li>异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中</li>
<li>请求队列将通知某个工作在同步模式的工作线程来读取并处理该请求对象</li>
</ul>
</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202401042225120.png" alt="image-20240104222535300"></li>
</ul>
<hr>
<p><strong>半同步/半反应堆模式（变体）</strong></p>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/202401042226850.png" alt="image-20240104222651428"></p>
<ul>
<li>异步线程只有一个，由主线程来充当，负责监听所有socket上的事件</li>
<li>如果监听socket上有可读事件发生，即有新的请求到来，主线程就接受之已得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件</li>
<li>如果连接socket上有读写事件发生，即有新的客户请求到来或有数据要发送至客户端，主线程就将该连接socket插入请求队列中</li>
<li><p>所有工作线程都睡眠在请求队列上，当有任务到来时，它们将通过竞争获得任务的接管权</p>
</li>
<li><p>缺点</p>
<ul>
<li>主线程和工作线程共享请求队列，主线程往请求队列中添加任务，或者工作线程从请求队列中取出任务，都需要对请求队列枷锁保护，从而拜拜浪费CPU时间</li>
<li>每个工作线程在同一时间只能处理一个客户请求。如果客户数量较多，而工作线程较少，则请求队列中将堆积很多任务对象，客户端的响应速度将越来越慢。如果通过增加工作线程来解决该问题，工作线程的切换也将耗费大量CPU时间</li>
</ul>
</li>
</ul>
<hr>
<p><strong>一种相对高效的半同步/半异步模式</strong></p>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/202401042235599.png" alt="image-20240104223501134"></p>
<ul>
<li>主线程只管理监听socket，连接socket由工作线程来管理</li>
<li>当有新的连接到来时，主线程就接受之并将新返回的连接socket派发给某个工作线程，此后该新socket上的任何I/O操作都由被选中的工作线程来处理，直到客户关闭连接</li>
<li>主线程向工作线程派发socket的最简单方式，就是往它和工作线程之间的管道里写数据；工作线程检测到管道上有数据可读时，就分析是否是一个新的客户连接请求到来；如果是，则把该新socket上的读写事件注册到自己的epoll内核事件表中</li>
<li>每个线程（主线程和工作线程）都维持自己的事件循环，独立地监听不同的事件，每个线程都工作在异步模式，并非严格意义上的半同步/半异步</li>
</ul>
<h3 id="领导者-追随者模式"><a href="#领导者-追随者模式" class="headerlink" title="领导者/追随者模式"></a>领导者/追随者模式</h3><p><strong>领导者/追随者模式</strong></p>
<ul>
<li>是多个工作线程轮流获得事件源集合，轮流监听、分发并处理事件的一种模式</li>
<li>在任意时间点，程序都仅有一个领导者线程，它负责监听I/O事件，而其他线程都是追随者，它们休眠在线程池中等待成为新的领导者</li>
<li>当前的领导者如果检测到I/O事件，首先要从线程池中推选出新的领导者线程，然后处理I/O事件；新的领导者等待新的I/O事件，而原来的领导者处理I/O事件，二者实现了并发</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202401051559577.png" alt="image-20240105155943535"></li>
</ul>
<p><strong>组件</strong></p>
<ul>
<li>句柄集（HandleSet）</li>
<li>线程集（ThreadSet）</li>
<li>事件处理器（EventHandler）</li>
<li>具体的事件处理器（ConcreteEventHendler）</li>
</ul>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/202401051543250.png" alt="image-20240105154112689"></p>
<hr>
<p><strong>句柄集</strong></p>
<ul>
<li>句柄用于表示I/O资源，在Linux下通常就是一个文件描述符</li>
<li>句柄集管理众多句柄，它使用wait_for_event方法来监听这些句柄上的I/O事件，并将其中的就绪事件通知给领导者线程</li>
<li>领导者调用绑定到Handle上的事件处理器来处理事件，领导者将Handle和事件处理器绑定时通过调用句柄集中的register_handle方法实现</li>
</ul>
<p><strong>线程集</strong></p>
<ul>
<li>所有工作线程的管理者，负责各线程之间的同步以及新领导者线程的推选</li>
<li>三种状态<ul>
<li><strong>Leader</strong><ul>
<li>线程当前处理领导者身份，负责等待句柄集上的I/O事件</li>
</ul>
</li>
<li><strong>Processing</strong><ul>
<li>线程正在处理事件</li>
<li>领导者检测到I/O事件之后，可以转移到Processing状态来处理该事件，并调用promote_new_leader方法推选新的领导者；也可以指定其他追随者来处理事件，此时领导者的地位不变</li>
<li>处于该状态的线程处理完事件之后，如果当前线程集没有领导者，则它成为新的领导者，否则变为追随者</li>
</ul>
</li>
<li><strong>Follower</strong><ul>
<li>追随者</li>
<li>通过调用线程集的join方法等待成为新的领导者，也可能被当前的领导者指定来处理新的任务</li>
</ul>
</li>
</ul>
</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202401051551234.png" alt="image-20240105155155403"></li>
<li>领导者线程推选i虚拟的领导者和追随者等待成为新领导者这两个操作都将修改线程集，因此线程集提供一个成员Synchronizer来同步这两个操作，以避免竞态条件</li>
</ul>
<p><strong>事件处理器和具体的事件处理器</strong></p>
<ul>
<li>事件处理器通常包含一个/多个回调函数handle_event，这些函数用于处理事件对应的业务逻辑</li>
<li>事件处理器在使用前需要被绑定到某个句柄上，当该句柄上有事件发生时，领导者就执行与之绑定的事件处理器中的回调函数</li>
<li>具体的事件处理器是事件处理器的派生类，必须重新实现基类的handle_event方法</li>
</ul>
<hr>
<p><strong>总结</strong></p>
<ul>
<li>由于领导者线程自己监听I/O事件并处理客户请求，因而该模式不需要在线程之间传递任何额外的数据，也无需像半同步/半反应堆模式在线程之间同步对请求队列的访问</li>
<li>仅支持一个事件源集合，无法让每个工作线程独立地管理多个客户连接</li>
</ul>
<h2 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h2><p>逻辑单元内部的一种高效编程方法</p>
<hr>
<p><strong>状态独立的有限状态机</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//有的应用层协议头部包含数据包类型的字段，每种类型可以映射为逻辑单元的一种执行状态，服务器可以根据它来编写相应的处理逻辑</span>
<span class="token function">STATE_MACHINE</span><span class="token punctuation">(</span>Package_pack<span class="token punctuation">)</span><span class="token punctuation">{</span>
	PackageType_type<span class="token operator">=</span>_pack<span class="token punctuation">.</span><span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">switch</span><span class="token punctuation">(</span>_type<span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">case</span> type_A<span class="token operator">:</span>
			<span class="token function">process_package_A</span><span class="token punctuation">(</span>_pack<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token keyword">case</span> type_B<span class="token operator">:</span>
			<span class="token function">process_package_B</span><span class="token punctuation">(</span>_pack<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>每个状态相互独立即状态之间没有转移</li>
</ul>
<hr>
<p><strong>带状态转移的有限状态机</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">STATE_MACHINE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	State cur_State<span class="token operator">=</span>type_A<span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>cur_State<span class="token operator">!=</span>type_C<span class="token punctuation">)</span><span class="token punctuation">{</span>
		Package_pack<span class="token operator">=</span><span class="token function">getNewPackage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">switch</span><span class="token punctuation">(</span>cur_State<span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token keyword">case</span> type_A<span class="token operator">:</span>
				<span class="token function">process_package_state_A</span><span class="token punctuation">(</span>_pack<span class="token punctuation">)</span><span class="token punctuation">;</span>
				cur_State<span class="token operator">=</span>type_B<span class="token punctuation">;</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token keyword">case</span> type_B<span class="token operator">:</span>
				<span class="token function">process_package_state_B</span><span class="token punctuation">(</span>_pack<span class="token punctuation">)</span><span class="token punctuation">;</span>
				cur_State<span class="token operator">=</span>type_C<span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="有限状态机的实例：HTTP请求的读取和分析"><a href="#有限状态机的实例：HTTP请求的读取和分析" class="headerlink" title="有限状态机的实例：HTTP请求的读取和分析"></a>有限状态机的实例：HTTP请求的读取和分析</h2><p><strong>背景</strong></p>
<p>很多网络协议，包括TCP协议和IP协议，都在其头部中提供了头部长度字段，程序根据该字段的值就可以直到是否接收到一个完整的协议头部。但HTTP协议并未提供这样的头部长度字段，并且其头部长度变化很大，可以只有十几字节，也可以有上百字节。根据协议规定，我们判断HTTP头部借宿的依据是遇到一个空行，该空行仅包含一堆回车换行符（\<cr>\<lf>）。</lf></cr></p>
<hr>
<p><strong>代码</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token expression">＜sys<span class="token operator">/</span>socket<span class="token punctuation">.</span>h＞</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token expression">＜netinet<span class="token operator">/</span>in<span class="token punctuation">.</span>h＞</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token expression">＜arpa<span class="token operator">/</span>inet<span class="token punctuation">.</span>h＞</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token expression">＜assert<span class="token punctuation">.</span>h＞</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token expression">＜stdio<span class="token punctuation">.</span>h＞</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token expression">＜stdlib<span class="token punctuation">.</span>h＞</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token expression">＜unistd<span class="token punctuation">.</span>h＞</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token expression">＜errno<span class="token punctuation">.</span>h＞</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token expression">＜string<span class="token punctuation">.</span>h＞</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token expression">＜fcntl<span class="token punctuation">.</span>h＞</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BUFFER_SIZE</span> <span class="token expression"><span class="token number">4096</span></span><span class="token comment">//读缓冲区大小</span></span>

<span class="token comment">//主状态机的两种可能状态</span>
<span class="token keyword">enum</span> <span class="token class-name">CHECK_STATE</span><span class="token punctuation">{</span>
    CHECK_STATE_REQUESTLINE<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> 		<span class="token comment">//当前正在分析请求行</span>
    CHECK_STATE_HEADER				<span class="token comment">//当前正在分析头部字段</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//从状态机的三种可能状态</span>
<span class="token keyword">enum</span> <span class="token class-name">LINE_STATUS</span><span class="token punctuation">{</span>
    LINE_OK<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>						<span class="token comment">//读取到一个完整的行</span>
    LINE_BAD<span class="token punctuation">,</span>						<span class="token comment">//行出错</span>
    LINE_OPEN						<span class="token comment">//行数据尚且不完整</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//服务器处理HTTP请求的结果</span>
<span class="token keyword">enum</span> <span class="token class-name">HTTP_CODE</span><span class="token punctuation">{</span>
    NO_REQUEST<span class="token punctuation">,</span>						<span class="token comment">//请求不完整，需要继续读取客户数据</span>
    GET_REQUEST<span class="token punctuation">,</span>					<span class="token comment">//获得了一个完整的客户请求</span>
    BAD_REQUEST<span class="token punctuation">,</span>					<span class="token comment">//客户请求有语法错误</span>
	FORBIDDEN_REQUEST<span class="token punctuation">,</span>				<span class="token comment">//客户对资源没有足够的访问权限</span>
    INTERNAL_ERROR<span class="token punctuation">,</span>					<span class="token comment">//服务器内部错误</span>
    CLOSED_CONNECTION				<span class="token comment">//客户端已经关闭连接</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//为了简化问题，我们没有给客户端发送一个完整的HTTP应答报文，而只是根据服务器的处理结果发送如下成功或失败信息</span>
<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span>szret<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span>
    <span class="token string">"I get a correct result\n"</span><span class="token punctuation">,</span>
    <span class="token string">"Somethingwrong\n"</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//从状态机，用于解析出一行内容</span>
LINE_STATUS <span class="token function">parse_line</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> buffer<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> checked_index<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> read_index<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">char</span> temp<span class="token punctuation">;</span>
	<span class="token comment">//checked_index指向buffer（应用程序的读缓冲区）中当前正在分析的字节</span>
    <span class="token comment">//read_index指向buffer中客户数据的尾部的下一字节</span>
    <span class="token comment">//buffer中第0～checked_index字节都已分析完毕，第checked_index～(read_index-1)字节由下面的循环挨个分析</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span> checked_index<span class="token operator">&lt;</span>read_index<span class="token punctuation">;</span> <span class="token operator">++</span>checked_index<span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token comment">//获得当前要分析的字节</span>
		temp<span class="token operator">=</span>buffer<span class="token punctuation">[</span>checked_index<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token comment">//如果当前的字节是“\r”，即回车符，则说明可能读取到一个完整的行</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>temp<span class="token operator">==</span><span class="token char">'\r'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token comment">//如果“\r”字符碰巧是目前buffer中的最后一个已经被读入的客户数据，那么这次分析没有读取到一个完整的行，返回LINE_OPEN以表示还需要继续读取客户数据才能进一步分析</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>checked_index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">==</span>read_index<span class="token punctuation">)</span><span class="token punctuation">{</span>
				<span class="token keyword">return</span> LINE_OPEN<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token comment">//如果下一个字符是“\n”，则说明我们成功读取到一个完整的行</span>
			<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>buffer<span class="token punctuation">[</span>checked_index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
				buffer<span class="token punctuation">[</span>checked_index<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token char">'\0'</span><span class="token punctuation">;</span>
				buffer<span class="token punctuation">[</span>checked_index<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token char">'\0'</span><span class="token punctuation">;</span>
				<span class="token keyword">return</span> LINE_OK<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token comment">//否则的话，说明客户发送的HTTP请求存在语法问题</span>
			<span class="token keyword">return</span> LINE_BAD<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
		<span class="token comment">//如果当前的字节是“\n”，即换行符，则也说明可能读取到一个完整的行</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>temp<span class="token operator">==</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>checked_index＞<span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>buffer<span class="token punctuation">[</span>checked_index<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token char">'\r'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
				buffer<span class="token punctuation">[</span>checked_index<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token char">'\0'</span><span class="token punctuation">;</span>
				buffer<span class="token punctuation">[</span>checked_index<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token char">'\0'</span><span class="token punctuation">;</span>
				<span class="token keyword">return</span> LINE_OK<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
			<span class="token keyword">return</span> LINE_BAD<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
	<span class="token comment">//如果所有内容都分析完毕也没遇到“\r”字符，则返回LINE_OPEN，表示还需要继续读取客户数据才能进一步分析</span>
	<span class="token keyword">return</span> LINE_OPEN<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//分析请求行</span>
HTTP_CODE <span class="token function">parse_requestline</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> temp<span class="token punctuation">,</span> CHECK_STATE<span class="token operator">&amp;</span> checkstate<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">char</span><span class="token operator">*</span> url<span class="token operator">=</span><span class="token function">strpbrk</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span><span class="token string">"\t"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//strpbrk比较两个字符串是否有同样的字符，返回第一个temp相同的字符</span>
	<span class="token comment">//如果请求行中没有空白字符或“\t”字符，则HTTP请求必有问题</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>url<span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">return</span> BAD_REQUEST<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token operator">*</span>url<span class="token operator">++</span><span class="token operator">=</span><span class="token char">'\0'</span><span class="token punctuation">;</span>
	<span class="token keyword">char</span><span class="token operator">*</span> method<span class="token operator">=</span>temp<span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span><span class="token string">"GET"</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//strcasecmp判断两个字符串是否相等，忽略大小写</span>
        <span class="token comment">//仅支持GET方法</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The request method is GET\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
		<span class="token keyword">return</span> BAD_REQUEST<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	url<span class="token operator">+=</span><span class="token function">strspn</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span><span class="token string">"\t"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//strspn检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标</span>
	<span class="token keyword">char</span><span class="token operator">*</span> version<span class="token operator">=</span><span class="token function">strpbrk</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span><span class="token string">"\t"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>version<span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">return</span> BAD_REQUEST<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token operator">*</span>version<span class="token operator">++</span><span class="token operator">=</span><span class="token char">'\0'</span><span class="token punctuation">;</span>
	version<span class="token operator">+=</span><span class="token function">strspn</span><span class="token punctuation">(</span>version<span class="token punctuation">,</span><span class="token string">"\t"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//仅支持HTTP/1.1</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>version<span class="token punctuation">,</span><span class="token string">"HTTP/1.1"</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">return</span> BAD_REQUEST<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//检查URL是否合法</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strncasecmp</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span><span class="token string">"http://"</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		url<span class="token operator">+=</span><span class="token number">7</span><span class="token punctuation">;</span>
		url<span class="token operator">=</span><span class="token function">strchr</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span><span class="token char">'/'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//strchr查找字符串中的一个字符，并返回该字符在字符串中第一次出现的位置</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>url<span class="token operator">||</span>url<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">!=</span><span class="token char">'/'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">return</span> BAD_REQUEST<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The request URL is:%s\n"</span><span class="token punctuation">,</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//HTTP请求行处理完毕，状态转移到头部字段的分析</span>
	checkstate<span class="token operator">=</span>CHECK_STATE_HEADER<span class="token punctuation">;</span>
	<span class="token keyword">return</span> NO_REQUEST<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//分析头部字段</span>
HTTP_CODE <span class="token function">parse_headers</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span>temp<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token comment">//遇到一个空行，说明我们得到了一个正确的HTTP请求</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>temp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token char">'\0'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">return</span> GET_REQUEST<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strncasecmp</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span><span class="token string">"Host:"</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//处理“HOST”头部字段</span>
		temp<span class="token operator">+=</span><span class="token number">5</span><span class="token punctuation">;</span>
		temp<span class="token operator">+=</span><span class="token function">strspn</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span><span class="token string">"\t"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"the request host is:%s\n"</span><span class="token punctuation">,</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
        <span class="token comment">//其他头部字段都不处理</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I can not handle this header\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> NO_REQUEST<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//分析HTTP请求的入口函数</span>
HTTP_CODE <span class="token function">parse_content</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> buffer<span class="token punctuation">,</span><span class="token keyword">int</span> checked_index<span class="token punctuation">,</span>CHECK_STATE<span class="token operator">&amp;</span> checkstate<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">&amp;</span> read_index<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">&amp;</span> start_line<span class="token punctuation">)</span><span class="token punctuation">{</span>
	LINE_STATUS linestatus<span class="token operator">=</span>LINE_OK<span class="token punctuation">;</span><span class="token comment">//记录当前行的读取状态</span>
	HTTP_CODE retcode<span class="token operator">=</span>NO_REQUEST<span class="token punctuation">;</span><span class="token comment">//记录HTTP请求的处理结果</span>
	<span class="token comment">//主状态机，用于从buffer中取出所有完整的行</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>linestatus<span class="token operator">=</span><span class="token function">parse_line</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span>checked_index<span class="token punctuation">,</span>read_index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span>LINE_OK<span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">char</span><span class="token operator">*</span> temp<span class="token operator">=</span>buffer<span class="token operator">+</span>start_line<span class="token punctuation">;</span><span class="token comment">//start_line是行在buffer中的起始位置</span>
		start_line<span class="token operator">=</span>checked_index<span class="token punctuation">;</span><span class="token comment">//记录下一行的起始位置</span>
		<span class="token comment">//checkstate记录主状态机当前的状态</span>
		<span class="token keyword">switch</span><span class="token punctuation">(</span>checkstate<span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token keyword">case</span> CHECK_STATE_REQUESTLINE<span class="token operator">:</span><span class="token punctuation">{</span>
                <span class="token comment">//第一个状态，分析请求行</span>
                retcode<span class="token operator">=</span><span class="token function">parse_requestline</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span>checkstate<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span><span class="token punctuation">(</span>retcode<span class="token operator">==</span>BAD_REQUEST<span class="token punctuation">)</span><span class="token punctuation">{</span>
					<span class="token keyword">return</span> BAD_REQUEST<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
			<span class="token keyword">case</span> CHECK_STATE_HEADER<span class="token operator">:</span><span class="token punctuation">{</span>
                <span class="token comment">//第二个状态，分析头部字段</span>
				retcode<span class="token operator">=</span><span class="token function">parse_headers</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span><span class="token punctuation">(</span>retcode<span class="token operator">==</span>BAD_REQUEST<span class="token punctuation">)</span><span class="token punctuation">{</span>
					<span class="token keyword">return</span> BAD_REQUEST<span class="token punctuation">;</span>
				<span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>retcode<span class="token operator">==</span>GET_REQUEST<span class="token punctuation">)</span><span class="token punctuation">{</span>
					<span class="token keyword">return</span> GET_REQUEST<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">default</span><span class="token operator">:</span><span class="token punctuation">{</span>
				<span class="token keyword">return</span> INTERNAL_ERROR<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
	<span class="token comment">//若没有读取到一个完整的行，则表示还需要继续读取客户数据才能进一步分析</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>linestatus<span class="token operator">==</span>LINE_OPEN<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> NO_REQUEST<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
		<span class="token keyword">return</span> BAD_REQUEST<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span><span class="token keyword">char</span><span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>argc<span class="token operator">&lt;=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"usage:%s ip_address port_number\n"</span><span class="token punctuation">,</span><span class="token function">basename</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> ip<span class="token operator">=</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> port<span class="token operator">=</span><span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 	<span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> address<span class="token punctuation">;</span>
	<span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// void bzero(void *s, int n); 将内存块s前n个字节清空</span>
	address<span class="token punctuation">.</span>sin_family<span class="token operator">=</span>AF_INET<span class="token punctuation">;</span><span class="token comment">//设置TCP/IPv4协议族</span>
	<span class="token function">inet_pton</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span>ip<span class="token punctuation">,</span><span class="token operator">&amp;</span>address<span class="token punctuation">.</span>sin_addr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//转换ip地址</span>
	address<span class="token punctuation">.</span>sin_port<span class="token operator">=</span><span class="token function">htons</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//转换端口</span>
	<span class="token keyword">int</span> listenfd<span class="token operator">=</span><span class="token function">socket</span><span class="token punctuation">(</span>PF_INET<span class="token punctuation">,</span>SOCK_STREAM<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建socket，PF_INET表示IPv4，SOCK_STREAM表示流服务</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>listenfd<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> ret<span class="token operator">=</span><span class="token function">bind</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//绑定socket和地址</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>ret<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	ret<span class="token operator">=</span><span class="token function">listen</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//最多监听5个客户</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>ret<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> client_address<span class="token punctuation">;</span>
	<span class="token class-name">socklen_t</span> client_addrlength<span class="token operator">=</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>client_address<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> fd<span class="token operator">=</span><span class="token function">accept</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>client_address<span class="token punctuation">,</span><span class="token operator">&amp;</span>client_addrlength<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>fd<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"errno is:%d\n"</span><span class="token punctuation">,</span>errno<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
		<span class="token keyword">char</span> buffer<span class="token punctuation">[</span>BUFFER_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//读缓冲区</span>
		<span class="token function">memset</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span><span class="token char">'\0'</span><span class="token punctuation">,</span>BUFFER_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> data_read<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> read_index<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//当前已经读取了多少字节的客户数据</span>
		<span class="token keyword">int</span> checked_index<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//当前已经分析完了多少字节的客户数据</span>
		<span class="token keyword">int</span> start_line<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//行在buffer中的起始位置</span>
		<span class="token comment">//设置主状态机的初始状态</span>
		CHECK_STATE checkstate<span class="token operator">=</span>CHECK_STATE_REQUESTLINE<span class="token punctuation">;</span> <span class="token comment">//正在分析请求行</span>
		<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">//循环读取客户数据并分析之</span>
			data_read<span class="token operator">=</span><span class="token function">recv</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>buffer<span class="token operator">+</span>read_index<span class="token punctuation">,</span>BUFFER_SIZE<span class="token operator">-</span>read_index<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>data_read<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
				<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"reading failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>data_read<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
				<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"remote client has closed the connection\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
			read_index<span class="token operator">+=</span>data_read<span class="token punctuation">;</span>
			<span class="token comment">//分析目前已经获得的所有客户数据</span>
			HTTP_CODE result<span class="token operator">=</span><span class="token function">parse_content</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span>checked_index<span class="token punctuation">,</span>checkstate<span class="token punctuation">,</span>read_index<span class="token punctuation">,</span>start_line<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>result<span class="token operator">==</span>NO_REQUEST<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token comment">//尚未得到一个完整的HTTP请求</span>
				<span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>result<span class="token operator">==</span>GET_REQUEST<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token comment">//得到一个完整的、正确的HTTP请求</span>
				<span class="token function">send</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>szret<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span>szret<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
                <span class="token comment">//其他情况表示发生错误</span>
				<span class="token function">send</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>szret<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span>szret<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
		<span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">close</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//多看几遍，没有很难</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<p><strong>从状态机（parse_line)</strong></p>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/202401051820710.png" alt="image-20240105182051405"></p>
<ul>
<li>初始状态是LINE_OK</li>
</ul>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/202401051824382.png" alt="image-20240105182410984"></p>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/202401051824536.png" alt="image-20240105182424760"></p>
<hr>
<p><strong>主状态机</strong></p>
<ul>
<li>主状态机使用checkstate变量来记录当前的状态</li>
<li>如果当前的状态是CHECK_STATE_REQUESTLINE，则表示parse_line函数解析出的行是请求行，于是主状态机调用parse_requestline来分析请求行</li>
<li>如果当前的状态是CHECK_STATE_HEADER，则表示parse_line函数解析出的是头部字段，于是主状态机调用parse_headers来分析头部字段</li>
<li>checkstate变量的初始值是CHECK_STATE_REQUESTLINE，parse_requestline函数在成功地分析完请求行之后将其设置为CHECK_STATE_HEADER，从而实现状态转移</li>
</ul>
]]></content>
      <tags>
        <tag>C++ socket</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux高级I/O函数</title>
    <url>/2023/11/29/2-Linux%E9%AB%98%E7%BA%A7IO%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">    

<h2 id="用于创建文件描述符"><a href="#用于创建文件描述符" class="headerlink" title="用于创建文件描述符"></a>用于创建文件描述符</h2><h3 id="pipe函数"><a href="#pipe函数" class="headerlink" title="pipe函数"></a>pipe函数</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;unistd.h&gt;
int pipe(int fd[2]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>pipe函数用于创建一个单向管道，以实现进程间的通信</li>
<li>pipe函数的参数是一个包含两个int型整数的数组指针，该函数成功时返回0，并将一对打开的文件描述符值填入其参数指向的数组；如果失败，则返回-1并设置errno。</li>
</ul>
<span id="more"></span>
<hr>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;sys/types.h&gt;
#include&lt;sys/socket.h&gt;
int socketpair&lt;int domain, int type, int protocol, int fd[2]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li>socket基础API，能方便地创建双向管道</li>
<li>前三个参数与socket系统调用一致，但domain只能使用UNIX本地域协议族AF_UNIX，因此只能在本地使用这个双向管道</li>
<li>成功返回0，失败返回-1并设置errno。</li>
</ul>
<h3 id="dup函数和dup2函数"><a href="#dup函数和dup2函数" class="headerlink" title="dup函数和dup2函数"></a>dup函数和dup2函数</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;unistd.h&gt;
int dup(int file_descriptor);
int dup2(int file_descriptor_one, int file_descriptor_two);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li>dup函数创建一个新的文件描述符，该新文件描述符和原有原件描述符file_descriptor指向相同的文件、管道或者网络连接</li>
<li>dup总是返回系统当前可用的最小整数值</li>
<li>dup2和dup类似，不过返回的是第一个不小于file_descriptor_two的整数值</li>
<li>调用失败时返回-1并设置errno</li>
<li>通过dup/dup2函数创建的文件描述符并不继承原有文件描述符的属性</li>
</ul>
<h2 id="用于读写数据"><a href="#用于读写数据" class="headerlink" title="用于读写数据"></a>用于读写数据</h2><h3 id="readv函数和writev函数"><a href="#readv函数和writev函数" class="headerlink" title="readv函数和writev函数"></a>readv函数和writev函数</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;sys/uio.h&gt;
ssize_t readv(int fd, const struct iovec* vector, int count);
ssize_t writev(int fd, const struct iovec* vector, int count);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li>readv函数将数据从文件描述符读到分散的内存块中，即分散读</li>
<li>writev函数将多块分散的内存数据一并写入文件描述符中，即集中写</li>
<li>fd参数是被操作的文件描述符</li>
<li>vector是内存块数组</li>
<li>count是数组的长度</li>
</ul>
<h3 id="mmap函数和munmap函数"><a href="#mmap函数和munmap函数" class="headerlink" title="mmap函数和munmap函数"></a>mmap函数和munmap函数</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;sys/mman.h&gt;
void* mmap(void* start, size_t length, int port, int flags, int fd, off_t offset);
int munmap(void* start, size_t length);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li>mmap函数用于申请一段内存空间，成功时返回指向目标内存区域的指针，失败则返回MAP_FAILED((void*)-1)并设置errno</li>
<li>munmap函数则释放由mmap创建的这段内存空间，成功时返回0，失败时返回-1并设置errno</li>
<li>start参数允许用户使用某个特定的地址作为这段内存的起始地址，为null时系统自动分配一个地址</li>
<li>length指定内存段的长度</li>
<li>port用来设置内存段的访问权限<ul>
<li>PORT_READ，内存段可读</li>
<li>PORT_WRITE，内存段可写</li>
<li>PORT_EXEC，内存段可执行</li>
<li>PORT_NONE，内存段不能被访问</li>
</ul>
</li>
<li>flags参数控制内存段内容被修改后程序的行为<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202312282136663.png" alt="image-20231228213611717"></li>
</ul>
</li>
<li>fd参数是被映射文件的文件描述符</li>
<li>offset参数设置从文件的何处开始映射</li>
</ul>
<h3 id="splice函数"><a href="#splice函数" class="headerlink" title="splice函数"></a>splice函数</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;fcntl.h&gt;
ssize_t splice(int fd_in, loff_t* off_in, int fd_out, loff_t* off_out, size_t len, unsigned int flags);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>splice函数用于在两个文件描述符之间移动数据，也就是零拷贝操作，成功时返回移动字节的数量，失败时返回-1并设置errno<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202312282213040.png" alt="image-20231228221323161"></li>
</ul>
</li>
<li>fd_in参数是待输入数据的文件描述符</li>
<li>off_in<ul>
<li>如果fd_in是一个管道文件描述符，则off_in参数必须被设置为NULL</li>
<li>如果fd_in不是一个管道文件描述符，则off_in表示从输入数据流的何处开始读取数据，为NULL时则表示从输入数据流的当前偏移位置读入</li>
</ul>
</li>
<li>fd_out/off_out参数的含义与fd_in/fd_out相同，不过用于输出数据流</li>
<li>len参数指定移动数据的长度</li>
<li>flags参数则控制数据如何移动<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202312282210892.png" alt="image-20231228221039832"></li>
</ul>
</li>
<li>fd_in和fd_out必须至少有一个是管道文件描述符</li>
</ul>
<h3 id="tee函数"><a href="#tee函数" class="headerlink" title="tee函数"></a>tee函数</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;fcntl.h&gt;
ssize_t tee(int fd_in, int fd_out, size_t len, unsigned int flags);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>tee函数在两个管道文件描述符之间复制数据，也是零拷贝操作</li>
<li>各参数含义与splice函数一致</li>
<li>成功时返回在两个文件描述符之间复制的数据数量（字节数），失败时返回-1并设置errno</li>
</ul>
<h2 id="用于控制I-O行为和属性"><a href="#用于控制I-O行为和属性" class="headerlink" title="用于控制I/O行为和属性"></a>用于控制I/O行为和属性</h2><h3 id="fcntl函数"><a href="#fcntl函数" class="headerlink" title="fcntl函数"></a>fcntl函数</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;fcntl.h&gt;
int fcntl(int fd, int cmd, ...);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>fcntl函数提供了对文件描述符的各种控制操作</li>
<li>fd参数是被操作的文件描述符</li>
<li>cmd参数指定执行何种类型的操作，根据操作类型的不同，可能还需要第三个可选参数arg</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202312282356818.png" alt="image-20231228235648756"></li>
</ul>
]]></content>
      <tags>
        <tag>C++ socket</tag>
      </tags>
  </entry>
  <entry>
    <title>I/O复用</title>
    <url>/2023/11/29/5-IO%E5%A4%8D%E7%94%A8/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">    

<h1 id="I-O复用"><a href="#I-O复用" class="headerlink" title="I/O复用"></a>I/O复用</h1><p><strong>需要I/O复用技术的场景</strong></p>
<ul>
<li>客户端程序要同时处理多个socket</li>
<li>客户端程序要同时处理用户输入和网络连接</li>
<li>TCP服务器要同时处理监听socket和连接socket</li>
<li>服务器要同时处理TCP请求和UDP请求</li>
<li>服务器要同时监听多个端口</li>
</ul>
<span id="more"></span>
<hr>
<p>I/O复用虽然能同时监听多个文件描述符，但它本身是阻塞的，并且当多个文件描述符同时就绪时，如果不采用额外的措施，程序就只能按顺序依次处理其中的每一个文件描述符，这使得服务器程序看起来像是串行工作的，如果要实现并发，只能使用多进程或多线程等编程手段</p>
<h2 id="select系统调用"><a href="#select系统调用" class="headerlink" title="select系统调用"></a>select系统调用</h2><h3 id="select-API"><a href="#select-API" class="headerlink" title="select API"></a>select API</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/select.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token keyword">int</span> nfds<span class="token punctuation">,</span> fd_set<span class="token operator">*</span> readfds<span class="token punctuation">,</span> fd_set<span class="token operator">*</span> writefds<span class="token punctuation">,</span> fd_set8 exceptfds<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">timeval</span><span class="token operator">*</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li><p>nfds参数指定被监听的文件描述符的总数；通常设置为监听的所有文件描述符中的最大值加1</p>
</li>
<li><p>readfds、writefds和exceptfds参数分别指向可读、可写和异常等事件对应的文件描述符集合</p>
</li>
<li><p>fd_set</p>
<ul>
<li>```c<h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <typesizes.h></typesizes.h></h1><h1 id="define-FD-SETSIZE-1024"><a href="#define-FD-SETSIZE-1024" class="headerlink" title="define __FD_SETSIZE 1024"></a>define __FD_SETSIZE 1024</h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <sys></sys></h1><h1 id="define-FD-SETSIZE-FD-SETSIZE"><a href="#define-FD-SETSIZE-FD-SETSIZE" class="headerlink" title="define FD_SETSIZE__FD_SETSIZE"></a>define FD_SETSIZE__FD_SETSIZE</h1>typedef long int __fd_mask;<h1 id="undef-NFDBITS"><a href="#undef-NFDBITS" class="headerlink" title="undef __NFDBITS"></a>undef __NFDBITS</h1><h1 id="define-NFDBITS-8-int-sizeof-fd-mask"><a href="#define-NFDBITS-8-int-sizeof-fd-mask" class="headerlink" title="define NFDBITS(8*(int)sizeof(fd_mask))"></a>define <strong>NFDBITS(8*(int)sizeof(</strong>fd_mask))</h1>typedef struct{<pre><code>#ifdef __USE_XOPEN
__fd_mask fds_bits[__FD_SETSIZE/__NFDBITS];
#define __FDS_BITS(set)((set)-&gt;fds_bits)
#else
__fd_mask __fds_bits[__FD_SETSIZE/__NFDBITS];
#define __FDS_BITS(set)((set)-&gt;__fds_bits)
#endif
</code></pre>}fd_set;<pre class="line-numbers language-none"><code class="language-none">
- 该结构体包含一个整形数组，该数组的每个元素的每一位标记一个文件描述符，容纳的文件描述符数量由FD_SETSIZE指定

- ```c
  #include &lt;sys/select.h&gt;
  FD_ZERO(fd_set* fdset);					//清除fdset的所有位
  FD_SET(int fd, fd_set* fdset);			//设置fdset的位fd
  FD_CLR(int fd, fd_set* fdset);			//清除fdset的位fd
  int FD_ISSET(int fd, fd_set* fdset);	//测试fdset的位fd是否被设置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p>timeout参数用来设置select函数的超时时间，是一个timeval类型指针，内核将修改它以告诉应用程序select等待了多久</p>
<ul>
<li>```c<br>struct timeval{<pre><code>long tv_sec;    //秒数
long tv_usec;    //微秒数
</code></pre>}<pre class="line-numbers language-none"><code class="language-none">
  - 如果tv_sec和tv_usec都为0，select将立即返回

  - 如果给timeout传递NULL，select将一直阻塞，直到某个文件描述符就绪

- select成功时返回就绪（可读、可写和异常）文件描述符的总数，如果在超时时间内没有任何文件描述符就绪，返回0

- select失败时返回-1并设置errno，如果在select等待期间，程序接收到信号，select立即返回-1，并设置erno为EINTR

### 文件描述符就绪条件

**socket可读**

- socket内核接收缓存区中的字节数大于或等于其低水位标记SO_RCVLOWAT，此时可以无阻塞地读该socket，并且读操作返回地字节数大于0
- socket通信的对方关闭连接，此时对socket的读操作将返回0
- 监听socket上有新的连接请求
- socket上有未处理的错误，此时可以使用getsockopt来读取和清除该错误

**socket可写**

- socket内核发送缓存区中的可用字节数大于或等于其低水位标记SO_SNDLOWAT，此时可以无阻塞地写该socket，并且写操作返回地字节数大于0
- socket的写操作被关闭，对写操作被关闭的socket执行写操作将触发一个SIGPIPE信号
- socket使用非阻塞connect连接成功或者失败（超时）之后
- socket上有未处理的错误，此时可以使用getsockopt来读取和清除该错误

**socket异常**

- socket接收到带外数据

### 处理带外数据（select示例）

**同时接收普通数据和带外数据**

```c
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc,char*argv[]){
	if(argc&lt;=2){
		printf("usage:%s ip_address port_number\n",basename(argv[0]));
        return 1;
	}
	const char* ip=argv[1];
	int port=atoi(argv[2]);
	int ret=0;
	struct sockaddr_in address;
	bzero(&amp;address,sizeof(address));
	address.sin_family=AF_INET;
	inet_pton(AF_INET,ip,&amp;address.sin_addr);
	address.sin_port=htons(port);
	int listenfd=socket(PF_INET,SOCK_STREAM,0);
	assert(listenfd&gt;=0);
	ret=bind(listenfd,(struct sockaddr*)&amp;address,sizeof(address));
	assert(ret!=-1);
	ret=listen(listenfd,5);
	assert(ret!=-1);
	struct sockaddr_in client_address;
	socklen_t client_addrlength=sizeof(client_address);
	int connfd=accept(listenfd,(struct sockaddr*)&amp;client_address,&amp;client_addrlength);
	if(connfd&lt;0){
		printf("errno is:%d\n",errno);
		close(listenfd);
	}
    //------------------------------------------------------------上面是常规流程
	char buf[1024];
	fd_set read_fds;
	fd_set exception_fds;
	FD_ZERO(&amp;read_fds); //清除fdset的所有位
	FD_ZERO(&amp;exception_fds);
	while(1){
		memset(buf,'\0',sizeof(buf));
		//每次调用select前都要重新在read_fds和exception_fds中设置文件描述符connfd，因为事件发生之后，文件描述符集合将被内核修改
		FD_SET(connfd,&amp;read_fds);
		FD_SET(connfd,&amp;exception_fds);
		ret=select(connfd+1,&amp;read_fds,NULL,&amp;exception_fds,NULL);
		if(ret&lt;0){
			printf("selection failure\n");
			break;
		}
        //对于可读事件，采用普通的recv函数读取数据
        if(FD_ISSET(connfd,&amp;read_fds)){
            ret=recv(connfd,buf,sizeof(buf)-1,0);
            if(ret&lt;=0){
                break;
            }
            printf("get%d bytes of normal data:%s\n",ret,buf);
        }
        //对于异常事件，采用带MSG_OOB标志的recv函数读取带外数据/
        else if(FD_ISSET(connfd,&amp;exception_fds)){
            ret=recv(connfd,buf,sizeof(buf)-1,MSG_OOB);
            if(ret&lt;=0){
                break;
            }
            printf("get%d bytes of oob data:%s\n",ret,buf);
        }
    }
	close(connfd);
	close(listenfd);
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="poll系统调用"><a href="#poll系统调用" class="headerlink" title="poll系统调用"></a>poll系统调用</h2><p>与select类似，在指定时间内轮询一定数量的文件描述符</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;poll.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pollfd</span><span class="token operator">*</span> fds<span class="token punctuation">,</span> <span class="token class-name">nfds_t</span> nfds<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li><p>fds参数是一个pollfd结构类型的数组，指定所有我们感兴趣的文件描述符上发生的可读，可写和异常等事件</p>
<ul>
<li>```c<br>struct pollfd{<pre><code>int fd;            //文件描述符
short events;    //注册的事件
short revents;    //实际发生的事件，由内核填充
</code></pre>};<pre class="line-numbers language-none"><code class="language-none">
  - ![image-20240106181927640](https://gitee.com/renmale-sztu/image/raw/master/202401061821925.png)

  - ![image-20240106182006827](https://gitee.com/renmale-sztu/image/raw/master/202401061820310.png)

- nfds参数指定被监听事件集合fds的大小

  - ```c
    typedef unsigned long int nfds_t;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p>timeout参数指定poll的超时值，单位是毫秒</p>
<ul>
<li>为-1时，poll调用将永远阻塞，直到某个事件发生</li>
<li>为0时，poll调用将立即返回</li>
</ul>
</li>
<li><p>返回值含义与select相同</p>
</li>
</ul>
<h2 id="epoll系统调用"><a href="#epoll系统调用" class="headerlink" title="epoll系统调用"></a>epoll系统调用</h2><ul>
<li>Linux特有的I/O函数，与select和poll有较大差异</li>
<li>使用一组函数来完成任务</li>
</ul>
<h3 id="内核事件表"><a href="#内核事件表" class="headerlink" title="内核事件表"></a>内核事件表</h3><ul>
<li>epoll把用户关心的文件描述符上的事件放在内核里的一个事件表中，从而无须像select和poll那样每次调用都需要重复传入文件描述符集或事件集</li>
<li>epoll需要使用一个额外的文件描述符来唯一标识内核中的这个事件表</li>
</ul>
<hr>
<p><strong>创建</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/epoll.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>size参数不起作用，只是给内核一个提示，告诉它事件表需要多大</li>
<li>该函数返回的文件描述符将用作其他所有epoll系统调用的第一个参数，以指定要访问的内核事件表</li>
</ul>
<p><strong>操作</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/epoll.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">epoll_ctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">int</span> op<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span><span class="token operator">*</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li><p>fd参数是要操作的文件描述符</p>
</li>
<li><p>op参数指定操作类型</p>
<ul>
<li>| 操作类型      | 含义                     |<br>| ——————- | ———————————— |<br>| EPOLL_CTL_ADD | 往事件表中注册fd上的事件 |<br>| EPOLL_CTL_MOD | 修改fd上的注册事件       |<br>| EPOLL_CTL_DEL | 删除fd上的注册事件       |</li>
</ul>
</li>
<li><p>event参数指定事件，是epoll_event结构指针类型</p>
<ul>
<li><p>```c<br>struct epoll_event{</p>
<pre><code>__uint32_t events;     //epoll事件
epoll_data_t data     //用户数据
</code></pre><p>};</p>
<pre class="line-numbers language-none"><code class="language-none">
- events成员描述事件类型，和poll基本相同，表示epoll事件类型的宏是在poll对应的宏前加上E

  - epoll有两个额外事件类型——EPOLLET和EPOLLONESHOT

- data成员用于存储用户数据

  - ```c
    typedef union epoll_data{
    	void* ptr;
    	int fd;
    	uint32_t u32;
    	uint64_t u64;
    }epoll_data_t;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>fd指定事件所从属的目标文件描述符</p>
</li>
<li><p>ptr成员可用来指定与fd相关的用户数据</p>
</li>
<li><p>是一个联合体，不能同时使用其ptr成员和fd成员</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>成功时返回0，失败时返回-1并设置errno</p>
</li>
</ul>
<h3 id="epoll-wait函数"><a href="#epoll-wait函数" class="headerlink" title="epoll_wait函数"></a>epoll_wait函数</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//在一段超时时间内等待一组文件描述符上的事件</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/epoll.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span><span class="token operator">*</span> events<span class="token punctuation">,</span> <span class="token keyword">int</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li>成功时返回就绪的文件描述符的个数，失败时返回-1并设置errno</li>
<li>timeout参数的含义与poll接口的timeout参数相同</li>
<li>maxevents参数指定最多监听多少个事件，它必须大于0</li>
<li>如果检测到事件，就将所有就绪的事件从内核事件表中复制到它的第二个参数events指向的数组中，这个数组只用于输出epoll_wait检测到的就绪事件，而不像select和poll的数组参数那样既用于传入用户注册的事件，有用于输出内核检测到的就绪事件，极大提高了效率</li>
</ul>
<hr>
<p><strong>poll和epoll在使用上的差别</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//如何索引poll返回的就绪文件描述符</span>
<span class="token keyword">int</span> ret<span class="token operator">=</span><span class="token function">poll</span><span class="token punctuation">(</span>fds<span class="token punctuation">,</span>MAX_EVENT_NUMBER<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//必须遍历所有已注册文件描述符并找到其中的就绪者（当然，可以利用ret来稍做优化）</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>MAX_EVENT_NUMBER<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//判断第i个文件描述符是否就绪</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>revents<span class="token operator">&amp;</span>POLLIN<span class="token punctuation">)</span><span class="token punctuation">{</span>       
		<span class="token comment">//处理sockfd</span>
        <span class="token keyword">int</span> sockfd<span class="token operator">=</span>fds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>fd<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//---------------------------------------------------------------------</span>
<span class="token comment">//如何索引epoll返回的就绪文件描述符</span>
<span class="token keyword">int</span> ret<span class="token operator">=</span><span class="token function">epoll_wait</span><span class="token punctuation">(</span>epollfd<span class="token punctuation">,</span>events<span class="token punctuation">,</span>MAX_EVENT_NUMBER<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//仅遍历就绪的ret个文件描述符</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>ret<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//sockfd肯定就绪，直接处理</span>
	<span class="token keyword">int</span> sockfd<span class="token operator">=</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="LT和ET模式"><a href="#LT和ET模式" class="headerlink" title="LT和ET模式"></a>LT和ET模式</h3><p><strong>epoll对文件描述符的操作的两种模式</strong></p>
<ul>
<li>LT模式（电平触发模式）<ul>
<li>默认工作模式，相当于一个效率较高的poll</li>
<li>当epoll_wait检测到其上有事件通知应用程序后，应用程序可以不立即处理该事件；这样，当应用程序下一次调用epoll_wait时，epoll_wait还会再次向应用程序通知此事件，直到事件被处理</li>
</ul>
</li>
<li>ET模式（边沿触发模式）<ul>
<li>epoll的高效工作模式，需要往epoll内核事件表中注册一个文件描述符上的EPOLLET事件</li>
<li>当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，应用程序必须立即处理该事件，因为后序的epoll_wait调用不会再像应用程序通知这一事件</li>
<li>很大程度上降低了同一个epoll事件被重复触发的次数</li>
</ul>
</li>
</ul>
<hr>
<p><strong>比较</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netinet/in.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;errno.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/epoll.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_EVENT_NUMBER</span> <span class="token expression"><span class="token number">1024</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BUFFER_SIZE</span> <span class="token expression"><span class="token number">10</span></span></span>

<span class="token comment">//将文件描述符设置成非阻塞的</span>
<span class="token keyword">int</span> <span class="token function">setnonblocking</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> old_option<span class="token operator">=</span><span class="token function">fcntl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>F_GETFL<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> new_option<span class="token operator">=</span>old_option<span class="token operator">|</span>O_NONBLOCK<span class="token punctuation">;</span>
	<span class="token function">fcntl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>F_SETFL<span class="token punctuation">,</span>new_option<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> old_option<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//将文件描述符fd上的EPOLLIN注册到epollfd指示的epoll内核事件表中，参数enable_et指定是否对fd启用ET模式</span>
<span class="token keyword">void</span> <span class="token function">addfd</span><span class="token punctuation">(</span><span class="token keyword">int</span> epollfd<span class="token punctuation">,</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span>bool enable_et<span class="token punctuation">)</span><span class="token punctuation">{</span>
	epoll_event event<span class="token punctuation">;</span>
	event<span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd<span class="token operator">=</span>fd<span class="token punctuation">;</span>
	event<span class="token punctuation">.</span>events<span class="token operator">=</span>EPOLLIN<span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>enable_et<span class="token punctuation">)</span>
		event<span class="token punctuation">.</span>events<span class="token operator">|=</span>EPOLLET<span class="token punctuation">;</span>
	<span class="token function">epoll_ctl</span><span class="token punctuation">(</span>epollfd<span class="token punctuation">,</span>EPOLL_CTL_ADD<span class="token punctuation">,</span>fd<span class="token punctuation">,</span><span class="token operator">&amp;</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">setnonblocking</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//LT模式的工作流程</span>
<span class="token keyword">void</span> <span class="token function">lt</span><span class="token punctuation">(</span>epoll_event<span class="token operator">*</span>events<span class="token punctuation">,</span><span class="token keyword">int</span> number<span class="token punctuation">,</span><span class="token keyword">int</span> epollfd<span class="token punctuation">,</span><span class="token keyword">int</span> listenfd<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">char</span> buf<span class="token punctuation">[</span>BUFFER_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>number<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">int</span> sockfd<span class="token operator">=</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>sockfd<span class="token operator">==</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> client_address<span class="token punctuation">;</span>
            <span class="token class-name">socklen_t</span> client_addrlength<span class="token operator">=</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>client_address<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> connfd<span class="token operator">=</span><span class="token function">accept</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>client_address<span class="token punctuation">,</span><span class="token operator">&amp;</span>client_addrlength<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">addfd</span><span class="token punctuation">(</span>epollfd<span class="token punctuation">,</span>connfd<span class="token punctuation">,</span>false<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//对connfd禁用ET模式</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events<span class="token operator">&amp;</span>EPOLLIN<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">//只要socket读缓存中还有未读出的数据，这段代码就被触发</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"event trigger once\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">memset</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span><span class="token char">'\0'</span><span class="token punctuation">,</span>BUFFER_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> ret<span class="token operator">=</span><span class="token function">recv</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span>buf<span class="token punctuation">,</span>BUFFER_SIZE<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token function">close</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"get%d bytes of content:%s\n"</span><span class="token punctuation">,</span>ret<span class="token punctuation">,</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"something else happened\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">//ET模式的工作流程</span>
<span class="token keyword">void</span> <span class="token function">et</span><span class="token punctuation">(</span>epoll_event<span class="token operator">*</span>events<span class="token punctuation">,</span><span class="token keyword">int</span> number<span class="token punctuation">,</span><span class="token keyword">int</span> epollfd<span class="token punctuation">,</span><span class="token keyword">int</span> listenfd<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">char</span> buf<span class="token punctuation">[</span>BUFFER_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>number<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">int</span> sockfd<span class="token operator">=</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd<span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>sockfd<span class="token operator">==</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> client_address<span class="token punctuation">;</span>
			<span class="token class-name">socklen_t</span> client_addrlength<span class="token operator">=</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>client_address<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">int</span> connfd<span class="token operator">=</span><span class="token function">accept</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>client_address<span class="token punctuation">,</span><span class="token operator">&amp;</span>client_addrlength<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">addfd</span><span class="token punctuation">(</span>epollfd<span class="token punctuation">,</span>connfd<span class="token punctuation">,</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//对connfd开启ET模式</span>
		<span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events<span class="token operator">&amp;</span> EPOLLIN<span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token comment">//这段代码不会被重复触发，所以我们循环读取数据，以确保把socket读缓存中的所有数据读出</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"event trigger once\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
				<span class="token function">memset</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span><span class="token char">'\0'</span><span class="token punctuation">,</span>BUFFER_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">int</span> ret<span class="token operator">=</span><span class="token function">recv</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span>buf<span class="token punctuation">,</span>BUFFER_SIZE<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
					<span class="token comment">//对于非阻塞IO，下面的条件成立表示数据已经全部读取完毕。此后，epoll就能再次触发sockfd上的EPOLLIN事件，以驱动下一次读操作</span>
					<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>errno<span class="token operator">==</span>EAGAIN<span class="token punctuation">)</span><span class="token operator">||</span><span class="token punctuation">(</span>errno<span class="token operator">==</span>EWOULDBLOCK<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
						<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"read later\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
					<span class="token function">close</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token keyword">break</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
					<span class="token function">close</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
					<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"get%d bytes of content:%s\n"</span><span class="token punctuation">,</span>ret<span class="token punctuation">,</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"something else happened\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span><span class="token keyword">char</span><span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>argc<span class="token operator">&lt;=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"usage:%s ip_address port_number\n"</span><span class="token punctuation">,</span><span class="token function">basename</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> ip<span class="token operator">=</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> port<span class="token operator">=</span><span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 	<span class="token keyword">int</span> ret<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> address<span class="token punctuation">;</span>
	<span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	address<span class="token punctuation">.</span>sin_family<span class="token operator">=</span>AF_INET<span class="token punctuation">;</span>
	<span class="token function">inet_pton</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span>ip<span class="token punctuation">,</span><span class="token operator">&amp;</span>address<span class="token punctuation">.</span>sin_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	address<span class="token punctuation">.</span>sin_port<span class="token operator">=</span><span class="token function">htons</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> listenfd<span class="token operator">=</span><span class="token function">socket</span><span class="token punctuation">(</span>PF_INET<span class="token punctuation">,</span>SOCK_STREAM<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>listenfd<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	ret<span class="token operator">=</span><span class="token function">bind</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>ret<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	ret<span class="token operator">=</span><span class="token function">listen</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>ret<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	epoll_event events<span class="token punctuation">[</span>MAX_EVENT_NUMBER<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> epollfd<span class="token operator">=</span><span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>epollfd<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">addfd</span><span class="token punctuation">(</span>epollfd<span class="token punctuation">,</span>listenfd<span class="token punctuation">,</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">int</span> ret<span class="token operator">=</span><span class="token function">epoll_wait</span><span class="token punctuation">(</span>epollfd<span class="token punctuation">,</span>events<span class="token punctuation">,</span>MAX_EVENT_NUMBER<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"epoll failure\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
        <span class="token function">lt</span><span class="token punctuation">(</span>events<span class="token punctuation">,</span>ret<span class="token punctuation">,</span>epollfd<span class="token punctuation">,</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用LT模式</span>
        <span class="token comment">//et(events,ret,epollfd,listenfd);//使用ET模式</span>
	<span class="token punctuation">}</span>
	<span class="token function">close</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>LT结果</strong></p>
<ul>
<li><p><img src="https://gitee.com/renmale-sztu/image/raw/master/202401071613253.png" alt="image-20240107161354990"></p>
</li>
<li><p><img src="https://gitee.com/renmale-sztu/image/raw/master/202401071613378.png" alt="image-20240107161314101"></p>
</li>
</ul>
<p><strong>ET结果</strong></p>
<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202401071621370.png" alt="image-20240107162145401"></li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202401071622783.png" alt="image-20240107162212882"></li>
</ul>
<hr>
<p>易见ET模式下事件被触发的次数要比LT模式下少很多</p>
<h3 id="EPOLLONESHOT事件"><a href="#EPOLLONESHOT事件" class="headerlink" title="EPOLLONESHOT事件"></a>EPOLLONESHOT事件</h3><p><strong>应用场景</strong></p>
<ul>
<li>即使使用ET模式，socket上的某个事件可能被触发多次，这在并发程序中会引发问题</li>
<li>一个线程在读取完某个socket上的数据后开始处理这些数据，而在数据的处理过程中该socket上又有新数据可读（EPOLLIN再次被触发），此时另一个线程被唤醒来读取这些新的数据，此时就出现了两个线程同时操作一个socket</li>
<li>EPOLLONESHOT事件被用来实现一个socket连接在任一时刻都只被一个线程处理</li>
</ul>
<p><strong>使用</strong></p>
<ul>
<li>对于注册了EPOLLONESHOT事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或异常事件，且只触发一次</li>
<li>当一个线程在处理某个socket时，其他线程是不可能有机会操作该socket的</li>
<li>注册了EPOLLONESHOT事件的socket一旦被某个线程处理完毕，该线程就应该立即重置这个socket上的EPOLLONESHOT事件，以确保这个socket下一次可读时，其EPOLLIN事件能被触发</li>
</ul>
<hr>
<p><strong>示例</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netinet/in.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;errno.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/epoll.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_EVENT_NUMBER</span> <span class="token expression"><span class="token number">1024</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BUFFER_SIZE</span> <span class="token expression"><span class="token number">1024</span></span></span>

<span class="token keyword">struct</span> <span class="token class-name">fds</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> epollfd<span class="token punctuation">;</span>
	<span class="token keyword">int</span> sockfd<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">setnonblocking</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> old_option<span class="token operator">=</span><span class="token function">fcntl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>F_GETFL<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> new_option<span class="token operator">=</span>old_option<span class="token operator">|</span>O_NONBLOCK<span class="token punctuation">;</span>
	<span class="token function">fcntl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>F_SETFL<span class="token punctuation">,</span>new_option<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> old_option<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//将fd上的EPOLLIN和EPOLLET事件注册到epollfd指示的epoll内核事件表中，参数oneshot指定是否注册fd上的EPOLLONESHOT事件</span>
<span class="token keyword">void</span> <span class="token function">addfd</span><span class="token punctuation">(</span><span class="token keyword">int</span> epollfd<span class="token punctuation">,</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span>bool oneshot<span class="token punctuation">)</span><span class="token punctuation">{</span>
	epoll_event event<span class="token punctuation">;</span>
	event<span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd<span class="token operator">=</span>fd<span class="token punctuation">;</span>
	event<span class="token punctuation">.</span>events<span class="token operator">=</span>EPOLLIN<span class="token operator">|</span>EPOLLET<span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>oneshot<span class="token punctuation">)</span><span class="token punctuation">{</span>
		event<span class="token punctuation">.</span>events<span class="token operator">|=</span>EPOLLONESHOT<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">epoll_ctl</span><span class="token punctuation">(</span>epollfd<span class="token punctuation">,</span>EPOLL_CTL_ADD<span class="token punctuation">,</span>fd<span class="token punctuation">,</span><span class="token operator">&amp;</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">setnonblocking</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//重置fd上的事件。这样操作之后，尽管fd上的EPOLLONESHOT事件被注册，但是操作系统仍然会触发fd上的EPOLLIN事件，且只触发一次</span>
<span class="token keyword">void</span> <span class="token function">reset_oneshot</span><span class="token punctuation">(</span><span class="token keyword">int</span> epollfd<span class="token punctuation">,</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">{</span>
	epoll_event event<span class="token punctuation">;</span>
	event<span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd<span class="token operator">=</span>fd<span class="token punctuation">;</span>
	event<span class="token punctuation">.</span>events<span class="token operator">=</span>EPOLLIN<span class="token operator">|</span>EPOLLET<span class="token operator">|</span>EPOLLONESHOT<span class="token punctuation">;</span>
	<span class="token function">epoll_ctl</span><span class="token punctuation">(</span>epollfd<span class="token punctuation">,</span>EPOLL_CTL_MOD<span class="token punctuation">,</span>fd<span class="token punctuation">,</span><span class="token operator">&amp;</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//工作线程</span>
<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">worker</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> sockfd<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">(</span>fds<span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">)</span><span class="token operator">-&gt;</span>sockfd<span class="token punctuation">;</span>
	<span class="token keyword">int</span> epollfd<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">(</span>fds<span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">)</span><span class="token operator">-&gt;</span>epollfd<span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"start new thread to receive data on fd:%d\n"</span><span class="token punctuation">,</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">char</span> buf<span class="token punctuation">[</span>BUFFER_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token function">memset</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span><span class="token char">'\0'</span><span class="token punctuation">,</span>BUFFER_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//循环读取sockfd上的数据，直到遇到EAGAIN错误</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">int</span> ret<span class="token operator">=</span><span class="token function">recv</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span>buf<span class="token punctuation">,</span>BUFFER_SIZE<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token function">close</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"foreiner closed the connection\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>errno<span class="token operator">==</span>EAGAIN<span class="token punctuation">)</span><span class="token punctuation">{</span>
				<span class="token function">reset_oneshot</span><span class="token punctuation">(</span>epollfd<span class="token punctuation">,</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"read later\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"get content:%s\n"</span><span class="token punctuation">,</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">//休眠5s，模拟数据处理过程</span>
			<span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"end thread receiving data on fd:%d\n"</span><span class="token punctuation">,</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span><span class="token keyword">char</span><span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>argc<span class="token operator">&lt;=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"usage:%s ip_address port_number\n"</span><span class="token punctuation">,</span><span class="token function">basename</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> ip<span class="token operator">=</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> port<span class="token operator">=</span><span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> ret<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> address<span class="token punctuation">;</span>
	<span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	address<span class="token punctuation">.</span>sin_family<span class="token operator">=</span>AF_INET<span class="token punctuation">;</span>
	<span class="token function">inet_pton</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span>ip<span class="token punctuation">,</span><span class="token operator">&amp;</span>address<span class="token punctuation">.</span>sin_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	address<span class="token punctuation">.</span>sin_port<span class="token operator">=</span><span class="token function">htons</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> listenfd<span class="token operator">=</span><span class="token function">socket</span><span class="token punctuation">(</span>PF_INET<span class="token punctuation">,</span>SOCK_STREAM<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>listenfd<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	ret<span class="token operator">=</span><span class="token function">bind</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>ret<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	ret<span class="token operator">=</span><span class="token function">listen</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>ret<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	epoll_event events<span class="token punctuation">[</span>MAX_EVENT_NUMBER<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> epollfd<span class="token operator">=</span><span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>epollfd<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//注意，监听socket listenfd上是不能注册EPOLLONESHOT事件的，否则应用程序只能处理一个客户连接！因为后续的客户连接请求将不再触发listenfd上的EPOLLIN事件</span>
	<span class="token function">addfd</span><span class="token punctuation">(</span>epollfd<span class="token punctuation">,</span>listenfd<span class="token punctuation">,</span>false<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">int</span> ret<span class="token operator">=</span><span class="token function">epoll_wait</span><span class="token punctuation">(</span>epollfd<span class="token punctuation">,</span>events<span class="token punctuation">,</span>MAX_EVENT_NUMBER<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"epoll failure\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>ret<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token keyword">int</span> sockfd<span class="token operator">=</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd<span class="token punctuation">;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>sockfd<span class="token operator">==</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">{</span>
				<span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> client_address<span class="token punctuation">;</span>
				<span class="token class-name">socklen_t</span> client_addrlength<span class="token operator">=</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>client_address<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">int</span> connfd<span class="token operator">=</span><span class="token function">accept</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>client_address<span class="token punctuation">,</span><span class="token operator">&amp;</span>client_addrlength<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token comment">//对每个非监听文件描述符都注册EPOLLONESHOT事件</span>
				<span class="token function">addfd</span><span class="token punctuation">(</span>epollfd<span class="token punctuation">,</span>connfd<span class="token punctuation">,</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events<span class="token operator">&amp;</span>EPOLLIN<span class="token punctuation">)</span><span class="token punctuation">{</span>
				<span class="token class-name">pthread_t</span> thread<span class="token punctuation">;</span>
				fds fds_for_new_worker<span class="token punctuation">;</span>
				fds_for_new_worker<span class="token punctuation">.</span>epollfd<span class="token operator">=</span>epollfd<span class="token punctuation">;</span>
				fds_for_new_worker<span class="token punctuation">.</span>sockfd<span class="token operator">=</span>sockfd<span class="token punctuation">;</span>
				<span class="token comment">//新启动一个工作线程为sockfd服务</span>
				<span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span>worker<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>fds_for_new_worker<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
				<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"something else happened\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
	<span class="token function">close</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>从工作线程函数worker来看，如果一个工作线程处理完某个socket上的一个请求（休眠5s模拟过程）之后，又接收到该socket上新的客户请求，则该线程将继续为这个socket服务；并且因为该socket上注册了EPOLLONESHOT事件，其他线程没有机会接触这个socket，如果工作线程等待5s后仍然没收到该socket上的下一批客户数据，则它将放弃该socket服务</li>
</ul>
<h2 id="三组I-O复用函数的比较"><a href="#三组I-O复用函数的比较" class="headerlink" title="三组I/O复用函数的比较"></a>三组I/O复用函数的比较</h2><p><img src="https://gitee.com/renmale-sztu/image/raw/master/202401071756433.png" alt="image-20240107175603729"></p>
]]></content>
      <tags>
        <tag>C++ socket</tag>
      </tags>
  </entry>
  <entry>
    <title>I/O复用高级应用</title>
    <url>/2023/11/29/6-IO%E5%A4%8D%E7%94%A8%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">    



<h2 id="非阻塞connect"><a href="#非阻塞connect" class="headerlink" title="非阻塞connect"></a>非阻塞connect</h2><p><strong>EINPROGRESS错误</strong></p>
<pre class="line-numbers language-none"><code class="language-none">The socket is nonblocking and the connection cannot be completed immediately.It is possible to select(2)or poll(2)for completion by selecting the socket for writing.After select(2)indicates writability,use getsockopt(2)to read the SO_ERROR option at level SOL_SOCKET to determine whether connect()completed successfully(SO_ERROR is zero)or unsuccessfully(SO_ERROR is one of the usual error codes listed here,explaining the reason for the failure).<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li>这种错误发生在对非阻塞的socket调用connect，而连接又没有立即建立时</li>
<li>在这种情况下，我们可以调用select、poll等函数来监听这个连接失败的socket上的可写事件，等select、poll等函数返回后，再利用getsockopt来读取错误码并清除该socket上的错误；如果错误码是0，表示连接建立成功，否则连接失败</li>
<li>通过这种方式，我们能够同时发起多个连接并一起等待</li>
</ul>
<span id="more"></span>
<hr>
<p><strong>代码实现</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netinet/in.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;time.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;errno.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/ioctl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BUFFER_SIZE</span> <span class="token expression"><span class="token number">1023</span></span></span>

<span class="token keyword">int</span> <span class="token function">setnonblocking</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> old_option<span class="token operator">=</span><span class="token function">fcntl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>F_GETFL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> new_option<span class="token operator">=</span>old_option<span class="token operator">|</span>O_NONBLOCK<span class="token punctuation">;</span>
    <span class="token function">fcntl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>F_SETFL<span class="token punctuation">,</span>new_option<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> old_option<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//超时连接函数，参数分别是服务器IP地址、端口号和超时时间（毫秒）。函数成功时返回已经处于连接状态的socket，失败则返回-1</span>
<span class="token keyword">int</span> <span class="token function">unblock_connect</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> ip<span class="token punctuation">,</span><span class="token keyword">int</span> port<span class="token punctuation">,</span><span class="token keyword">int</span> time<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> ret<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> address<span class="token punctuation">;</span>
	<span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	address<span class="token punctuation">.</span>sin_family<span class="token operator">=</span>AF_INET<span class="token punctuation">;</span>
	<span class="token function">inet_pton</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span>ip<span class="token punctuation">,</span><span class="token operator">&amp;</span>address<span class="token punctuation">.</span>sin_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	address<span class="token punctuation">.</span>sin_port<span class="token operator">=</span><span class="token function">htons</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> sockfd<span class="token operator">=</span><span class="token function">socket</span><span class="token punctuation">(</span>PF_INET<span class="token punctuation">,</span>SOCK_STREAM<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> fdopt<span class="token operator">=</span><span class="token function">setnonblocking</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
	ret<span class="token operator">=</span><span class="token function">connect</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token comment">//如果连接成功，则恢复sockfd的属性，并立即返回之</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"connect with server immediately\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">fcntl</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span>F_SETFL<span class="token punctuation">,</span>fdopt<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> sockfd<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>errno<span class="token operator">!=</span>EINPROGRESS<span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token comment">//如果连接没有立即建立，那么只有当errno是EINPROGRESS时才表示连接还在进行，否则出错返回</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"unblock connect not support\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
    fd_set readfds<span class="token punctuation">;</span>
	fd_set writefds<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">timeval</span> timeout<span class="token punctuation">;</span>
	<span class="token function">FD_ZERO</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>readfds<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">FD_SET</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span><span class="token operator">&amp;</span>writefds<span class="token punctuation">)</span><span class="token punctuation">;</span>
	timeout<span class="token punctuation">.</span>tv_sec<span class="token operator">=</span>time<span class="token punctuation">;</span>
	timeout<span class="token punctuation">.</span>tv_usec<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
	ret<span class="token operator">=</span><span class="token function">select</span><span class="token punctuation">(</span>sockfd<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>writefds<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token comment">//select超时或者出错，立即返回</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"connection time out\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">close</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">FD_ISSET</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span><span class="token operator">&amp;</span>writefds<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"no events on sockfd found\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">close</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">int</span> error<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token class-name">socklen_t</span> length<span class="token operator">=</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//调用getsockopt来获取并清除sockfd上的错误</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">getsockopt</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span>SOL_SOCKET<span class="token punctuation">,</span>SO_ERROR<span class="token punctuation">,</span><span class="token operator">&amp;</span>error<span class="token punctuation">,</span><span class="token operator">&amp;</span>length<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"get socket option failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">close</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//错误号不为0表示连接出错</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>error<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"connection failed after select with theerror:%d\n"</span><span class="token punctuation">,</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">close</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//连接成功</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"connection ready after select with thesocket:%d\n"</span><span class="token punctuation">,</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fcntl</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span>F_SETFL<span class="token punctuation">,</span>fdopt<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> sockfd<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span><span class="token keyword">char</span><span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>argc<span class="token operator">&lt;=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"usage:%s ip_address port_number\n"</span><span class="token punctuation">,</span><span class="token function">basename</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> ip<span class="token operator">=</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> port<span class="token operator">=</span><span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> sockfd<span class="token operator">=</span><span class="token function">unblock_connect</span><span class="token punctuation">(</span>ip<span class="token punctuation">,</span>port<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>sockfd<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">close</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<p><strong>存在的问题</strong></p>
<ul>
<li>非阻塞的socket可能导致connect始终失败</li>
<li>select对处于EINPROGRESS状态下的socket可能不起作用</li>
<li>对于出错的socket，getsockopt在有些系统上返回-1，在有些系统上返回0</li>
<li>上述问题没有统一的解决方法</li>
</ul>
<h2 id="聊天室程序"><a href="#聊天室程序" class="headerlink" title="聊天室程序"></a>聊天室程序</h2><p><strong>客户端功能</strong></p>
<ul>
<li>从标准输入终端读入用户数据，并将用户数据发送至服务器</li>
<li>往标准输出终端答应服务器发送给它的数据</li>
</ul>
<p><strong>服务器功能</strong></p>
<ul>
<li>接收客户数据，并把客户数据发送给没一个登录到该服务器上的客户端（数据发送者除外）</li>
</ul>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>使用poll同时监听用户输入和网络连接，并利用splice函数将用户输入内容直接定向到网络连接上以发送之，实现数据零拷贝，提高程序执行效率</p>
<hr>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span><span class="token expression">_GNU_SOURCE <span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netinet/in.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;poll.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BUFFER_SIZE</span> <span class="token expression"><span class="token number">64</span></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span><span class="token keyword">char</span><span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>argc<span class="token operator">&lt;=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"usage:%s ip_address port_number\n"</span><span class="token punctuation">,</span><span class="token function">basename</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> ip<span class="token operator">=</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> port<span class="token operator">=</span><span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> server_address<span class="token punctuation">;</span>
	<span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>server_address<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>server_address<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	server_address<span class="token punctuation">.</span>sin_family<span class="token operator">=</span>AF_INET<span class="token punctuation">;</span>
	<span class="token function">inet_pton</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span>ip<span class="token punctuation">,</span><span class="token operator">&amp;</span>server_address<span class="token punctuation">.</span>sin_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	server_address<span class="token punctuation">.</span>sin_port<span class="token operator">=</span><span class="token function">htons</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> sockfd<span class="token operator">=</span><span class="token function">socket</span><span class="token punctuation">(</span>PF_INET<span class="token punctuation">,</span>SOCK_STREAM<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>sockfd<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">connect</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>server_address<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>server_address<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"connection failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">close</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    pollfd fds<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token comment">//注册文件描述符0（标准输入）和文件描述符sockfd上的可读事件</span>
	fds<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>fd<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
	fds<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>events<span class="token operator">=</span>POLLIN<span class="token punctuation">;</span>
	fds<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>revents<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
	fds<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>fd<span class="token operator">=</span>sockfd<span class="token punctuation">;</span>
	fds<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>events<span class="token operator">=</span>POLLIN<span class="token operator">|</span>POLLRDHUP<span class="token punctuation">;</span>
	fds<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>revents<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">char</span> read_buf<span class="token punctuation">[</span>BUFFER_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> pipefd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> ret<span class="token operator">=</span><span class="token function">pipe</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>ret<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		ret<span class="token operator">=</span><span class="token function">poll</span><span class="token punctuation">(</span>fds<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"poll failure\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
        <span class="token comment">// POLLRDHUP-TCP连接被对方关闭或者对方关闭了写操作</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>revents<span class="token operator">&amp;</span> POLLRDHUP<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"server close the connection\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>revents<span class="token operator">&amp;</span>POLLIN<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">memset</span><span class="token punctuation">(</span>read_buf<span class="token punctuation">,</span><span class="token char">'\0'</span><span class="token punctuation">,</span>BUFFER_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">recv</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>fd<span class="token punctuation">,</span>read_buf<span class="token punctuation">,</span>BUFFER_SIZE<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>read_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>revents<span class="token operator">&amp;</span>POLLIN<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">//使用splice将用户输入的数据直接写到sockfd上（零拷贝）</span>
            ret<span class="token operator">=</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span>pipefd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token number">32768</span><span class="token punctuation">,</span>SPLICE_F_MORE<span class="token operator">|</span>SPLICE_F_MOVE<span class="token punctuation">)</span><span class="token punctuation">;</span>
            ret<span class="token operator">=</span><span class="token function">splice</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span>sockfd<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token number">32768</span><span class="token punctuation">,</span>SPLICE_F_MORE<span class="token operator">|</span>SPLICE_F_MOVE<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">close</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>使用poll同时管理监听socket和连接socket，并且使用牺牲空间换取事件的策略来提高服务器性能</p>
<hr>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span><span class="token expression">_GNU_SOURCE <span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netinet/in.h＞#include＜arpa/inet.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;errno.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;poll.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">USER_LIMIT</span> <span class="token expression"><span class="token number">5</span></span><span class="token comment">//最大用户数量</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BUFFER_SIZE</span> <span class="token expression"><span class="token number">64</span></span><span class="token comment">//读缓冲区的大小</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FD_LIMIT</span> <span class="token expression"><span class="token number">65535</span></span><span class="token comment">//文件描述符数量限制</span></span>

<span class="token comment">//客户数据：客户端socket地址、待写到客户端的数据的位置、从客户端读入的数据</span>
<span class="token keyword">struct</span> <span class="token class-name">client_data</span><span class="token punctuation">{</span>
	sockaddr_in address<span class="token punctuation">;</span>
	<span class="token keyword">char</span><span class="token operator">*</span> write_buf<span class="token punctuation">;</span>
	<span class="token keyword">char</span> buf<span class="token punctuation">[</span>BUFFER_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">setnonblocking</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> old_option<span class="token operator">=</span><span class="token function">fcntl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>F_GETFL<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> new_option<span class="token operator">=</span>old_option<span class="token operator">|</span>O_NONBLOCK<span class="token punctuation">;</span>
	<span class="token function">fcntl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>F_SETFL<span class="token punctuation">,</span>new_option<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> old_option<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span><span class="token keyword">char</span><span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>argc<span class="token operator">&lt;=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"usage:%s ip_address port_number\n"</span><span class="token punctuation">,</span><span class="token function">basename</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 	<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> ip<span class="token operator">=</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> port<span class="token operator">=</span><span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> ret<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> address<span class="token punctuation">;</span>
	<span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	address<span class="token punctuation">.</span>sin_family<span class="token operator">=</span>AF_INET<span class="token punctuation">;</span>
	<span class="token function">inet_pton</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span>ip<span class="token punctuation">,</span><span class="token operator">&amp;</span>address<span class="token punctuation">.</span>sin_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	address<span class="token punctuation">.</span>sin_port<span class="token operator">=</span><span class="token function">htons</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> listenfd<span class="token operator">=</span><span class="token function">socket</span><span class="token punctuation">(</span>PF_INET<span class="token punctuation">,</span>SOCK_STREAM<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>listenfd<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	ret<span class="token operator">=</span><span class="token function">bind</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>ret<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	ret<span class="token operator">=</span><span class="token function">listen</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>ret<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//创建users数组，分配FD_LIMIT个client_data对象。可以预期：每个可能的socket连接都可以获得一个这样的对象，并且socket的值可以直接用来索引（作为数组的下标）socket连接对应的client_data对象，这是将socket和客户数据关联的简单而高效的方式</span>
	client_data<span class="token operator">*</span> users<span class="token operator">=</span>new client_data<span class="token punctuation">[</span>FD_LIMIT<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token comment">//尽管我们分配了足够多的client_data对象，但为了提高poll的性能，仍然有必要限制用户的数量</span>
	pollfd fds<span class="token punctuation">[</span>USER_LIMIT<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> user_counter<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>USER_LIMIT<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>
		fds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>fd<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
		fds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
	fds<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>fd<span class="token operator">=</span>listenfd<span class="token punctuation">;</span>
	fds<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>events<span class="token operator">=</span>POLLIN<span class="token operator">|</span>POLLERR<span class="token punctuation">;</span>
	fds<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>revents<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		ret<span class="token operator">=</span><span class="token function">poll</span><span class="token punctuation">(</span>fds<span class="token punctuation">,</span>user_counter<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"poll failure\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>user_counter<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>fd<span class="token operator">==</span>listenfd<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>revents<span class="token operator">&amp;</span>POLLIN<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
				<span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> client_address<span class="token punctuation">;</span>
				<span class="token class-name">socklen_t</span> client_addrlength<span class="token operator">=</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>client_address<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">int</span> connfd<span class="token operator">=</span><span class="token function">accept</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>client_address<span class="token punctuation">,</span><span class="token operator">&amp;</span>client_addrlength<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>connfd<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"errno is:%d\n"</span><span class="token punctuation">,</span>errno<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">continue</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token comment">//如果请求太多，则关闭新到的连接</span>
				<span class="token keyword">if</span><span class="token punctuation">(</span>user_counter<span class="token operator">&gt;=</span>USER_LIMIT<span class="token punctuation">)</span><span class="token punctuation">{</span>
					<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> info<span class="token operator">=</span><span class="token string">"too many users\n"</span><span class="token punctuation">;</span>
					<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token function">send</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span>info<span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token function">close</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token keyword">continue</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
				<span class="token comment">//对于新的连接，同时修改fds和users数组。前文已经提到，users[connfd]对应于新连接文件描述符connfd的客户数据</span>
				user_counter<span class="token operator">++</span><span class="token punctuation">;</span>
				users<span class="token punctuation">[</span>connfd<span class="token punctuation">]</span><span class="token punctuation">.</span>address<span class="token operator">=</span>client_address<span class="token punctuation">;</span>
				<span class="token function">setnonblocking</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
				fds<span class="token punctuation">[</span>user_counter<span class="token punctuation">]</span><span class="token punctuation">.</span>fd<span class="token operator">=</span>connfd<span class="token punctuation">;</span>
				fds<span class="token punctuation">[</span>user_counter<span class="token punctuation">]</span><span class="token punctuation">.</span>events<span class="token operator">=</span>POLLIN<span class="token operator">|</span>POLLRDHUP<span class="token operator">|</span>POLLERR<span class="token punctuation">;</span>
				fds<span class="token punctuation">[</span>user_counter<span class="token punctuation">]</span><span class="token punctuation">.</span>revents<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
				<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"comes a new user,now have%d users\n"</span><span class="token punctuation">,</span>user_counter<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>revents<span class="token operator">&amp;</span>POLLERR<span class="token punctuation">)</span><span class="token punctuation">{</span>
				<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"get an error from%d\n"</span><span class="token punctuation">,</span>fds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">char</span> errors<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
				<span class="token function">memset</span><span class="token punctuation">(</span>errors<span class="token punctuation">,</span><span class="token char">'\0'</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token class-name">socklen_t</span> length<span class="token operator">=</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>errors<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">getsockopt</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>fd<span class="token punctuation">,</span>SOL_SOCKET<span class="token punctuation">,</span>SO_ERROR<span class="token punctuation">,</span><span class="token operator">&amp;</span>errors<span class="token punctuation">,</span><span class="token operator">&amp;</span>length<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
					<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"get socket option failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">continue</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>revents<span class="token operator">&amp;</span>POLLRDHUP<span class="token punctuation">)</span><span class="token punctuation">{</span>
				<span class="token comment">//如果客户端关闭连接，则服务器也关闭对应的连接，并将用户总数减1</span>
                users<span class="token punctuation">[</span>fds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>fd<span class="token punctuation">]</span><span class="token operator">=</span>users<span class="token punctuation">[</span>fds<span class="token punctuation">[</span>user_counter<span class="token punctuation">]</span><span class="token punctuation">.</span>fd<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token function">close</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
                fds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>fds<span class="token punctuation">[</span>user_counter<span class="token punctuation">]</span><span class="token punctuation">;</span>
                i<span class="token operator">--</span><span class="token punctuation">;</span>
                user_counter<span class="token operator">--</span><span class="token punctuation">;</span>
                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a client left\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>revents<span class="token operator">&amp;</span>POLLIN<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">int</span> connfd<span class="token operator">=</span>fds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>fd<span class="token punctuation">;</span>
                <span class="token function">memset</span><span class="token punctuation">(</span>users<span class="token punctuation">[</span>connfd<span class="token punctuation">]</span><span class="token punctuation">.</span>buf<span class="token punctuation">,</span><span class="token char">'\0'</span><span class="token punctuation">,</span>BUFFER_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
                ret<span class="token operator">=</span><span class="token function">recv</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span>users<span class="token punctuation">[</span>connfd<span class="token punctuation">]</span><span class="token punctuation">.</span>buf<span class="token punctuation">,</span>BUFFER_SIZE<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"get%d bytes of client data%sfrom%d\n"</span><span class="token punctuation">,</span>ret<span class="token punctuation">,</span>users<span class="token punctuation">[</span>connfd<span class="token punctuation">]</span><span class="token punctuation">.</span>buf<span class="token punctuation">,</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
					<span class="token comment">//如果读操作出错，则关闭连接</span>
					<span class="token keyword">if</span><span class="token punctuation">(</span>errno<span class="token operator">!=</span>EAGAIN<span class="token punctuation">)</span><span class="token punctuation">{</span>
						<span class="token function">close</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
						users<span class="token punctuation">[</span>fds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>fd<span class="token punctuation">]</span><span class="token operator">=</span>users<span class="token punctuation">[</span>fds<span class="token punctuation">[</span>user_counter<span class="token punctuation">]</span><span class="token punctuation">.</span>fd<span class="token punctuation">]</span><span class="token punctuation">;</span>
                        fds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>fds<span class="token punctuation">[</span>user_counter<span class="token punctuation">]</span><span class="token punctuation">;</span>
                        i<span class="token operator">--</span><span class="token punctuation">;</span>
						user_counter<span class="token operator">--</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
				<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
				<span class="token keyword">else</span><span class="token punctuation">{</span>
					<span class="token comment">//如果接收到客户数据，则通知其他socket连接准备写数据*/</span>
					<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>user_counter<span class="token punctuation">;</span><span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span>
						<span class="token keyword">if</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>fd<span class="token operator">==</span>connfd<span class="token punctuation">)</span><span class="token punctuation">{</span>
							<span class="token keyword">continue</span><span class="token punctuation">;</span>
						<span class="token punctuation">}</span>
						fds<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>events<span class="token operator">|=</span><span class="token operator">~</span>POLLIN<span class="token punctuation">;</span>
						fds<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>events<span class="token operator">|=</span>POLLOUT<span class="token punctuation">;</span>
						users<span class="token punctuation">[</span>fds<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>fd<span class="token punctuation">]</span><span class="token punctuation">.</span>write_buf<span class="token operator">=</span>users<span class="token punctuation">[</span>connfd<span class="token punctuation">]</span><span class="token punctuation">.</span>buf<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
			<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>fds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>revents<span class="token operator">&amp;</span>POLLOUT<span class="token punctuation">)</span><span class="token punctuation">{</span>
				<span class="token keyword">int</span> connfd<span class="token operator">=</span>fds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>fd<span class="token punctuation">;</span>
				<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>users<span class="token punctuation">[</span>connfd<span class="token punctuation">]</span><span class="token punctuation">.</span>write_buf<span class="token punctuation">)</span><span class="token punctuation">{</span>
					<span class="token keyword">continue</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				ret<span class="token operator">=</span><span class="token function">send</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span>users<span class="token punctuation">[</span>connfd<span class="token punctuation">]</span><span class="token punctuation">.</span>write_buf<span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span>users<span class="token punctuation">[</span>connfd<span class="token punctuation">]</span><span class="token punctuation">.</span>write_buf<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                users<span class="token punctuation">[</span>connfd<span class="token punctuation">]</span><span class="token punctuation">.</span>write_buf<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
				<span class="token comment">//写完数据后需要重新注册fds[i]上的可读事件</span>
				fds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events<span class="token operator">|=</span><span class="token operator">~</span>POLLOUT<span class="token punctuation">;</span>
                fds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events<span class="token operator">|=</span>POLLIN<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
	delete<span class="token punctuation">[</span><span class="token punctuation">]</span> users<span class="token punctuation">;</span>
	<span class="token function">close</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="同时处理TCP和UDP服务"><a href="#同时处理TCP和UDP服务" class="headerlink" title="同时处理TCP和UDP服务"></a>同时处理TCP和UDP服务</h2><ul>
<li>从bind系统调用的参数来看，一个socket只能与一个socket地址绑定，即一个socket只能用来监听一个端口；因此，服务器如果要同时监听多个端口，就必须创建多个socket，并将它们分别绑定到多个端口上</li>
<li>即使是同一个端口，如果服务器要同时处理劳改端口上的TCP和UDP请求，也需要创建两个不同的socket：一个是流socket，另一个是数据报socket，并将它们都绑定到该端口上</li>
</ul>
<hr>
<p><strong>同时处理TCP请求和UDP请求的回射服务器</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netinet/in.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;errno.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/epoll.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_EVENT_NUMBER</span> <span class="token expression"><span class="token number">1024</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TCP_BUFFER_SIZE</span> <span class="token expression"><span class="token number">512</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">UDP_BUFFER_SIZE</span> <span class="token expression"><span class="token number">1024</span></span></span>

<span class="token keyword">int</span> <span class="token function">setnonblocking</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> old_option<span class="token operator">=</span><span class="token function">fcntl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>F_GETFL<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> new_option<span class="token operator">=</span>old_option<span class="token operator">|</span>O_NONBLOCK<span class="token punctuation">;</span>
	<span class="token function">fcntl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>F_SETFL<span class="token punctuation">,</span>new_option<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> old_option<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">addfd</span><span class="token punctuation">(</span><span class="token keyword">int</span> epollfd<span class="token punctuation">,</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">{</span>
	epoll_event event<span class="token punctuation">;</span>
	event<span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd<span class="token operator">=</span>fd<span class="token punctuation">;</span>
	event<span class="token punctuation">.</span>events<span class="token operator">=</span>EPOLLIN<span class="token operator">|</span>EPOLLET<span class="token punctuation">;</span>
	<span class="token function">epoll_ctl</span><span class="token punctuation">(</span>epollfd<span class="token punctuation">,</span>EPOLL_CTL_ADD<span class="token punctuation">,</span>fd<span class="token punctuation">,</span><span class="token operator">&amp;</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">setnonblocking</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span><span class="token keyword">char</span><span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>argc<span class="token operator">&lt;=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"usage:%s ip_address port_number\n"</span><span class="token punctuation">,</span><span class="token function">basename</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> ip<span class="token operator">=</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> port<span class="token operator">=</span><span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> ret<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> address<span class="token punctuation">;</span>
	<span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	address<span class="token punctuation">.</span>sin_family<span class="token operator">=</span>AF_INET<span class="token punctuation">;</span>
	<span class="token function">inet_pton</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span>ip<span class="token punctuation">,</span><span class="token operator">&amp;</span>address<span class="token punctuation">.</span>sin_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	address<span class="token punctuation">.</span>sin_port<span class="token operator">=</span><span class="token function">htons</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//创建TCP socket，并将其绑定到端口port上</span>
	<span class="token keyword">int</span> listenfd<span class="token operator">=</span><span class="token function">socket</span><span class="token punctuation">(</span>PF_INET<span class="token punctuation">,</span>SOCK_STREAM<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>listenfd<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	ret<span class="token operator">=</span><span class="token function">bind</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>ret<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	ret<span class="token operator">=</span><span class="token function">listen</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>ret<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//创建UDP socket，并将其绑定到端口port上</span>
	<span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	address<span class="token punctuation">.</span>sin_family<span class="token operator">=</span>AF_INET<span class="token punctuation">;</span>
	<span class="token function">inet_pton</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span>ip<span class="token punctuation">,</span><span class="token operator">&amp;</span>address<span class="token punctuation">.</span>sin_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	address<span class="token punctuation">.</span>sin_port<span class="token operator">=</span><span class="token function">htons</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> udpfd<span class="token operator">=</span><span class="token function">socket</span><span class="token punctuation">(</span>PF_INET<span class="token punctuation">,</span>SOCK_DGRAM<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>udpfd<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	ret<span class="token operator">=</span><span class="token function">bind</span><span class="token punctuation">(</span>udpfd<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>ret<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	epoll_event events<span class="token punctuation">[</span>MAX_EVENT_NUMBER<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> epollfd<span class="token operator">=</span><span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>epollfd<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//注册TCP socket和UDP socket上的可读事件</span>
	<span class="token function">addfd</span><span class="token punctuation">(</span>epollfd<span class="token punctuation">,</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">addfd</span><span class="token punctuation">(</span>epollfd<span class="token punctuation">,</span>udpfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">int</span> number<span class="token operator">=</span><span class="token function">epoll_wait</span><span class="token punctuation">(</span>epollfd<span class="token punctuation">,</span>events<span class="token punctuation">,</span>MAX_EVENT_NUMBER<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>number<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"epoll failure\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>number<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token keyword">int</span> sockfd<span class="token operator">=</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd<span class="token punctuation">;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>sockfd<span class="token operator">==</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">{</span>
				<span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> client_address<span class="token punctuation">;</span>
				<span class="token class-name">socklen_t</span> client_addrlength<span class="token operator">=</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>client_address<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">int</span> connfd<span class="token operator">=</span><span class="token function">accept</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>client_address<span class="token punctuation">,</span><span class="token operator">&amp;</span>client_addrlength<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token function">addfd</span><span class="token punctuation">(</span>epollfd<span class="token punctuation">,</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>sockfd<span class="token operator">==</span>udpfd<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token comment">//UDP不用建立连接，无须调用accept函数</span>
				<span class="token keyword">char</span> buf<span class="token punctuation">[</span>UDP_BUFFER_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
				<span class="token function">memset</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span><span class="token char">'\0'</span><span class="token punctuation">,</span>UDP_BUFFER_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> client_address<span class="token punctuation">;</span>
				<span class="token class-name">socklen_t</span> client_addrlength<span class="token operator">=</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>client_address<span class="token punctuation">)</span><span class="token punctuation">;</span>
				ret<span class="token operator">=</span><span class="token function">recvfrom</span><span class="token punctuation">(</span>udpfd<span class="token punctuation">,</span>buf<span class="token punctuation">,</span>UDP_BUFFER_SIZE<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>client_address<span class="token punctuation">,</span><span class="token operator">&amp;</span>client_addrlength<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
					<span class="token function">sendto</span><span class="token punctuation">(</span>udpfd<span class="token punctuation">,</span>buf<span class="token punctuation">,</span>UDP_BUFFER_SIZE<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>client_address<span class="token punctuation">,</span>client_addrlength<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
			<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events＆EPOLLIN<span class="token punctuation">)</span><span class="token punctuation">{</span>
				<span class="token keyword">char</span> buf<span class="token punctuation">[</span>TCP_BUFFER_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
				<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
					<span class="token function">memset</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span><span class="token char">'\0'</span><span class="token punctuation">,</span>TCP_BUFFER_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
					ret<span class="token operator">=</span><span class="token function">recv</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span>buf<span class="token punctuation">,</span>TCP_BUFFER_SIZE<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
						<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>errno<span class="token operator">==</span>EAGAIN<span class="token punctuation">)</span><span class="token operator">||</span><span class="token punctuation">(</span>errno<span class="token operator">==</span>EWOULDBLOCK<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
							<span class="token keyword">break</span><span class="token punctuation">;</span>
						<span class="token punctuation">}</span>
						<span class="token function">close</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
					<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
						<span class="token function">close</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
					<span class="token keyword">else</span><span class="token punctuation">{</span>
						<span class="token function">send</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span>buf<span class="token punctuation">,</span>ret<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span><span class="token punctuation">{</span>
				<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"something else happened\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
	<span class="token function">close</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <tags>
        <tag>C++ socket</tag>
      </tags>
  </entry>
  <entry>
    <title>CMAKE了解</title>
    <url>/2023/02/28/CMAKE%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<p><a href="https://modern-cmake-cn.github.io/Modern-CMake-zh_CN/">Modern CMake 简体中文版</a><br><a href="http://file.ncnynl.com/ros/CMake%20Practice.pdf">CMake实践</a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="为什么要使用CMAKE？"><a href="#为什么要使用CMAKE？" class="headerlink" title="为什么要使用CMAKE？"></a>为什么要使用CMAKE？</h2><ul>
<li>你需要在不止一台电脑上构建软件包</li>
<li>你想使用IDE，但也许不总是使用</li>
<li>你需要支持不同的操作系统（甚至可能只是Unix的不同版本）</li>
<li>你想支持多个编译器</li>
<li>你想使用一个第三方库</li>
<li>……</li>
</ul>
<p>CMake的生态极好，大部分的IDE都支持CMake（或者是CMake支持那个IDE）。如果你想要在你的代码中包含一个库，你有两个选择，要么自己写一个构建系统，要么使用该库支持的构建系统中的某个。而那通常包含 CMake。 如何你的工程包含的库多了，CMake 或很快成为那些库所支持的构建系统的交集</p>
<span id="more"></span>
<h2 id="CMake应该避免的行为"><a href="#CMake应该避免的行为" class="headerlink" title="CMake应该避免的行为"></a>CMake应该避免的行为</h2><ul>
<li><strong>不要使用具有全局作用域的函数</strong><br>  包含<em>link_directories</em>、<em>include_libraries</em>等相似的函数</li>
<li><strong>不要添加非必要的PUBLIC要求</strong><br>  避免把一些不必要的东西强加给用户，更应该声明为PRIVATE</li>
<li><strong>不要在file函数中添加GLOB文件</strong></li>
<li><strong>将库直接链接到需要构建的目标上</strong><br>  如果可以的化，总是显示的将库链接到目标上</li>
<li><strong>当链接库文件时，不要省略 PUBLIC 或 PRIVATE 关键字</strong><br>  这将会导致后续所有的链接都是缺省的<h2 id="CMake应遵守的规范"><a href="#CMake应遵守的规范" class="headerlink" title="CMake应遵守的规范"></a>CMake应遵守的规范</h2></li>
<li><strong>把 CMake 程序视作代码：</strong><br>  它是代码。它应该和其他的代码一样，是整洁并且可读的。</li>
<li><strong>建立目标的观念：</strong><br>  你的目标应该代表一系列的概念。为任何需要保持一致的东西指定一个 （导入型）INTERFACE 目标，然后每次都链接到该目标。</li>
<li><strong>导出你的接口：</strong><br>  你的 CMake 项目应该可以直接构建或者安装。</li>
<li><strong>为库书写一个 Config.cmake 文件：</strong><br>  这是库作者为支持客户的体验而应该做的。</li>
<li><strong>声明一个 ALIAS 目标以保持使用的一致性：</strong><br>  使用 add_subdirectory 和 find_package 应该提供相同的目标和命名空间。</li>
<li><strong>将常见的功能合并到有详细文档的函数或宏中：</strong><br>  函数往往是更好的选择。</li>
<li><strong>使用小写的函数名：</strong><br>  CMake 的函数和宏的名字可以定义为大写或小写，但是一般都使用小写，变量名用大写。</li>
<li><strong>使用 cmake_policy 和/或 限定版本号范围：</strong><br>  每次改变版本特性 (policy) 都要有据可依。应该只有不得不使用旧特性时才降低特性 (policy) 版本。<h1 id="CMake-amp-HelloWorld"><a href="#CMake-amp-HelloWorld" class="headerlink" title="CMake &amp; HelloWorld"></a>CMake &amp; HelloWorld</h1>在目录practice下创建两个文件<em>main.cpp</em>和<em>CMakeLists.txt</em>:<br><sup><a href="#fn_注" id="reffn_注">注</a></sup>CMakeLists.txt文件必须保持一致<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">-practice
 |-main.cpp
 |-CMakeLists.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<strong><em>main.cpp</em></strong><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;

int main()&#123;
	std::cout&lt;&lt;&quot;Hello, World!&quot;&lt;&lt;std::endl;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<strong><em>CMakeLists.txt</em></strong><pre class="line-numbers language-CMake" data-language="CMake"><code class="language-CMake">cmake_minimum_required(VERSION 3.1)
project(HELLO)
set(SRC_LIST main.cpp)
# MESSAGE(STATUS &quot;This is BINARY dir &quot; $&#123;HELLO_BINARY_DIR&#125;)
add_executable(hello SRC_LIST)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="cmake-minimum-required"><a href="#cmake-minimum-required" class="headerlink" title="cmake_minimum_required"></a>cmake_minimum_required</h2><em>cmake_minimum_required(VERSION 3.1)</em><br>每个CMakeLists.txt都要包含的第一行，CMake的版本与他的特性相互关联，这意味着定义了CMake的行为变化<br>从CMake 3.12开始，版本号可以声明为一个范围，如： VERSION 3.1…3.15，表名该工程最低可以支持3.1版本，但是最高在3.15版本上测试成功过</li>
</ul>
<h2 id="project"><a href="#project" class="headerlink" title="project"></a>project</h2><p><em>project</em>命令用来指定工程的名字和支持的语言，默认支持所有的语言</p>
<ul>
<li><strong><em>project(HELLO)</em></strong> 指定了工程的名字，并且支持所有的语言</li>
<li><strong><em>project(HELLO CXX)</em></strong> 指定了工程的名字，并且支持语言的C++</li>
<li><strong><em>project(HELLO C CXX)</em></strong> 指定了工程的名字，并且支持的语言是C和C++</li>
</ul>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>set命令用来显示的指定变量<br><strong><em>set(SRC_LIST main.cpp)</em></strong>后，SRC_LIST变量就包含了<em>main.cpp</em><br>也可以<strong><em>set(SRC_LIST main.cpp t1.cpp t2.cpp)</em></strong>，不同的文件用空格分隔，也可以通过<strong><em>；</em></strong>来分隔</p>
<p>变量名通常全部用大写，变量值跟在其后，你可以通过<strong>${}</strong>来解析一个变量，例如<strong><em>${SRC_LIST}</em></strong></p>
<p>CMake有作用域的概念，在声明一个变量之后，你只可以在当前作用域（即当前的文件夹下），你可以通过在变量声明末尾添加<strong><em>PARENT_SCOPE</em></strong>来将它的作用域定为当前的上一级作用域</p>
<h2 id="message"><a href="#message" class="headerlink" title="message"></a>message</h2><p><em>message</em>命令用来向终端输出用户自定义的信息</p>
<ul>
<li><strong><em>SEND_ERROR</em></strong>，产生错误，生成过程被跳过</li>
<li><strong><em>STATUS</em></strong>，输出前缀为 - 的信息</li>
<li><strong><em>FATAL_ERROR</em></strong>，立即终止所有cmake过程</li>
</ul>
<h2 id="add-executable"><a href="#add-executable" class="headerlink" title="add_executable"></a>add_executable</h2><p>该命令用来生成可执行文件<br><strong><em>add_executable(hello SRC_LIST)</em></strong>生成的可执行文件名字是<strong>hello</strong>，源文件读取<strong>SRC_LIST</strong>中的内容<br>也可以写成<strong><em>add_executable(hello main.cpp)</em></strong></p>
<h2 id="内部构建和外部构建"><a href="#内部构建和外部构建" class="headerlink" title="内部构建和外部构建"></a>内部构建和外部构建</h2><p>上述例子就是内部构建，他生成的临时文件很多，不方便管理<br>而外部构建则是新建一个build文件夹，将所有生成的临时文件都统一的放在build文件夹下，不会对源文件产生影响<br>在我们使用project指令后，会隐式地生成两个CMake变量：</p>
<ul>
<li><projectname>_BINARY_DIR，本例中是 HELLO_BINARY_DIR</li>
<li><projectname>_SOURCE_DIR，本例中是 HELLO_SOURCE_DIR</li>
</ul>
<p>当前都指向当前的工作目录</p>
<hr>
<p>问题：如果改了工程名，这两个变量名也会改变</p>
<p>解决：又定义两个预定义变量：PROJECT_BINARY_DIR和PROJECT_SOURCE_DIR，这两个变量和HELLO_BINARY_DIR，HELLO_SOURCE_DIR是一致的。所以改了工程名也没有关系</p>
<p>在我们在build目录下运行make构建工程后</p>
<p>HELLO_SOURCE_DIR  还是工程路径</p>
<p>HELLO_BINARY_DIR  编译路径 也就是 practice/bulid</p>
<h2 id="SET关键字"><a href="#SET关键字" class="headerlink" title="SET关键字"></a>SET关键字</h2><h1 id="HelloWorld-amp-工程"><a href="#HelloWorld-amp-工程" class="headerlink" title="HelloWorld &amp; 工程"></a>HelloWorld &amp; 工程</h1><p>在我们的实际开发中，我们并不会将工程中的所有源代码文件都挤在一个文件夹下，并且大多时候是分模块开发的</p>
<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">-practice
 |-build
 |-src
 |  |-main.cpp
 |  |-CMakeLists.txt
 |-func
 |  |-cal.hpp
 |  |-CMakeLists.txt
 |-CMakeLists.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h2><p><strong><em>CMakeLists.txt</em></strong><br><pre class="line-numbers language-CMake" data-language="CMake"><code class="language-CMake">cmake_minimum_required(VERSION 3.1)
project(PRACTICE)
add_subdirectory(src)
add_subdirectory(func)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p>
<h2 id="src"><a href="#src" class="headerlink" title="src"></a>src</h2><p><strong><em>main.cpp</em></strong></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
#include &quot;cal.hpp&quot;

int main()&#123;
	int a &#x3D; 10, b &#x3D; 5;
	int c &#x3D; add(a, b);
	int d &#x3D; sub(a, b);
	std::cout&lt;&lt;&quot;a+b&#x3D;&quot;&lt;&lt;c&lt;&lt;std::endl;
	std::cout&lt;&lt;&quot;a-b&#x3D;&quot;&lt;&lt;d&lt;&lt;std::endl;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong><em>CMakeLists.txt</em></strong><br><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.1</span><span class="token punctuation">)</span>
<span class="token keyword">project</span><span class="token punctuation">(</span>SRC<span class="token punctuation">)</span>
<span class="token keyword">add_executable</span><span class="token punctuation">(</span>practice main.cpp<span class="token punctuation">)</span>
<span class="token keyword">target_include_directories</span><span class="token punctuation">(</span>practice <span class="token namespace">PRIVATE</span> ../func<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p>
<h2 id="func"><a href="#func" class="headerlink" title="func"></a>func</h2><p><strong><em>cal.hpp</em></strong></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
int add(int a,int b)&#123;return a+b;&#125;
int sub(int a,int b)&#123;return a-b;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><strong><em>CMakeLists.txt</em></strong><br><pre class="line-numbers language-CMake" data-language="CMake"><code class="language-CMake">cmake_minimum_required(VERSION 3.1)
project(FUNC)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p>
<h2 id="add-subdirectory"><a href="#add-subdirectory" class="headerlink" title="add_subdirectory"></a>add_subdirectory</h2><p><strong><em>add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</em></strong></p>
<ul>
<li>这个指令用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置</li>
<li>EXCLUDE_FROM_ALL函数是将写的目录从编译中排除</li>
<li>add_subdirectory(src bin)<br>将 src 子目录加入工程并指定编译输出(包含编译中间结果)路径为bin 目录如果不进行 bin 目录的指定，那么编译结果(包括中间结果)都将存放在build/src 目录<h2 id="target-include-directories"><a href="#target-include-directories" class="headerlink" title="target_include_directories"></a>target_include_directories</h2></li>
</ul>
<p><strong><em>target_include_directories</em></strong>命令用来指定目标包含的头文件路径</p>
<p><strong><em>target_link_libraries</em></strong>命令用来指定目标链接的库</p>
<p><strong><em>target_compile_options</em></strong>命令用来指定目标的编译选项</p>
<hr>
<p><em>target_include_directories(<strong><target></strong> [SYSTEM] [AFTER|BEFORE] <strong><INTERFACE|PUBLIC|PRIVATE> [items1…]</strong>)</em></p>
<p><strong><em>target</em></strong></p>
<p><strong>目标由<em>add_library()</em>或<em>add_executable()</em>生成</strong></p>
<p><strong><em><INTERFACE|PUBLIC|PRIVATE>使用依据</em></strong><br>==INTERFACE==:target对应的头文件使用<br>==PRIVATE==：target对应的源文件使用<br>==PUBLIC==:target对应的头文件和源文件使用</p>
<h2 id="include-directories"><a href="#include-directories" class="headerlink" title="include_directories"></a><strong>include_directories</strong></h2><p><strong><em>include_directories([AFTER|BEFORE] [SYSTEM] dir1 [dir2 …])</em></strong></p>
<p>==include_directories(../func)==</p>
<p><strong><em>target_include_directories</em></strong>的功能可以用<strong><em>include_directories</em></strong>完全替代，但是官方文档和实际项目要求都建议尽可能地使用<strong><em>target_include_directories</em></strong></p>
<p>因为<strong><em>include_directories</em></strong>是对当前<strong><em>CMakeLists.txt</em></strong>中的==所有目标==以及在其调用点之后添加的子目录中的所有目标将具有此头文件搜索路径，是一个全局包含，所以尽量使用<strong><em>target_include_directories</em></strong>使项目保持清晰</p>
<h2 id="更改二进制的保存路径更改二进制的保存路径"><a href="#更改二进制的保存路径更改二进制的保存路径" class="headerlink" title="更改二进制的保存路径更改二进制的保存路径"></a>更改二进制的保存路径更改二进制的保存路径</h2><p>SET 指令重新定义 EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH 变量 来指定最终的目标二进制的位置</p>
<p>SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)<br>SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib)</p>
<h1 id="静态库和动态库"><a href="#静态库和动态库" class="headerlink" title="静态库和动态库"></a>静态库和动态库</h1><p>建立一个静态库和动态库，提供hello函数供其他程序编程使用，作用是向终端输出Hello, World!字符串</p>
<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">-practice_lib
|-build
|-CMakeLists.txt
|-lib
	|-CMakeLists.txt
	|-hello.hpp
	|-hello.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong><em>hello.hpp</em></strong><br><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#ifndef HELLO_H
#define HELLO_H
void hello();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br><strong><em>hello.cpp</em></strong><br><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;hello.hpp&quot;
#include&lt;iostream&gt;
void hello()&#123;
	std::cout&lt;&lt;&quot;Hello World!&quot;&lt;&lt;std::endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><strong><em>CMakeLists.txt</em></strong><br><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">project</span><span class="token punctuation">(</span>HELLO<span class="token punctuation">)</span>
<span class="token keyword">add_subdirectory</span><span class="token punctuation">(</span>lib bin<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br><strong><em>lib/CMakeLists.txt</em></strong><br><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">set</span><span class="token punctuation">(</span>LIBHELLO_SRC hello.cpp<span class="token punctuation">)</span>
<span class="token keyword">add_library</span><span class="token punctuation">(</span>hello <span class="token namespace">SHARED</span> <span class="token punctuation">$&#123;</span>LIBHELLO_SRC<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
````

<span class="token comment">## add_library</span>
***<span class="token keyword">add_library</span><span class="token punctuation">(</span>hello <span class="token namespace">SHARED</span> \<span class="token punctuation">$&#123;</span>LIBHELLO_SRC<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>***
- hello:库名，生成地名字前面会加上lib
- <span class="token namespace">SHARED</span>，动态库；<span class="token namespace">STATIC</span>：静态库
- <span class="token punctuation">$&#123;</span>LIBHELLO_SRC<span class="token punctuation">&#125;</span>:源文件

<span class="token comment">### 同时构建静态和动态库</span>

```cmake
// 如果用这种方式，只会构建一个动态库，不会构建出静态库，虽然静态库的后缀是.a
<span class="token keyword">add_library</span><span class="token punctuation">(</span>hello <span class="token namespace">SHARED</span> <span class="token punctuation">$&#123;</span>LIBHELLO_SRC<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token keyword">add_library</span><span class="token punctuation">(</span>hello <span class="token namespace">STATIC</span> <span class="token punctuation">$&#123;</span>LIBHELLO_SRC<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

// 修改静态库的名字，这样是可以的，但是我们往往希望他们的名字是相同的，只是后缀不同而已
<span class="token keyword">add_library</span><span class="token punctuation">(</span>hello <span class="token namespace">SHARED</span> <span class="token punctuation">$&#123;</span>LIBHELLO_SRC<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token keyword">add_library</span><span class="token punctuation">(</span>hello_static <span class="token namespace">STATIC</span> <span class="token punctuation">$&#123;</span>LIBHELLO_SRC<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<h3 id="set-target-properties"><a href="#set-target-properties" class="headerlink" title="set_target_properties"></a>set_target_properties</h3><p>这条指令可以用来设置输出的名称，对于动态库，还可以用来指定动态库版本和 API 版本</p>
<p>同时构建静态和动态库</p>
<pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">set</span><span class="token punctuation">(</span>LIBHELLO_SRC hello.cpp<span class="token punctuation">)</span>

<span class="token keyword">add_library</span><span class="token punctuation">(</span>hello_static <span class="token namespace">STATIC</span> <span class="token punctuation">$&#123;</span>LIBHELLO_SRC<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

//对hello_static的重名为hello
<span class="token keyword">set_target_properties</span><span class="token punctuation">(</span>hello_static <span class="token namespace">PROPERTIES</span>  <span class="token property">OUTPUT_NAME</span> <span class="token string">"hello"</span><span class="token punctuation">)</span>
//cmake 在构建一个新的target 时，会尝试清理掉其他使用这个名字的库，因为，在构建 libhello.so 时， 就会清理掉 libhello.a
<span class="token keyword">set_target_properties</span><span class="token punctuation">(</span>hello_static <span class="token namespace">PROPERTIES</span> CLEAN_DIRECT_OUTPUT <span class="token number">1</span><span class="token punctuation">)</span>
//CLEAN_DIRECT_OUTPUT 部分用于指示在生成具有相同名字的（<span class="token property">OUTPUT_NAME</span>）的目标时，是否清理上次生成的内容

<span class="token keyword">add_library</span><span class="token punctuation">(</span>hello <span class="token namespace">SHARED</span> <span class="token punctuation">$&#123;</span>LIBHELLO_SRC<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

<span class="token keyword">set_target_properties</span><span class="token punctuation">(</span>hello <span class="token namespace">PROPERTIES</span> <span class="token property">OUTPUT_NAME</span> <span class="token string">"hello"</span><span class="token punctuation">)</span>
<span class="token keyword">set_target_properties</span><span class="token punctuation">(</span>hello <span class="token namespace">PROPERTIES</span> CLEAN_DIRECT_OUTPUT <span class="token number">1</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="动态库的版本号"><a href="#动态库的版本号" class="headerlink" title="动态库的版本号"></a>动态库的版本号</h3><p>一般动态库都有一个版本号的关联</p>
<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">libhello.so.1.2
libhello.so ->libhello.so.1
libhello.so.1->libhello.so.1.2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>CMakeLists.txt 插入如下</p>
<p><code>set_target_properties(hello PROPERTIES VERSION 1.2 SOVERSION 1)</code></p>
<p>VERSION 指代动态库版本，SOVERSION 指代 API 版本。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>使用INSTALL指令，可以将二进制、动态库、静态库以及文件、目录、脚本等安装到系统目录下<br><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">install</span><span class="token punctuation">(</span>TARGETS &lt;target<span class="token punctuation">></span>... [...]<span class="token punctuation">)</span>
<span class="token keyword">install</span><span class="token punctuation">(</span>&#123;FILES | PROGRAMS<span class="token punctuation">&#125;</span> &lt;file<span class="token punctuation">></span>... [...]<span class="token punctuation">)</span>
<span class="token keyword">install</span><span class="token punctuation">(</span>DIRECTORY &lt;dir<span class="token punctuation">></span>... [...]<span class="token punctuation">)</span>
<span class="token keyword">install</span><span class="token punctuation">(</span>SCRIPT &lt;file<span class="token punctuation">></span> [...]<span class="token punctuation">)</span>
<span class="token keyword">install</span><span class="token punctuation">(</span>CODE &lt;code<span class="token punctuation">></span> [...]<span class="token punctuation">)</span>
<span class="token keyword">install</span><span class="token punctuation">(</span>EXPORT &lt;export-name<span class="token punctuation">></span> [...]<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<h1 id="QT-amp-CMake"><a href="#QT-amp-CMake" class="headerlink" title="QT &amp; CMake"></a>QT &amp; CMake</h1><p><strong><em>CMakeLists.txt</em></strong><br><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.5.1</span><span class="token punctuation">)</span>
<span class="token keyword">project</span><span class="token punctuation">(</span>qui<span class="token punctuation">)</span>

如果不是用QT Creator开发，需要设置QT路径
<span class="token keyword">set</span><span class="token punctuation">(</span>Qt5_DIR <span class="token string">"D:/qt5/5.12.9/msvc2017_64/lib/cmake/Qt5"</span><span class="token punctuation">)</span>

<span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_INCLUDE_CURRENT_DIR</span> <span class="token boolean">ON</span><span class="token punctuation">)</span>
<span class="token comment"># QT特有的编译器，需要打开</span>
<span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_AUTOUIC</span> <span class="token boolean">ON</span><span class="token punctuation">)</span>
<span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_AUTOMOC</span> <span class="token boolean">ON</span><span class="token punctuation">)</span>
<span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_AUTORCC</span> <span class="token boolean">ON</span><span class="token punctuation">)</span>

<span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_CXX_STANDARD</span> <span class="token number">11</span><span class="token punctuation">)</span>
<span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_CXX_STANDARD_REQUIRED</span> <span class="token boolean">ON</span><span class="token punctuation">)</span>

<span class="token comment">#FIND_PACKAGE(Qt5 COMPONENTS Core Gui Qml Quick Widgets REQUIRED)</span>
<span class="token function">FIND_PACKAGE</span><span class="token punctuation">(</span>Qt5 COMPONENTS Widgets REQUIRED<span class="token punctuation">)</span>
<span class="token comment"># 自动寻找QT5，REQUIRED表示没找到不继续下去</span>

<span class="token comment">#源文件</span>
<span class="token function">SET</span><span class="token punctuation">(</span>qui_SOURCES 
	src/main.cpp 
	src/mainwindow.cpp 
<span class="token punctuation">)</span>

<span class="token comment">#头文件</span>
<span class="token function">SET</span><span class="token punctuation">(</span>qui_HEADERS 
	src/mainwindow.h
<span class="token punctuation">)</span>

<span class="token comment">#ui文件</span>
<span class="token function">SET</span><span class="token punctuation">(</span>qui_FORMS 
	src/mainwindow.ui
<span class="token punctuation">)</span>

qrc文件
<span class="token comment">#SET(qui_RESOURCES </span>
<span class="token comment">#	img.qrc</span>
<span class="token comment">#)</span>

<span class="token comment">#调用预编译器moc，需要使用 QT5_WRAP_CPP宏</span>
<span class="token function">QT5_WRAP_CPP</span><span class="token punctuation">(</span>qui_HEADERS_MOC <span class="token punctuation">$&#123;</span>qui_HEADERS<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

<span class="token comment">#使用uic处理.ui文件</span>
<span class="token function">QT5_WRAP_UI</span><span class="token punctuation">(</span>qui_FORMS_HEADERS <span class="token punctuation">$&#123;</span>qui_FORMS<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

<span class="token comment">#使用rcc处理.qrc文件</span>
<span class="token comment">#QT5_ADD_RESOURCES(qui_RESOURCES_RCC $&#123;qui_RESOURCES&#125;)</span>

<span class="token comment">#这些生成的中间文件都会在build目录下，这样的话，编译器则不能定位由uic程序产生的诸如_ui_mainwindow.h等文件。所以，我们需要把build目录添加到包含目录中</span>
<span class="token property">INCLUDE_DIRECTORIES</span><span class="token punctuation">(</span><span class="token punctuation">$&#123;</span><span class="token variable">CMAKE_CURRENT_BINARY_DIR</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

<span class="token comment">#生成可执行文件</span>
<span class="token function">ADD_EXECUTABLE</span><span class="token punctuation">(</span>qui 
	<span class="token punctuation">$&#123;</span>qui_SOURCES<span class="token punctuation">&#125;</span> 
	<span class="token punctuation">$&#123;</span>qui_HEADERS_MOC<span class="token punctuation">&#125;</span> 
    <span class="token punctuation">$&#123;</span>qui_FORMS_HEADERS<span class="token punctuation">&#125;</span>
	<span class="token comment">#$&#123;qui_RESOURCES_RCC&#125; </span>
<span class="token punctuation">)</span>

<span class="token comment">#为target添加需要链接的共享库</span>
<span class="token comment">#TARGET_LINK_LIBRARIES(qui Qt5::Core Qt5::Gui Qt5::Qml Qt5::Quick $&#123;Qt5Widgets_LIBRARIES&#125;)</span>
<span class="token function">TARGET_LINK_LIBRARIES</span><span class="token punctuation">(</span>qui <span class="token punctuation">$&#123;</span>Qt5Widgets_LIBRARIES<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token function">INSTALL</span><span class="token punctuation">(</span>TARGETS qui
    RUNTIME DESTINATION lib
    LIBRARY DESTINATION lib
    ARCHIVE DESTINATION lib
<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
]]></content>
      <tags>
        <tag>CMAKE</tag>
      </tags>
  </entry>
  <entry>
    <title>Manacher</title>
    <url>/2022/11/29/Manacher/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">        

<p>​    给定一个字符串<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="13.294ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 5876 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(529,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(958,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(1387,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mi" transform="translate(1820,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(2249,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(2678,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(3107,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mi" transform="translate(3540,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(3969,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(4398,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(4827,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(5356,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g></g></g></svg></mjx-container>，求该字符串的最长回文子串的长度。</p>
<h3 id="暴力匹配"><a href="#暴力匹配" class="headerlink" title="暴力匹配"></a>暴力匹配</h3><p>​        两个<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="3.362ex" height="2.059ex" role="img" focusable="false" viewBox="0 -705 1486 910"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mi" transform="translate(550,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mi" transform="translate(1035,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container>循环遍历所有子串，再判断所有子串是否回文，再通过比较获取最长回文子串长度，算法复杂度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="6.606ex" height="2.451ex" role="img" focusable="false" viewBox="0 -833.2 2919.8 1083.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mn" transform="translate(975.3,363) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g></g><g data-mml-node="mo" transform="translate(2530.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202212212100439.png" alt="image-20221221210004388"></p>
<span id="more"></span>
<h3 id="朴素算法"><a href="#朴素算法" class="headerlink" title="朴素算法"></a>朴素算法</h3><p>​        先遍历一遍字符串，对于每个 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewBox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container>，以它作为字符串的中心向字符串两边扩展，在遍历获得子串的同时完成对是否回文的判断，这样就将时间复杂度优化到了 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="6.606ex" height="2.452ex" role="img" focusable="false" viewBox="0 -833.9 2919.8 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mn" transform="translate(975.3,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(2530.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>，需要分别计算奇数串和偶数串</p>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202212212100576.png" alt="202211291956549"></p>
<h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int mmax=0;
for(int i=0;i&lt;len;++i){
    int d1=1,d2=0;
    //奇数串
    for(int j=1;j&lt;std::min(i,len);++j){
        if(str[i-j]!=str[i+j]) return;
        d1+=2;
	}  
    //偶数串
    for(int j=0;j&lt;std::min(i,len-i-1);++j){
        if(str[i-j]!=str[i+1+j]) return;
        d2+=2;
    }
    mmax=std::max(mmax,std::max(d1,d2));
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h3><h4 id="奇数串"><a href="#奇数串" class="headerlink" title="奇数串"></a>奇数串</h4><p>我们先定义：</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="3.215ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 1421 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mo" transform="translate(520,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(798,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1143,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g></g></g></svg></mjx-container>：表示以 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewBox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container> 为中心的最长回文子串的长度</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="6.244ex" height="2.009ex" role="img" focusable="false" viewBox="0 -694 2759.7 888"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(878,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(1450,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(1894.7,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(2239.7,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g></g></g></svg></mjx-container>：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="3.281ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 1450 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(878,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g></g></g></svg></mjx-container> 就是以 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.957ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 865 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(345,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g></g></g></svg></mjx-container> 为中心的最右回文边界，即 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="21.559ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 9529 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(878,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(1727.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(2783.6,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(3661.6,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(4190.6,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(4762.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(5151.6,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(5718.8,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(6719,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mo" transform="translate(7239,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(7517,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(7862,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(8140,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path></g></g><g data-mml-node="mn" transform="translate(8640,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(9140,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="5.755ex" height="1.756ex" role="img" focusable="false" viewBox="0 -694 2543.6 776"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(345,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mo" transform="translate(1142.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(2198.6,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></p>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202212212101292.png" alt="202211291950905"></p>
<p>我们继续遍历字符串，当 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.09ex;" xmlns="http://www.w3.org/2000/svg" width="7.078ex" height="1.586ex" role="img" focusable="false" viewBox="0 -661 3128.6 701"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(622.8,0)"><path data-c="3C" d="M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z"></path></g><g data-mml-node="mi" transform="translate(1678.6,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(2556.6,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g></g></g></svg></mjx-container> 时，我们可以发现一个 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.462ex;" xmlns="http://www.w3.org/2000/svg" width="0.932ex" height="1.957ex" role="img" focusable="false" viewBox="0 -661 412 865"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g></g></g></svg></mjx-container> 与 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewBox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container> 关于 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.957ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 865 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(345,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g></g></g></svg></mjx-container> 对称</p>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202212212105286.png" alt="202211291950954"></p>
<p>此时，我们可以发现，<strong>在 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.391ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 1941 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mo" transform="translate(520,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(798,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1143,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mo" transform="translate(1663,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g></g></g></svg></mjx-container> 的范围内</strong>，任何以 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.462ex;" xmlns="http://www.w3.org/2000/svg" width="0.932ex" height="1.957ex" role="img" focusable="false" viewBox="0 -661 412 865"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g></g></g></svg></mjx-container> 为中心的子串，都可以找到一个以 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewBox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container> 为中心的子串与它相反（<del>因为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewBox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container> 和 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.462ex;" xmlns="http://www.w3.org/2000/svg" width="0.932ex" height="1.957ex" role="img" focusable="false" viewBox="0 -661 412 865"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g></g></g></svg></mjx-container> 关于 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.957ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 865 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(345,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g></g></g></svg></mjx-container> 对称，且 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.391ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 1941 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mo" transform="translate(520,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(798,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1143,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mo" transform="translate(1663,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g></g></g></svg></mjx-container> 是回文串</del>），而又因为回文串是以中心对称的，即：</p>
<p><strong>任何以 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.462ex;" xmlns="http://www.w3.org/2000/svg" width="0.932ex" height="1.957ex" role="img" focusable="false" viewBox="0 -661 412 865"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g></g></g></svg></mjx-container> 为中心的回文子串，都可以找到一个以 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewBox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container> 为中心的子串与它相等</strong></p>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202212212106854.png" alt="202211291951492"></p>
<p>所以，以 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewBox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container> 为中心的最长回文子串的长度至少为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="26.009ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 11496 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(878,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1223,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1823,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(2212,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mo" transform="translate(2732,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(3010,0)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g><g data-mml-node="mo" transform="translate(3422,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(3700,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mn" transform="translate(4144.7,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(4866.9,0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path></g><g data-mml-node="mo" transform="translate(5589.1,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(5978.1,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(6856.1,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(7650.3,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(8650.6,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(8995.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(9606.8,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(10607,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(11107,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>，接下来再利用朴素算法来对超过 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="3.281ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 1450 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(878,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g></g></g></svg></mjx-container> 的部分进行判断</p>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202212212106297.png" alt="202211291951801"></p>
<p>最后，再更新 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.957ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 865 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(345,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g></g></g></svg></mjx-container> 和 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="3.281ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 1450 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(878,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g></g></g></svg></mjx-container></p>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202212212106908.png" alt="202211291951303"></p>
<h5 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::vector&lt;int&gt; odd;
int id=0,mx=0,mmax=0;
for(int i=0;i&lt;len;++i){
    //回文半径
	int k=(i&gt;mx) ? 1 : std::min(odd[2*id-i]/2,mx-i);
    while(0&lt;=i-k &amp;&amp; i+k&lt;len &amp;&amp; str[i-k]==str[i+k]) ++k;
    --k;
    odd[i]=2*k+1;
    mmax=std::max(mmax,odd[i]);
    if(i+k&gt;mx){
		id=i;
        mx=i+k;
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="偶数串"><a href="#偶数串" class="headerlink" title="偶数串"></a>偶数串</h4><p>偶数部分只需要对奇数的代码做一点修改即可</p>
<h5 id="代码实现：-2"><a href="#代码实现：-2" class="headerlink" title="代码实现："></a>代码实现：</h5><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">std::vector&lt;int&gt; even;
int id=0,mx=0,mmax=0;
for(int i=0;i&lt;len;++i){
    //回文半径
	int k=(i&gt;mx) ? 0 : std::min(even[2*id-i+1]/2,mx-i);
    while(0&lt;=i-k &amp;&amp; i+1+k&lt;len &amp;&amp; str[i-k]==str[i+1+k]) ++k;
    even[i]=2*k;
    mmax=std::max(mmax,even[i]);
    if(i+k&gt;mx){
		id=i;
        mx=i+k;
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><p>在前面我们都是将奇数串和偶数串分开来算，实际上我们可以通过插入无意义的符号来使二者都统一为奇数串。</p>
<p>对于前面给定的字符串 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="13.294ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 5876 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(529,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(958,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(1387,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mi" transform="translate(1820,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(2249,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(2678,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(3107,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mi" transform="translate(3540,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(3969,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(4398,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(4827,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(5356,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g></g></g></svg></mjx-container> ，我们插入 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.983ex" height="1.756ex" role="img" focusable="false" viewBox="0 -694 3086.4 776"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(298,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(764,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1586.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(2586.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container> 个分隔符 #，使字符串变成 #a#b#b#c#b#b#b#c#b#b#b#a#d#，这样所有的子串的长度都为奇数了，最后除以2就是真正子串的长度了。</p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ul>
<li><a href="https://www.luogu.com.cn/problem/P1659">P1659 [国家集训队]拉拉队排练</a> </li>
<li><a href="https://www.luogu.com.cn/problem/P3501">P3501[POI2010]ANT-Antisymmetry</a> </li>
<li><a href="https://www.luogu.com.cn/problem/UVA11475">UVA11475 Extend to Palindrome</a> </li>
<li><a href="https://www.luogu.com.cn/problem/P6216">P6216 回文匹配</a> </li>
<li><a href="https://www.luogu.com.cn/problem/P4555">P4555[国家集训队]最长双回文串 </a> </li>
<li><a href="https://www.luogu.com.cn/problem/P5446">P5446 [THUPC2018]绿绿和串串</a> </li>
</ul>
]]></content>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>定时器</title>
    <url>/2023/11/29/8-%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">    



<ul>
<li>两种高效的管理定时器的容器<ul>
<li>时间轮</li>
<li>时间堆</li>
</ul>
</li>
</ul>
<span id="more"></span>
<ul>
<li>定时<ul>
<li>定时是指在一段时间之后触发某段代码的机制，可以在这段代码中依次处理所有到期的定时器</li>
</ul>
</li>
<li>Linux提供了三种定时方法<ul>
<li>socket选项SO_RCVTIMEO和SO_SNDTIMEO</li>
<li>SIGALRM信号</li>
<li>I/O复用系统调用的超时参数</li>
</ul>
</li>
</ul>
<h2 id="socket选项SO-RCVTIMEO和SO-SNDTIMEO"><a href="#socket选项SO-RCVTIMEO和SO-SNDTIMEO" class="headerlink" title="socket选项SO_RCVTIMEO和SO_SNDTIMEO"></a>socket选项SO_RCVTIMEO和SO_SNDTIMEO</h2><p><strong>SO_RCVTIMEO和SO_SNDTIMEO</strong></p>
<ul>
<li>SO_RCVTIMEO设置socket接收数据超时时间</li>
<li>SO_SNDTIMEO设置socket发送数据超时时间</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202401101310929.png" alt="image-20240110131049770"></li>
</ul>
<hr>
<p><strong>设置connect超时时间</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netinet/in.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;errno.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>

<span class="token comment">/*超时连接函数*/</span>
<span class="token keyword">int</span> <span class="token function">timeout_connect</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span>ip<span class="token punctuation">,</span><span class="token keyword">int</span> port<span class="token punctuation">,</span><span class="token keyword">int</span> time<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> ret<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> address<span class="token punctuation">;</span>
	<span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	address<span class="token punctuation">.</span>sin_family<span class="token operator">=</span>AF_INET<span class="token punctuation">;</span>
	<span class="token function">inet_pton</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span>ip<span class="token punctuation">,</span><span class="token operator">&amp;</span>address<span class="token punctuation">.</span>sin_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	address<span class="token punctuation">.</span>sin_port<span class="token operator">=</span><span class="token function">htons</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> sockfd<span class="token operator">=</span><span class="token function">socket</span><span class="token punctuation">(</span>PF_INET<span class="token punctuation">,</span>SOCK_STREAM<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>sockfd<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">/*通过选项SO_RCVTIMEO和SO_SNDTIMEO所设置的超时时间的类型是timeval，这和select系统调用的超时参数类型相同*/</span>
    <span class="token keyword">struct</span> <span class="token class-name">timeval</span> timeout<span class="token punctuation">;</span>
	timeout<span class="token punctuation">.</span>tv_sec<span class="token operator">=</span>time<span class="token punctuation">;</span>
	timeout<span class="token punctuation">.</span>tv_usec<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token class-name">socklen_t</span> len<span class="token operator">=</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//设置发送超时</span>
	ret<span class="token operator">=</span><span class="token function">setsockopt</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span>SOL_SOCKET<span class="token punctuation">,</span>SO_SNDTIMEO<span class="token punctuation">,</span><span class="token operator">&amp;</span>timeout<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>ret<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	ret<span class="token operator">=</span><span class="token function">connect</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token comment">/*超时对应的错误号是EINPROGRESS。下面这个条件如果成立，我们就可以处理定时任务了*/</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>errno<span class="token operator">==</span>EINPROGRESS<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"connecting timeout,process timeout logic\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"error occur when connecting to server\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> sockfd<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span><span class="token keyword">char</span><span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>argc<span class="token operator">&lt;=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"usage:%s ip_address port_number\n"</span><span class="token punctuation">,</span><span class="token function">basename</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> ip<span class="token operator">=</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> port<span class="token operator">=</span><span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> sockfd<span class="token operator">=</span><span class="token function">timeout_connect</span><span class="token punctuation">(</span>ip<span class="token punctuation">,</span>port<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>sockfd<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="SIGALRM信号"><a href="#SIGALRM信号" class="headerlink" title="SIGALRM信号"></a>SIGALRM信号</h2><h3 id="基于升序链表的定时器"><a href="#基于升序链表的定时器" class="headerlink" title="基于升序链表的定时器"></a>基于升序链表的定时器</h3><p>定时器通常至少要包含两个成员：一个超时时间和一个任务回调函数，有的时候还可能包含任务回调函数被执行时需要传入的参数，以及是否重启定时器等信息。如果使用链表作为容器来串联所有的定时器，则每个定时器还需要包含指向下一个定时器的指针成员。</p>
<hr>
<p><strong>一个简单的升序定时器链表—按照定时器超时时间作升序</strong></p>
<p>~全是关于双向链表的知识~</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BUFFER_SIZE</span> <span class="token expression"><span class="token number">64</span></span></span>
class util_timer<span class="token punctuation">;</span><span class="token comment">/*前向声明*/</span>

<span class="token comment">/*用户数据结构：客户端socket地址、socket文件描述符、读缓存和定时器*/</span>
<span class="token keyword">struct</span> <span class="token class-name">client_data</span><span class="token punctuation">{</span>
	sockaddr_in address<span class="token punctuation">;</span>
	<span class="token keyword">int</span> sockfd<span class="token punctuation">;</span>
	<span class="token keyword">char</span> buf<span class="token punctuation">[</span>BUFFER_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
	util_timer<span class="token operator">*</span> timer<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">/*定时器类*/</span>
class util_timer<span class="token punctuation">{</span>
public<span class="token operator">:</span>
    <span class="token function">util_timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">prev</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
public<span class="token operator">:</span>
	<span class="token class-name">time_t</span> expire<span class="token punctuation">;</span><span class="token comment">/*任务的超时时间，这里使用绝对时间*/</span>
	<span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span>cb_func<span class="token punctuation">)</span><span class="token punctuation">(</span>client_data<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*任务回调函数*/</span>
	<span class="token comment">/*回调函数处理的客户数据，由定时器的执行者传递给回调函数*/</span>
	client_data<span class="token operator">*</span> user_data<span class="token punctuation">;</span>
	util_timer<span class="token operator">*</span> prev<span class="token punctuation">;</span><span class="token comment">/*指向前一个定时器*/</span>
	util_timer<span class="token operator">*</span> next<span class="token punctuation">;</span><span class="token comment">/*指向下一个定时器*/</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">/*定时器链表。它是一个升序、双向链表，且带有头结点和尾节点*/</span>
class sort_timer_lst<span class="token punctuation">{</span>
public<span class="token operator">:</span>
	<span class="token function">sort_timer_lst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">head</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">tail</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
	<span class="token comment">/*链表被销毁时，删除其中所有的定时器*/</span>
	～<span class="token function">sort_timer_lst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		util_timer<span class="token operator">*</span> tmp<span class="token operator">=</span>head<span class="token punctuation">;</span>
		<span class="token keyword">while</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">{</span>
            head<span class="token operator">=</span>tmp<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
            delete tmp<span class="token punctuation">;</span>
            tmp<span class="token operator">=</span>head<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
	<span class="token comment">/*将目标定时器timer添加到链表中*/</span>
	<span class="token keyword">void</span> <span class="token function">add_timer</span><span class="token punctuation">(</span>util_timer<span class="token operator">*</span> timer<span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>timer<span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>head<span class="token punctuation">)</span><span class="token punctuation">{</span>
            head<span class="token operator">=</span>tail<span class="token operator">=</span>timer<span class="token punctuation">;</span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">/*如果目标定时器的超时时间小于当前链表中所有定时器的超时时间，则把该定时器插入链表头部，作为链表新的头节点。否则就需要调用重载函数add_timer(util_timer*timer,util_timer*lst_head)，把它插入链表中合适的位置，以保证链表的升序特性*/</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>timer<span class="token operator">-&gt;</span>expire<span class="token operator">&lt;</span>head<span class="token operator">-&gt;</span>expire<span class="token punctuation">)</span><span class="token punctuation">{</span>
			timer<span class="token operator">-&gt;</span>next<span class="token operator">=</span>head<span class="token punctuation">;</span>
			head<span class="token operator">-&gt;</span>prev<span class="token operator">=</span>timer<span class="token punctuation">;</span>
			head<span class="token operator">=</span>timer<span class="token punctuation">;</span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
		<span class="token function">add_timer</span><span class="token punctuation">(</span>timer<span class="token punctuation">,</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token comment">/*当某个定时任务发生变化时，调整对应的定时器在链表中的位置。这个函数只考虑被调整的定时器的超时时间延长的情况，即该定时器需要往链表的尾部移动*/</span>
	<span class="token keyword">void</span> <span class="token function">adjust_timer</span><span class="token punctuation">(</span>util_timer<span class="token operator">*</span> timer<span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>timer<span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		util_timer<span class="token operator">*</span>tmp<span class="token operator">=</span>timer<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		<span class="token comment">/*如果被调整的目标定时器处在链表尾部，或者该定时器新的超时值仍然小于其下一个定时器的超时值，则不用调整*/</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>tmp<span class="token operator">||</span><span class="token punctuation">(</span>timer<span class="token operator">-&gt;</span>expire<span class="token operator">&lt;</span>tmp<span class="token operator">-&gt;</span>expire<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">/*如果目标定时器是链表的头节点，则将该定时器从链表中取出并重新插入链表*/</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>timer<span class="token operator">==</span>head<span class="token punctuation">)</span><span class="token punctuation">{</span>
            head<span class="token operator">=</span>head<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
            head<span class="token operator">-&gt;</span>prev<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
            timer<span class="token operator">-&gt;</span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
			<span class="token function">add_timer</span><span class="token punctuation">(</span>timer<span class="token punctuation">,</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">/*如果目标定时器不是链表的头节点，则将该定时器从链表中取出，然后插入其原来所在位置之后的部分链表中*/</span>
		<span class="token keyword">else</span><span class="token punctuation">{</span>
            timer<span class="token operator">-&gt;</span>prev<span class="token operator">-&gt;</span>next<span class="token operator">=</span>timer<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
            timer<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>prev<span class="token operator">=</span>timer<span class="token operator">-&gt;</span>prev<span class="token punctuation">;</span>
			<span class="token function">add_timer</span><span class="token punctuation">(</span>timer<span class="token punctuation">,</span>timer<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
	<span class="token comment">/*将目标定时器timer从链表中删除*/</span>
	<span class="token keyword">void</span> <span class="token function">del_timer</span><span class="token punctuation">(</span>util_timer<span class="token operator">*</span> timer<span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>timer<span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">/*下面这个条件成立表示链表中只有一个定时器，即目标定时器*/</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>timer<span class="token operator">==</span>head<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>timer<span class="token operator">==</span>tail<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			delete timer<span class="token punctuation">;</span>
			head<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
			tail<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
		<span class="token comment">//如果链表中至少有两个定时器，且目标定时器是链表的头结点，则将链表的头结点重置为原头节点的下一个节点，然后删除目标定时器</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>timer<span class="token operator">==</span>head<span class="token punctuation">)</span><span class="token punctuation">{</span>
            head<span class="token operator">=</span>head<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
            head<span class="token operator">-&gt;</span>prev<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
            delete timer<span class="token punctuation">;</span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//如果链表中至少有两个定时器，且目标定时器是链表的尾结点，则将链表的尾结点重置为原尾节点的前一个节点，然后删除目标定时器</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>timer<span class="token operator">==</span>tail<span class="token punctuation">)</span><span class="token punctuation">{</span>
            tail<span class="token operator">=</span>tail<span class="token operator">-&gt;</span>prev<span class="token punctuation">;</span>
            tail<span class="token operator">-&gt;</span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
            delete timer<span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">/*如果目标定时器位于链表的中间，则把它前后的定时器串联起来，然后删除目标定时器*/</span>
        timer<span class="token operator">-&gt;</span>prev<span class="token operator">-&gt;</span>next<span class="token operator">=</span>timer<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        timer<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>prev<span class="token operator">=</span>timer<span class="token operator">-&gt;</span>prev<span class="token punctuation">;</span>
        delete timer<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">/*SIGALRM信号每次被触发就在其信号处理函数（如果使用统一事件源，则是主函数）中执行一次tick函数，以处理链表上到期的任务*/</span>
	<span class="token keyword">void</span> <span class="token function">tick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>head<span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"timer tick\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">time_t</span> cur<span class="token operator">=</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*获得系统当前的时间*/</span>
		util_timer<span class="token operator">*</span> tmp<span class="token operator">=</span>head<span class="token punctuation">;</span>
		<span class="token comment">/*从头结点开始依次处理每个定时器，直到遇到一个尚未到期的定时器，这就是定时器的核心逻辑*/</span>
		<span class="token keyword">while</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token comment">/*因为每个定时器都使用绝对时间作为超时值，所以我们可以把定时器的超时值和系统当前时间，比较以判断定时器是否到期*/</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">&lt;</span>tmp<span class="token operator">-&gt;</span>expire<span class="token punctuation">)</span><span class="token punctuation">{</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token comment">/*调用定时器的回调函数，以执行定时任务*/</span>
			tmp<span class="token operator">-&gt;</span><span class="token function">cb_func</span><span class="token punctuation">(</span>tmp<span class="token operator">-&gt;</span>user_data<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">/*执行完定时器中的定时任务之后，就将它从链表中删除，并重置链表头结点*/</span>
			head<span class="token operator">=</span>tmp<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">{</span>
            	head<span class="token operator">-&gt;</span>prev<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
			delete tmp<span class="token punctuation">;</span>
			tmp<span class="token operator">=</span>head<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
private<span class="token operator">:</span>
<span class="token comment">/*一个重载的辅助函数，它被公有的add_timer函数和adjust_timer函数调用。该函数表示将目标定时器timer添加到节点lst_head之后的部分链表中*/</span>
	<span class="token keyword">void</span> <span class="token function">add_timer</span><span class="token punctuation">(</span>util_timer<span class="token operator">*</span> timer<span class="token punctuation">,</span>util_timer<span class="token operator">*</span> lst_head<span class="token punctuation">)</span><span class="token punctuation">{</span>
        util_timer<span class="token operator">*</span> prev<span class="token operator">=</span>lst_head<span class="token punctuation">;</span>
        util_timer<span class="token operator">*</span> tmp<span class="token operator">=</span>prev<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		<span class="token comment">/*遍历lst_head节点之后的部分链表，直到找到一个超时时间大于目标定时器的超时时间的节点，并将目标定时器插入该节点之前*/</span>
		<span class="token keyword">while</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>timer<span class="token operator">-&gt;</span>expire<span class="token operator">&lt;</span>tmp<span class="token operator">-&gt;</span>expire<span class="token punctuation">)</span><span class="token punctuation">{</span>
                prev<span class="token operator">-&gt;</span>next<span class="token operator">=</span>timer<span class="token punctuation">;</span>
                timer<span class="token operator">-&gt;</span>next<span class="token operator">=</span>tmp<span class="token punctuation">;</span>
                tmp<span class="token operator">-&gt;</span>prev<span class="token operator">=</span>timer<span class="token punctuation">;</span>
                timer<span class="token operator">-&gt;</span>prev<span class="token operator">=</span>prev<span class="token punctuation">;</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
			prev<span class="token operator">=</span>tmp<span class="token punctuation">;</span>
			tmp<span class="token operator">=</span>tmp<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">/*如果遍历完lst_head节点之后的部分链表，仍未找到超时时间大于目标定时器的超时时间的节点，则将目标定时器插入链表尾部，并把它设置为链表新的尾节点*/</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>tmp<span class="token punctuation">)</span><span class="token punctuation">{</span>
            prev<span class="token operator">-&gt;</span>next<span class="token operator">=</span>timer<span class="token punctuation">;</span>
            timer<span class="token operator">-&gt;</span>prev<span class="token operator">=</span>prev<span class="token punctuation">;</span>
            timer<span class="token operator">-&gt;</span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
            tail<span class="token operator">=</span>timer<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
private<span class="token operator">:</span>
    util_timer<span class="token operator">*</span> head<span class="token punctuation">;</span>
    util_timer<span class="token operator">*</span> tail<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="处理非活动连接"><a href="#处理非活动连接" class="headerlink" title="处理非活动连接"></a>处理非活动连接</h3><p>服务器程序通常要定期处理非活动连接：给客户端发一个重连请求，或者关闭该连接，或者其他。</p>
<hr>
<p><strong>关闭非活动连接</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netinet/in.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;errno.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/epoll.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"lst_timer.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FD_LIMIT</span> <span class="token expression"><span class="token number">65535</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_EVENT_NUMBER</span> <span class="token expression"><span class="token number">1024</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TIMESLOT</span> <span class="token expression"><span class="token number">5</span></span></span>
<span class="token keyword">static</span> <span class="token keyword">int</span> pipefd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">/*利用升序链表来管理定时器*/</span>
<span class="token keyword">static</span> sort_timer_lst timer_lst<span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> epollfd<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">setnonblocking</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> old_option<span class="token operator">=</span><span class="token function">fcntl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>F_GETFL<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> new_option<span class="token operator">=</span>old_option<span class="token operator">|</span>O_NONBLOCK<span class="token punctuation">;</span>
	<span class="token function">fcntl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>F_SETFL<span class="token punctuation">,</span>new_option<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> old_option<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">addfd</span><span class="token punctuation">(</span><span class="token keyword">int</span> epollfd<span class="token punctuation">,</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">{</span>
    epoll_event event<span class="token punctuation">;</span>
    event<span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd<span class="token operator">=</span>fd<span class="token punctuation">;</span>
    event<span class="token punctuation">.</span>events<span class="token operator">=</span>EPOLLIN<span class="token operator">|</span>EPOLLET<span class="token punctuation">;</span>
    <span class="token function">epoll_ctl</span><span class="token punctuation">(</span>epollfd<span class="token punctuation">,</span>EPOLL_CTL_ADD<span class="token punctuation">,</span>fd<span class="token punctuation">,</span><span class="token operator">&amp;</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setnonblocking</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">sig_handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> save_errno<span class="token operator">=</span>errno<span class="token punctuation">;</span>
    <span class="token keyword">int</span> msg<span class="token operator">=</span>sig<span class="token punctuation">;</span>
    <span class="token function">send</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>msg<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    errno<span class="token operator">=</span>save_errno<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">addsig</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">struct</span> <span class="token class-name">sigaction</span> sa<span class="token punctuation">;</span>
	<span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sa<span class="token punctuation">,</span><span class="token char">'\0'</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>sa<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    sa<span class="token punctuation">.</span>sa_handler<span class="token operator">=</span>sig_handler<span class="token punctuation">;</span>
    sa<span class="token punctuation">.</span>sa_flags<span class="token operator">|=</span>SA_RESTART<span class="token punctuation">;</span> <span class="token comment">//重新调用被该信号终止的系统调用</span>
	<span class="token function">sigfillset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sa<span class="token punctuation">.</span>sa_mask<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//在信号集中设置所有信号</span>
	<span class="token function">assert</span><span class="token punctuation">(</span><span class="token function">sigaction</span><span class="token punctuation">(</span>sig<span class="token punctuation">,</span><span class="token operator">&amp;</span>sa<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">timer_handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token comment">/*定时处理任务，实际上就是调用tick函数*/</span>
	timer_lst<span class="token punctuation">.</span><span class="token function">tick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">/*因为一次alarm调用只会引起一次SIGALRM信号，所以我们要重新定时，以不断触发SIGALRM信号*/</span>
	<span class="token function">alarm</span><span class="token punctuation">(</span>TIMESLOT<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*定时器回调函数，它删除非活动连接socket上的注册事件，并关闭之*/</span>
<span class="token keyword">void</span> <span class="token function">cb_func</span><span class="token punctuation">(</span>client_data<span class="token operator">*</span> user_data<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token function">epoll_ctl</span><span class="token punctuation">(</span>epollfd<span class="token punctuation">,</span>EPOLL_CTL_DEL<span class="token punctuation">,</span>user_data<span class="token operator">-&gt;</span>sockfd<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>user_data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>user_data<span class="token operator">-&gt;</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"close fd%d\n"</span><span class="token punctuation">,</span>user_data<span class="token operator">-&gt;</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>argc<span class="token operator">&lt;=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"usage:%s ip_address port_number\n"</span><span class="token punctuation">,</span><span class="token function">basename</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> ip<span class="token operator">=</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> port<span class="token operator">=</span><span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> ret<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> address<span class="token punctuation">;</span>
	<span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	address<span class="token punctuation">.</span>sin_family<span class="token operator">=</span>AF_INET<span class="token punctuation">;</span>
	<span class="token function">inet_pton</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span>ip<span class="token punctuation">,</span><span class="token operator">&amp;</span>address<span class="token punctuation">.</span>sin_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	address<span class="token punctuation">.</span>sin_port<span class="token operator">=</span><span class="token function">htons</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> listenfd<span class="token operator">=</span><span class="token function">socket</span><span class="token punctuation">(</span>PF_INET<span class="token punctuation">,</span>SOCK_STREAM<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>listenfd<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	ret<span class="token operator">=</span><span class="token function">bind</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>ret<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	ret<span class="token operator">=</span><span class="token function">listen</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>ret<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	epoll_event events<span class="token punctuation">[</span>MAX_EVENT_NUMBER<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> epollfd<span class="token operator">=</span><span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>epollfd<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">addfd</span><span class="token punctuation">(</span>epollfd<span class="token punctuation">,</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
	ret<span class="token operator">=</span><span class="token function">socketpair</span><span class="token punctuation">(</span>PF_UNIX<span class="token punctuation">,</span>SOCK_STREAM<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>pipefd<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>ret<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">setnonblocking</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">addfd</span><span class="token punctuation">(</span>epollfd<span class="token punctuation">,</span>pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/*设置信号处理函数*/</span>
	<span class="token function">addsig</span><span class="token punctuation">(</span>SIGALRM<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">addsig</span><span class="token punctuation">(</span>SIGTERM<span class="token punctuation">)</span><span class="token punctuation">;</span>
	bool stop_server<span class="token operator">=</span>false<span class="token punctuation">;</span>
	client_data<span class="token operator">*</span> users<span class="token operator">=</span>new client_data<span class="token punctuation">[</span>FD_LIMIT<span class="token punctuation">]</span><span class="token punctuation">;</span>
	bool timeout<span class="token operator">=</span>false<span class="token punctuation">;</span>
	<span class="token function">alarm</span><span class="token punctuation">(</span>TIMESLOT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//定时，TIMESLOT秒后发出信号</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stop_server<span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">int</span> number<span class="token operator">=</span><span class="token function">epoll_wait</span><span class="token punctuation">(</span>epollfd<span class="token punctuation">,</span>events<span class="token punctuation">,</span>MAX_EVENT_NUMBER<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>number<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>errno<span class="token operator">!=</span>EINTR<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"epoll failure\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>number<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token keyword">int</span> sockfd<span class="token operator">=</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd<span class="token punctuation">;</span>
			<span class="token comment">/*处理新到的客户连接*/</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>sockfd<span class="token operator">==</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> client_address<span class="token punctuation">;</span>
                <span class="token class-name">socklen_t</span> client_addrlength<span class="token operator">=</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>client_address<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">int</span> connfd<span class="token operator">=</span><span class="token function">accept</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>client_address<span class="token punctuation">,</span><span class="token operator">&amp;</span>client_addrlength<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">addfd</span><span class="token punctuation">(</span>epollfd<span class="token punctuation">,</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
                users<span class="token punctuation">[</span>connfd<span class="token punctuation">]</span><span class="token punctuation">.</span>address<span class="token operator">=</span>client_address<span class="token punctuation">;</span>
                users<span class="token punctuation">[</span>connfd<span class="token punctuation">]</span><span class="token punctuation">.</span>sockfd<span class="token operator">=</span>connfd<span class="token punctuation">;</span>
                <span class="token comment">/*创建定时器，设置其回调函数与超时时间，然后绑定定时器与用户数据，最后将定时器添加到链表timer_lst中*/</span>
                util_timer<span class="token operator">*</span> timer<span class="token operator">=</span>new util_timer<span class="token punctuation">;</span>
                timer<span class="token operator">-&gt;</span>user_data<span class="token operator">=</span><span class="token operator">&amp;</span>users<span class="token punctuation">[</span>connfd<span class="token punctuation">]</span><span class="token punctuation">;</span>
                timer<span class="token operator">-&gt;</span>cb_func<span class="token operator">=</span>cb_func<span class="token punctuation">;</span>
                <span class="token class-name">time_t</span> cur<span class="token operator">=</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                timer<span class="token operator">-&gt;</span>expire<span class="token operator">=</span>cur<span class="token operator">+</span><span class="token number">3</span><span class="token operator">*</span>TIMESLOT<span class="token punctuation">;</span>
                users<span class="token punctuation">[</span>connfd<span class="token punctuation">]</span><span class="token punctuation">.</span>timer<span class="token operator">=</span>timer<span class="token punctuation">;</span>
                timer_lst<span class="token punctuation">.</span><span class="token function">add_timer</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">/*处理信号*/</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>sockfd<span class="token operator">==</span>pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events<span class="token operator">&amp;</span>EPOLLIN<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">int</span> sig<span class="token punctuation">;</span>
                <span class="token keyword">char</span> signals<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                ret<span class="token operator">=</span><span class="token function">recv</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>signals<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>signals<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token comment">//handle the error</span>
                    <span class="token keyword">continue</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token keyword">continue</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">else</span><span class="token punctuation">{</span>
                    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>ret<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>
                        <span class="token keyword">switch</span><span class="token punctuation">(</span>signals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                            <span class="token keyword">case</span> SIGALRM<span class="token operator">:</span><span class="token punctuation">{</span>
                                <span class="token comment">/*用timeout变量标记有定时任务需要处理，但不立即处理定时任务。这是因为定时任务的优先级不是很高，我们优先处理其他更重要的任务*/</span>
                                timeout<span class="token operator">=</span>true<span class="token punctuation">;</span>
                                <span class="token keyword">break</span><span class="token punctuation">;</span>
                            <span class="token punctuation">}</span>
                            <span class="token keyword">case</span> SIGTERM<span class="token operator">:</span><span class="token punctuation">{</span><span class="token comment">//终止进程信号</span>
                                stop_server<span class="token operator">=</span>true<span class="token punctuation">;</span>
                            <span class="token punctuation">}</span>
                        <span class="token punctuation">}</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token comment">/*处理客户连接上接收到的数据*/</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events<span class="token operator">&amp;</span>EPOLLIN<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token function">memset</span><span class="token punctuation">(</span>users<span class="token punctuation">[</span>sockfd<span class="token punctuation">]</span><span class="token punctuation">.</span>buf<span class="token punctuation">,</span><span class="token char">'\0'</span><span class="token punctuation">,</span>BUFFER_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
                ret<span class="token operator">=</span><span class="token function">recv</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span>users<span class="token punctuation">[</span>sockfd<span class="token punctuation">]</span><span class="token punctuation">.</span>buf<span class="token punctuation">,</span>BUFFER_SIZE<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"get%d bytes of client data%s from%d\n"</span><span class="token punctuation">,</span>ret<span class="token punctuation">,</span>users<span class="token punctuation">[</span>sockfd<span class="token punctuation">]</span><span class="token punctuation">.</span>buf<span class="token punctuation">,</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
                util_timer<span class="token operator">*</span> timer<span class="token operator">=</span>users<span class="token punctuation">[</span>sockfd<span class="token punctuation">]</span><span class="token punctuation">.</span>timer<span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token comment">/*如果发生读错误，则关闭连接，并移除其对应的定时器*/</span>
                    <span class="token keyword">if</span><span class="token punctuation">(</span>errno<span class="token operator">!=</span>EAGAIN<span class="token punctuation">)</span><span class="token punctuation">{</span>
                        <span class="token function">cb_func</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>users<span class="token punctuation">[</span>sockfd<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">if</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">{</span>
                            timer_lst<span class="token punctuation">.</span><span class="token function">del_timer</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token comment">/*如果对方已经关闭连接，则我们也关闭连接，并移除对应的定时器*/</span>
                    <span class="token function">cb_func</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>users<span class="token punctuation">[</span>sockfd<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">{</span>
                        timer_lst<span class="token punctuation">.</span><span class="token function">del_timer</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">else</span><span class="token punctuation">{</span>
                    <span class="token comment">/*如果某个客户连接上有数据可读，则我们要调整该连接对应的定时器，以延迟该连接被关闭的时间*/</span>
                    <span class="token keyword">if</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">{</span>
                        <span class="token class-name">time_t</span> cur<span class="token operator">=</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        timer<span class="token operator">-&gt;</span>expire<span class="token operator">=</span>cur<span class="token operator">+</span><span class="token number">3</span><span class="token operator">*</span>TIMESLOT<span class="token punctuation">;</span>
                        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"adjust timer once\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        timer_lst<span class="token punctuation">.</span><span class="token function">adjust_timer</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span><span class="token punctuation">{</span>
                <span class="token comment">//others</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">/*最后处理定时事件，因为I/O事件有更高的优先级。当然，这样做将导致定时任务不能精确地按照预期的时间执行*/</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">timer_handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            timeout<span class="token operator">=</span>false<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
    <span class="token function">close</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    delete<span class="token punctuation">[</span><span class="token punctuation">]</span>users<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="I-O复用系统调用的超时参数"><a href="#I-O复用系统调用的超时参数" class="headerlink" title="I/O复用系统调用的超时参数"></a>I/O复用系统调用的超时参数</h2><p>Linux下的3组I/O复用系统调用都带有超时参数，因此它们不仅能统一处理信号和I/O事件，也能统一处理定时事件；但是由于I/O复用系统调用可能在超时事件到期之前就返回（有I/O事件发生），所以如果我们要利用它们来定时，就需要不断更新定时参数以反映剩余的事件</p>
<hr>
<p><strong>利用I/O复用系统调用定时</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TIMEOUT</span> <span class="token expression"><span class="token number">5000</span></span></span>
<span class="token keyword">int</span> timeout<span class="token operator">=</span>TIMEOUT<span class="token punctuation">;</span>
<span class="token class-name">time_t</span> start<span class="token operator">=</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">time_t</span> end<span class="token operator">=</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"the timeout is now%d mil-seconds\n"</span><span class="token punctuation">,</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
	start<span class="token operator">=</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> number<span class="token operator">=</span><span class="token function">epoll_wait</span><span class="token punctuation">(</span>epollfd<span class="token punctuation">,</span>events<span class="token punctuation">,</span>MAX_EVENT_NUMBER<span class="token punctuation">,</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>number<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>errno<span class="token operator">!=</span>EINTR<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"epoll failure\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">break</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">/*如果epoll_wait成功返回0，则说明超时时间到，此时便可处理定时任务，并重置定时时间*/</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>number<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		timeout<span class="token operator">=</span>TIMEOUT<span class="token punctuation">;</span>
		<span class="token keyword">continue</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	end<span class="token operator">=</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">/*如果epoll_wait的返回值大于0，则本次epoll_wait调用持续的时间是(endstart)*1000 ms，我们需要将定时时间timeout减去这段时间以获得下次epoll_wait调用的超时参数*/</span>
	timeout<span class="token operator">-=</span><span class="token punctuation">(</span>end<span class="token operator">-</span>start<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">1000</span><span class="token punctuation">;</span>
	<span class="token comment">/*重新计算之后的timeout值有可能等于0，说明本次epoll_wait调用返回时，不仅有文件描述符就绪，而且其超时时间也刚好到达，此时我们也要处理定时任务，并重置定时时间*/</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>timeout<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		timeout<span class="token operator">=</span>TIMEOUT<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//handle connections</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="高性能定时器"><a href="#高性能定时器" class="headerlink" title="高性能定时器"></a>高性能定时器</h2><p>基于排序链表的定时器存在一个问题：添加定时器的效率偏低</p>
<h3 id="时间轮"><a href="#时间轮" class="headerlink" title="时间轮"></a>时间轮</h3><p><strong>概念</strong></p>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/202401101620979.png" alt="image-20240110161958190"></p>
<ul>
<li>（实线）指针指向论在上的一个槽（slot），以恒定的速度顺时针转动，没转动一步就指向下一个槽（虚线指针指向的槽），每次转动成为一个滴答（tick）</li>
<li>一个滴答的时间称为时间轮的槽间隙<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="15.249ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 6740 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(469,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(814,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1203,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(1672,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(1970,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mi" transform="translate(2455,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(2816,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(3161,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(3761,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(4122,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(4588,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(5039,0)"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mi" transform="translate(5524,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(6053,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mo" transform="translate(6351,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>，时间轮共有N个槽，因此运转一周的时间时<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="5.987ex" height="1.57ex" role="img" focusable="false" viewBox="0 -683 2646.4 694"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mo" transform="translate(1110.2,0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path></g><g data-mml-node="mi" transform="translate(1832.4,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(2301.4,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></li>
<li>每个槽指向一条定时器链表，每条链表上的定时器具有相同的特征：它们的定时时间相差<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="5.987ex" height="1.57ex" role="img" focusable="false" viewBox="0 -683 2646.4 694"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mo" transform="translate(1110.2,0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path></g><g data-mml-node="mi" transform="translate(1832.4,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(2301.4,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container>的整数倍</li>
<li>如果指针指向槽cs，我们要添加一个定时时间为ti的定时器，则该定时器将被插入槽ts对应的链表中：<ul>
<li><script type="math/tex; mode=display">ts=(cs+(ti/si))%N</script></li>
</ul>
</li>
<li>基于排序链表的定时器使用唯一的一条链表来管理所有定时器，所以插入操作的效率随着定时器数目的增多而降低，而时间论使用哈希表的思想，将定时器散列到不同的链表上，这样每条链表上的定时器数目都将明显少于原来的排序链表上的定时器数目，插入效率不受定时器数目的影响</li>
<li>对于时间轮来说，要提高定时精度，就要使si值足够小，要提高执行效率，则要求N值足够大</li>
</ul>
<hr>
<p><strong>实现</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">TIME_WHEEL_TIMER</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TIME_WHEEL_TIMER</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;time.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netinet/in.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BUFFER_SIZE</span> <span class="token expression"><span class="token number">64</span></span></span>
class tw_timer<span class="token punctuation">;</span>

<span class="token comment">/*绑定socket和定时器*/</span>
<span class="token keyword">struct</span> <span class="token class-name">client_data</span><span class="token punctuation">{</span>
	sockaddr_in address<span class="token punctuation">;</span>
	<span class="token keyword">int</span> sockfd<span class="token punctuation">;</span>
	<span class="token keyword">char</span> buf<span class="token punctuation">[</span>BUFFER_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
	tw_timer<span class="token operator">*</span> timer<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">/*定时器类*/</span>
class tw_timer<span class="token punctuation">{</span>
public<span class="token operator">:</span>
	<span class="token function">tw_timer</span><span class="token punctuation">(</span><span class="token keyword">int</span> rot<span class="token punctuation">,</span><span class="token keyword">int</span> ts<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">prev</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">rotation</span><span class="token punctuation">(</span>rot<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">time_slot</span><span class="token punctuation">(</span>ts<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
public<span class="token operator">:</span>
	<span class="token keyword">int</span> rotation<span class="token punctuation">;</span><span class="token comment">/*记录定时器在时间轮转多少圈后生效*/</span>
	<span class="token keyword">int</span> time_slot<span class="token punctuation">;</span><span class="token comment">/*记录定时器属于时间轮上哪个槽（对应的链表，下同）*/</span>
	<span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span>cb_func<span class="token punctuation">)</span><span class="token punctuation">(</span>client_data<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*定时器回调函数*/</span>
	client_data<span class="token operator">*</span> user_data<span class="token punctuation">;</span><span class="token comment">/*客户数据*/</span>
	tw_timer<span class="token operator">*</span> next<span class="token punctuation">;</span><span class="token comment">/*指向下一个定时器*/</span>
	tw_timer<span class="token operator">*</span> prev<span class="token punctuation">;</span><span class="token comment">/*指向前一个定时器*/</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

class time_wheel<span class="token punctuation">{</span>
public<span class="token operator">:</span>
	<span class="token function">time_wheel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">cur_slot</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>N<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>
			slots<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">/*初始化每个槽的头结点*/</span>
		<span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    ～<span class="token function">time_wheel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">/*遍历每个槽，并销毁其中的定时器*/</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>N<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>
            tw_timer<span class="token operator">*</span> tmp<span class="token operator">=</span>slots<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">{</span>
                slots<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>tmp<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
                delete tmp<span class="token punctuation">;</span>
                tmp<span class="token operator">=</span>slots<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
	<span class="token comment">/*根据定时值timeout创建一个定时器，并把它插入合适的槽中*/</span>
	tw_timer<span class="token operator">*</span> <span class="token function">add_timer</span><span class="token punctuation">(</span><span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>timeout<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">int</span> ticks<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token comment">/*下面根据待插入定时器的超时值计算它将在时间轮转动多少个滴答后被触发，并将该滴答数存储于变量ticks中。如果待插入定时器的超时值小于时间轮的槽间隔SI，则将ticks向上折合为1，否则就将ticks向下折合为timeout/SI*/</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>timeout<span class="token operator">&lt;</span>SI<span class="token punctuation">)</span><span class="token punctuation">{</span>
			ticks<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span><span class="token punctuation">{</span>
			ticks<span class="token operator">=</span>timeout<span class="token operator">/</span>SI<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">/*计算待插入的定时器在时间轮转动多少圈后被触发*/</span>
		<span class="token keyword">int</span> rotation<span class="token operator">=</span>ticks<span class="token operator">/</span>N<span class="token punctuation">;</span>
		<span class="token comment">/*计算待插入的定时器应该被插入哪个槽中*/</span>
		<span class="token keyword">int</span> ts<span class="token operator">=</span><span class="token punctuation">(</span>cur_slot<span class="token operator">+</span><span class="token punctuation">(</span>ticks<span class="token operator">%</span>N<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">%</span>N<span class="token punctuation">;</span>
		<span class="token comment">/*创建新的定时器，它在时间轮转动rotation圈之后被触发，且位于第ts个槽上*/</span>
        tw_timer<span class="token operator">*</span> timer<span class="token operator">=</span>new <span class="token function">tw_timer</span><span class="token punctuation">(</span>rotation<span class="token punctuation">,</span>ts<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">/*如果第ts个槽中尚无任何定时器，则把新建的定时器插入其中，并将该定时器设置为该槽的头结点*/</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>slots<span class="token punctuation">[</span>ts<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"add timer,rotation is%d,ts is%d,cur_slotis%d\n"</span><span class="token punctuation">,</span>rotation<span class="token punctuation">,</span>ts<span class="token punctuation">,</span>cur_slot<span class="token punctuation">)</span><span class="token punctuation">;</span>
			slots<span class="token punctuation">[</span>ts<span class="token punctuation">]</span><span class="token operator">=</span>timer<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">/*否则，将定时器插入第ts个槽中*/</span>
		<span class="token keyword">else</span><span class="token punctuation">{</span>
			timer<span class="token operator">-&gt;</span>next<span class="token operator">=</span>slots<span class="token punctuation">[</span>ts<span class="token punctuation">]</span><span class="token punctuation">;</span>
			slots<span class="token punctuation">[</span>ts<span class="token punctuation">]</span><span class="token operator">-&gt;</span>prev<span class="token operator">=</span>timer<span class="token punctuation">;</span>
			slots<span class="token punctuation">[</span>ts<span class="token punctuation">]</span><span class="token operator">=</span>timer<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> timer<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">/*删除目标定时器timer*/</span>
	<span class="token keyword">void</span> <span class="token function">del_timer</span><span class="token punctuation">(</span>tw_timer<span class="token operator">*</span> timer<span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>timer<span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">int</span> ts<span class="token operator">=</span>timer<span class="token operator">-&gt;</span>time_slot<span class="token punctuation">;</span>
		<span class="token comment">/*slots[ts]是目标定时器所在槽的头结点。如果目标定时器就是该头结点，则需要重置第ts个槽的头结点*/</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>timer<span class="token operator">==</span>slots<span class="token punctuation">[</span>ts<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			slots<span class="token punctuation">[</span>ts<span class="token punctuation">]</span><span class="token operator">=</span>slots<span class="token punctuation">[</span>ts<span class="token punctuation">]</span><span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>slots<span class="token punctuation">[</span>ts<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
				slots<span class="token punctuation">[</span>ts<span class="token punctuation">]</span><span class="token operator">-&gt;</span>prev<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			delete timer<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span><span class="token punctuation">{</span>
			timer<span class="token operator">-&gt;</span>prev<span class="token operator">-&gt;</span>next<span class="token operator">=</span>timer<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>timer<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">{</span>
				timer<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>prev<span class="token operator">=</span>timer<span class="token operator">-&gt;</span>prev<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			delete timer<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
	<span class="token comment">/*SI时间到后，调用该函数，时间轮向前滚动一个槽的间隔*/</span>
	<span class="token keyword">void</span> <span class="token function">tick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		tw_timer<span class="token operator">*</span> tmp<span class="token operator">=</span>slots<span class="token punctuation">[</span>cur_slot<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">/*取得时间轮上当前槽的头结点*/</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"current slot is%d\n"</span><span class="token punctuation">,</span>cur_slot<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"tick the timer once\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">/*如果定时器的rotation值大于0，则它在这一轮不起作用*/</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>tmp<span class="token operator">-&gt;</span>rotation<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
				tmp<span class="token operator">-&gt;</span>rotation<span class="token operator">--</span><span class="token punctuation">;</span>
				tmp<span class="token operator">=</span>tmp<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token comment">/*否则，说明定时器已经到期，于是执行定时任务，然后删除该定时器*/</span>
			<span class="token keyword">else</span><span class="token punctuation">{</span>
				tmp<span class="token operator">-&gt;</span><span class="token function">cb_func</span><span class="token punctuation">(</span>tmp<span class="token operator">-&gt;</span>user_data<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span><span class="token punctuation">(</span>tmp<span class="token operator">==</span>slots<span class="token punctuation">[</span>cur_slot<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
					<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"delete header in cur_slot\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					slots<span class="token punctuation">[</span>cur_slot<span class="token punctuation">]</span><span class="token operator">=</span>tmp<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
					delete tmp<span class="token punctuation">;</span>
					<span class="token keyword">if</span><span class="token punctuation">(</span>slots<span class="token punctuation">[</span>cur_slot<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
						slots<span class="token punctuation">[</span>cur_slot<span class="token punctuation">]</span><span class="token operator">-&gt;</span>prev<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
					tmp<span class="token operator">=</span>slots<span class="token punctuation">[</span>cur_slot<span class="token punctuation">]</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">else</span><span class="token punctuation">{</span>
					tmp<span class="token operator">-&gt;</span>prev<span class="token operator">-&gt;</span>next<span class="token operator">=</span>tmp<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
					<span class="token keyword">if</span><span class="token punctuation">(</span>tmp<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">{</span>
						tmp<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>prev<span class="token operator">=</span>tmp<span class="token operator">-&gt;</span>prev<span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
					tw_timer<span class="token operator">*</span> tmp2<span class="token operator">=</span>tmp<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
					delete tmp<span class="token punctuation">;</span>
					tmp<span class="token operator">=</span>tmp2<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
		cur_slot<span class="token operator">=</span><span class="token operator">++</span>cur_slot<span class="token operator">%</span>N<span class="token punctuation">;</span><span class="token comment">/*更新时间轮的当前槽，以反映时间轮的转动*/</span>
	<span class="token punctuation">}</span>
private<span class="token operator">:</span>
    <span class="token comment">/*时间轮上槽的数目*/</span>
    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> N<span class="token operator">=</span><span class="token number">60</span><span class="token punctuation">;</span>
    <span class="token comment">/*每1 s时间轮转动一次，即槽间隔为1 s*/</span>
    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> SI<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">/*时间轮的槽，其中每个元素指向一个定时器链表，链表无序*/</span>
    tw_timer<span class="token operator">*</span> slots<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> cur_slot<span class="token punctuation">;</span><span class="token comment">/*时间轮的当前槽*/</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="时间堆"><a href="#时间堆" class="headerlink" title="时间堆"></a>时间堆</h3><p><strong>概念</strong></p>
<p>将所有定时器中超时时间最小的一个定时器的超时值作为心搏间隔，这样一旦心搏函数tick被调用，超时时间最小的定时器必然到期，我们就可以在tick函数中处理该定时器，然后再次从剩余的定时器中找出超时时间最小的一个，并将这段最小时间设置为下一次心搏间隔，如此反复，就实现了精确的定时</p>
<p>最小堆很适合处理这种定时方案</p>
<hr>
<p><strong>简单实现</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">MIN_HEAP</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MIN_HEAP</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netinet/in.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;time.h&gt;</span></span>
using std<span class="token operator">::</span>exception<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BUFFER_SIZE</span> <span class="token expression"><span class="token number">64</span></span></span>
class heap_timer<span class="token punctuation">;</span><span class="token comment">/*前向声明*/</span>

<span class="token comment">/*绑定socket和定时器*/</span>
<span class="token keyword">struct</span> <span class="token class-name">client_data</span><span class="token punctuation">{</span>
    sockaddr_in address<span class="token punctuation">;</span>
    <span class="token keyword">int</span> sockfd<span class="token punctuation">;</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span>BUFFER_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    heap_timer<span class="token operator">*</span>timer<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">/*定时器类*/</span>
class heap_timer<span class="token punctuation">{</span>
public<span class="token operator">:</span>
    <span class="token function">heap_timer</span><span class="token punctuation">(</span><span class="token keyword">int</span> delay<span class="token punctuation">)</span><span class="token punctuation">{</span>
    	expire<span class="token operator">=</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token operator">+</span>delay<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
public<span class="token operator">:</span>
    <span class="token class-name">time_t</span> expire<span class="token punctuation">;</span><span class="token comment">/*定时器生效的绝对时间*/</span>
    <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span>cb_func<span class="token punctuation">)</span><span class="token punctuation">(</span>client_data<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*定时器的回调函数*/</span>
    client_data<span class="token operator">*</span> user_data<span class="token punctuation">;</span><span class="token comment">/*用户数据*/</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">/*时间堆类*/</span>
class time_heap<span class="token punctuation">{</span>
public<span class="token operator">:</span>
	<span class="token comment">/*构造函数之一，初始化一个大小为cap的空堆*/</span>
	<span class="token function">time_heap</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">)</span><span class="token function">throw</span><span class="token punctuation">(</span>std<span class="token operator">::</span>exception<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">capacity</span><span class="token punctuation">(</span>cap<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">cur_size</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        array<span class="token operator">=</span>new heap_timer<span class="token operator">*</span> <span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">/*创建堆数组*/</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>array<span class="token punctuation">)</span><span class="token punctuation">{</span>
            throw std<span class="token operator">::</span><span class="token function">exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>capacity<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>
            array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
	<span class="token comment">/*构造函数之二，用已有数组来初始化堆*/</span>
	<span class="token function">time_heap</span><span class="token punctuation">(</span>heap_timer<span class="token operator">*</span><span class="token operator">*</span> init_array<span class="token punctuation">,</span><span class="token keyword">int</span> size<span class="token punctuation">,</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span><span class="token function">throw</span><span class="token punctuation">(</span>std<span class="token operator">::</span>exception<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">cur_size</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">capacity</span><span class="token punctuation">(</span>capacity<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>capacity<span class="token operator">&lt;</span>size<span class="token punctuation">)</span><span class="token punctuation">{</span>
            throw std<span class="token operator">::</span><span class="token function">exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        array<span class="token operator">=</span>new heap_timer<span class="token operator">*</span> <span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">/*创建堆数组*/</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>array<span class="token punctuation">)</span><span class="token punctuation">{</span>
            throw std<span class="token operator">::</span><span class="token function">exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>capacity<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>
            array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>size<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">/*初始化堆数组*/</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>size<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>
                array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>init_array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token punctuation">(</span>cur_size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token operator">--</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token comment">/*对数组中的第[(cur_size-1)/2]～0个元素执行下虑操作*/</span>
                <span class="token function">percolate_down</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
	<span class="token comment">/*销毁时间堆*/</span>
	～<span class="token function">time_heap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>cur_size<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>
			delete array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		delete<span class="token punctuation">[</span><span class="token punctuation">]</span>array<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
public<span class="token operator">:</span>
	<span class="token comment">/*添加目标定时器timer*/</span>
	<span class="token keyword">void</span> <span class="token function">add_timer</span><span class="token punctuation">(</span>heap_timer<span class="token operator">*</span> timer<span class="token punctuation">)</span><span class="token function">throw</span><span class="token punctuation">(</span>std<span class="token operator">::</span>exception<span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>timer<span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
        <span class="token comment">/*如果当前堆数组容量不够，则将其扩大1倍*/</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>cur_size<span class="token operator">&gt;=</span>capacity<span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">/*新插入了一个元素，当前堆大小加1，hole是新建空穴的位置*/</span>
		<span class="token keyword">int</span> hole<span class="token operator">=</span>cur_size<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> parent<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment">/*对从空穴到根节点的路径上的所有节点执行上虑操作*/</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span>hole<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">;</span>hole<span class="token operator">=</span>parent<span class="token punctuation">)</span><span class="token punctuation">{</span>
			parent<span class="token operator">=</span><span class="token punctuation">(</span>hole<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token operator">-&gt;</span>expire<span class="token operator">&lt;=</span>timer<span class="token operator">-&gt;</span>expire<span class="token punctuation">)</span><span class="token punctuation">{</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			array<span class="token punctuation">[</span>hole<span class="token punctuation">]</span><span class="token operator">=</span>array<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		array<span class="token punctuation">[</span>hole<span class="token punctuation">]</span><span class="token operator">=</span>timer<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">/*删除目标定时器timer*/</span>
	<span class="token keyword">void</span> <span class="token function">del_timer</span><span class="token punctuation">(</span>heap_timer<span class="token operator">*</span> timer<span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>timer<span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">/*仅仅将目标定时器的回调函数设置为空，即所谓的延迟销毁。这将节省真正删除该定时器造成的开销，但这样做容易使堆数组膨胀*/</span>
		timer<span class="token operator">-&gt;</span>cb_func<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
    <span class="token comment">/*获得堆顶部的定时器*/</span>
    heap_timer<span class="token operator">*</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">{</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
        <span class="token keyword">return</span> array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
    
    <span class="token comment">/*删除堆顶部的定时器*/</span>
	<span class="token keyword">void</span> <span class="token function">pop_timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			delete array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token comment">/*将原来的堆顶元素替换为堆数组中最后一个元素*/</span>
            array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>array<span class="token punctuation">[</span><span class="token operator">--</span>cur_size<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token function">percolate_down</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*对新的堆顶元素执行下虑操作*/</span>
		<span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">/*心搏函数*/</span>
    <span class="token keyword">void</span> <span class="token function">tick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        heap_timer<span class="token operator">*</span> tmp<span class="token operator">=</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token class-name">time_t</span> cur<span class="token operator">=</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*循环处理堆中到期的定时器*/</span>
		<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>tmp<span class="token punctuation">)</span><span class="token punctuation">{</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token comment">/*如果堆顶定时器没到期，则退出循环*/</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>tmp<span class="token operator">-&gt;</span>expire<span class="token operator">&gt;</span>cur<span class="token punctuation">)</span><span class="token punctuation">{</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token comment">/*否则就执行堆顶定时器中的任务*/</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-&gt;</span>cb_func<span class="token punctuation">)</span><span class="token punctuation">{</span>
				array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-&gt;</span><span class="token function">cb_func</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-&gt;</span>user_data<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
            <span class="token comment">/*将堆顶元素删除，同时生成新的堆顶定时器（array[0]）*/</span>
            <span class="token function">pop_timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            tmp<span class="token operator">=</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    
	bool <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">{</span><span class="token keyword">return</span> cur_size<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
private<span class="token operator">:</span>
	<span class="token comment">/*最小堆的下虑操作，它确保堆数组中以第hole个节点作为根的子树拥有最小堆性质*/</span>
	<span class="token keyword">void</span> <span class="token function">percolate_down</span><span class="token punctuation">(</span><span class="token keyword">int</span> hole<span class="token punctuation">)</span><span class="token punctuation">{</span>
		heap_timer<span class="token operator">*</span> temp<span class="token operator">=</span>array<span class="token punctuation">[</span>hole<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> child<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token punctuation">(</span>hole<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token punctuation">(</span>cur_size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>hole<span class="token operator">=</span>child<span class="token punctuation">)</span><span class="token punctuation">{</span>
			child<span class="token operator">=</span>hole<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>child<span class="token operator">&lt;</span><span class="token punctuation">(</span>cur_size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>child<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-&gt;</span>expire<span class="token operator">&lt;</span>array<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token operator">-&gt;</span>expire<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
				<span class="token operator">++</span>child<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token operator">-&gt;</span>expire<span class="token operator">&lt;</span>temp<span class="token operator">-&gt;</span>expire<span class="token punctuation">)</span><span class="token punctuation">{</span>
				array<span class="token punctuation">[</span>hole<span class="token punctuation">]</span><span class="token operator">=</span>array<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">else</span><span class="token punctuation">{</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
		array<span class="token punctuation">[</span>hole<span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
    
    <span class="token comment">/*将堆数组容量扩大1倍*/</span>
    <span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">throw</span><span class="token punctuation">(</span>std<span class="token operator">::</span>exception<span class="token punctuation">)</span><span class="token punctuation">{</span>
		heap_timer<span class="token operator">*</span><span class="token operator">*</span> temp<span class="token operator">=</span>new heap_timer<span class="token operator">*</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">2</span><span class="token operator">*</span>capacity<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>
			temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>temp<span class="token punctuation">)</span><span class="token punctuation">{</span>
			throw std<span class="token operator">::</span><span class="token function">exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
        capacity<span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span>capacity<span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>cur_size<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>
			temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		delete<span class="token punctuation">[</span><span class="token punctuation">]</span>array<span class="token punctuation">;</span>
		array<span class="token operator">=</span>temp<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
private<span class="token operator">:</span>
    heap_timer<span class="token operator">*</span><span class="token operator">*</span> array<span class="token punctuation">;</span><span class="token comment">/*堆数组*/</span>
    <span class="token keyword">int</span> capacity<span class="token punctuation">;</span><span class="token comment">/*堆数组的容量*/</span>
    <span class="token keyword">int</span> cur_size<span class="token punctuation">;</span><span class="token comment">/*堆数组当前包含元素的个数*/</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">时间复杂度</th>
<th style="text-align:center">添加定时器</th>
<th style="text-align:center">删除定时器</th>
<th style="text-align:center">执行定时任务</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">基于升序链表的定时器</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">O(1)</td>
</tr>
<tr>
<td style="text-align:center">时间轮</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">比O(n)好，使用多个轮子时接近O(1)</td>
</tr>
<tr>
<td style="text-align:center">时间堆</td>
<td style="text-align:center">O(logn)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">O(1)</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <tags>
        <tag>C++ socket</tag>
      </tags>
  </entry>
  <entry>
    <title>Trie</title>
    <url>/2022/11/29/Trie/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>字典树也叫Trie树、前缀树，是一种针对字符串进行维护的<strong>数据结构</strong>，而不是算法。</p>
<p>字典树是对字符串的一种存储的方式，这棵树的根节点到某一个目标节点的路径就是一个字符串（单词）。</p>
<p>举个例子，下图的字典树：</p>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202212212057021.png" alt="202211291950874"></p>
<p>该字典树存储的单词为：</p>
<pre class="line-numbers language-none"><code class="language-none">a
abc
ba
bca
bca
ca
ca<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<span id="more"></span>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ul>
<li>根节点不包含字符，除根节点外的所有节点都包含一个字符</li>
<li>从根节点到某一个节点，路径上经过的所有字符连接起来，为该节点对应的字符串</li>
<li>每个节点的子节点包含的字符各不相同</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>计算热词：统计字符串在集合中出现的个数</li>
<li>字典序排序</li>
<li>最长公共前缀（LCP）</li>
<li>…</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>字典树的实现主要有<strong>插入和查找</strong></p>
<p>假设该字符串集合由26个小写字母组成，我们定义两个数组</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int next[100000][26],cnt; //存放该节点的子节点
int num[100000]; //表示该字符串一共出现多少次，为0表示不存在<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void insert(std::string str){
    int len=str.length();
	int p=0; //记录当前节点位置
    for(int i=0;i&lt;len;++i){
    	int c=str[i]-'a';
        if(!next[p][c]) next[p][c]=++cnt;
        p=next[p][c];
    }
    ++num[p];
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int find(std::string str){
	int len=str.length();
    int p=0;
    for(int i=0;i&lt;len;++i){
		int c=str[i]-'a';
        if(!next[p][c]) return 0;
        p=next[p][c];
    }
    return num[p];
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ul>
<li><a href="https://www.luogu.com.cn/problem/SP4033">SP4033 PHONELST - Phone List</a></li>
<li><a href="https://www.luogu.com.cn/problem/UVA1401">UVA1401 Remember the Word</a></li>
<li><a href="https://www.luogu.com.cn/problem/UVA11732">UVA11732 “strcmp()” Anyone?</a> </li>
<li><a href="https://www.luogu.com.cn/problem/P7469">P7469 [NOI Online 2021 提高组] 积木小赛</a> </li>
</ul>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>信号</title>
    <url>/2023/11/29/7-%E4%BF%A1%E5%8F%B7/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">    



<h2 id="Linux信号产生的条件"><a href="#Linux信号产生的条件" class="headerlink" title="Linux信号产生的条件"></a>Linux信号产生的条件</h2><ul>
<li>对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号<ul>
<li>比如输入CRTL+C通常会给进程发送一个中断信号</li>
</ul>
</li>
<li>系统异常<ul>
<li>比如浮点异常和非法内存段访问</li>
</ul>
</li>
<li>系统状态变化<ul>
<li>比如alarm定时器到期将引起SIGALRM信号</li>
</ul>
</li>
<li>运行kill命令或调用kill函数</li>
</ul>
<span id="more"></span>
<h2 id="Linux信号概述"><a href="#Linux信号概述" class="headerlink" title="Linux信号概述"></a>Linux信号概述</h2><h3 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">kill</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">,</span> <span class="token keyword">int</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li>该函数把信号sig发送给目标进程，目标进程由pid参数指定</li>
<li><p>pid取值</p>
<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202401091557011.png" alt="image-20240109155257484"></li>
</ul>
</li>
<li><p>Linux定义的信号值都大于0，如果sig取0，则kill函数不发送任何信号，但可以用来检测目标进程或进程组是否存在，因为检查工作总是在信号发送之前就执行，但是这种方法是不可靠的</p>
</li>
<li>成功时返回0，失败则返回-1并设置errno<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202401091600868.png" alt="image-20240109160014039"></li>
</ul>
</li>
</ul>
<h3 id="信号处理方式"><a href="#信号处理方式" class="headerlink" title="信号处理方式"></a>信号处理方式</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span>__sighandler_t<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>信号处理函数只带有一个整形参数，改参数用来表示信号类型</li>
<li>信号处理函数应该是可重入的，否则很容易引发一些竞态条件，因此在型号处理函数中严禁调用一些不安全的函数</li>
</ul>
<hr>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/signum.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SIG_DFL</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span>__sighandler_t<span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SIG_IGN</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span>__sighandler_t<span class="token punctuation">)</span><span class="token number">1</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li>SIG_IGN表示忽略目标信号</li>
<li>SIG_DFL表示使用信号的默认处理方式</li>
</ul>
<h3 id="LINUX信号"><a href="#LINUX信号" class="headerlink" title="LINUX信号"></a>LINUX信号</h3><p><img src="https://gitee.com/renmale-sztu/image/raw/master/202401091610062.png" alt="image-20240109161041046"></p>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/202401091610700.png" alt="image-20240109161048880"></p>
<h3 id="中断系统调用"><a href="#中断系统调用" class="headerlink" title="中断系统调用"></a>中断系统调用</h3><p>如果程序在执行处于阻塞状态的系统调用时接收到信号，并且我们为该信号设置了信号处理函数，则默认情况下系统调用将被中断，并且errno被设置为EINTR；我们可以使用sigaction函数为信号设置SA_RESTART标志以自动重启该信号中断的系统调用</p>
<p>对于默认行为是暂停进程的信号（比如SIGSTOP、SIGTTIN），如果我们没有为他们设置信号处理函数，则它们也可以中断某些系统调用（比如connect、epoll_wait）</p>
<h2 id="信号函数"><a href="#信号函数" class="headerlink" title="信号函数"></a>信号函数</h2><h3 id="signal系统调用"><a href="#signal系统调用" class="headerlink" title="signal系统调用"></a>signal系统调用</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>
__sighandler_t <span class="token function">signal</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">,</span> _sighandler_t _handler<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>该函数为一个信号设置处理函数</li>
<li>sig参数指出要捕获的信号类型</li>
<li>_hendler参数是_sighandler_t类型的函数指针，用于指定信号sig的处理函数</li>
<li>成功时返回一个函数指针，这个返回值时前一次调用signal函数时传入的函数指针（即先前的信号处理函数指针），或者是信号sig对应的默认处理函数指针SIG_DEF（如果是第一次调用signal）</li>
<li>出错时返回SIG_ERR，并设置errno</li>
</ul>
<h3 id="sigaction系统调用"><a href="#sigaction系统调用" class="headerlink" title="sigaction系统调用"></a>sigaction系统调用</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">sigaction</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sigaction</span><span class="token operator">*</span> act<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sigaction</span><span class="token operator">*</span> oact<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li><p>该函数也用于为一个信号设置处理函数，但相比signal更为健壮</p>
</li>
<li><p>sig参数指出要捕获的信号类型</p>
</li>
<li><p>act参数指定新的信号处理方式</p>
</li>
<li><p>oact参数输出信号先前的处理方式</p>
</li>
<li><p>sigaction结构体</p>
<ul>
<li>```c<br>struct sigaction{<pre><code>#ifdef__USE_POSIX199309
    union{
        _sighandler_t sa_handler;
        void(*sa_sigaction)(int,siginfo_t*,void*);
    }_sigaction_handler;
    #define sa_handler__sigaction_handler.sa_handler
    #define sa_sigaction__sigaction_handler.sa_sigaction
#else
    _sighandler_t sa_handler;
#endif
_sigset_t sa_mask;
int sa_flags;
void(*sa_restorer)(void);
</code></pre>};<pre class="line-numbers language-none"><code class="language-none">
  - sa_hander成员指定信号处理函数

  - sa_mask成员设置进程的信号掩码（在原有信号源码的基础上增加信号掩码）

  - sa_flags成员用于设置程序收到信号时的行为

    - ![image-20240109162820540](https://gitee.com/renmale-sztu/image/raw/master/202401091628457.png)

  - sa_restorer成员已经过时

  - 成功时返回0，失败时返回-1并设置errno

## 信号集

### 信号集函数

**sigset_t结构体**

```c
#include &lt;bits/sigset.h&gt;
#define_SIGSET_NWORDS(1024/(8*sizeof(unsigned long int)))
typedef struct{
	unsigned long int __val[_SIGSET_NWORDS];
}__sigset_t;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p>实际上是一个长整型数组，数组的每个元素的每个位表示一个信号</p>
</li>
</ul>
<hr>
<p><strong>信号集操作函数</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token expression">＜signal<span class="token punctuation">.</span>h＞</span></span>
<span class="token keyword">int</span> <span class="token function">sigemptyset</span><span class="token punctuation">(</span><span class="token class-name">sigset_t</span><span class="token operator">*</span>_set<span class="token punctuation">)</span>					<span class="token comment">//清空信号集</span>
<span class="token keyword">int</span> <span class="token function">sigfillset</span><span class="token punctuation">(</span><span class="token class-name">sigset_t</span><span class="token operator">*</span>_set<span class="token punctuation">)</span>					<span class="token comment">//在信号集中设置所有信号</span>
<span class="token keyword">int</span> <span class="token function">sigaddset</span><span class="token punctuation">(</span><span class="token class-name">sigset_t</span><span class="token operator">*</span>_set<span class="token punctuation">,</span>int_signo<span class="token punctuation">)</span>			<span class="token comment">//将信号_signo添加至信号集中</span>
<span class="token keyword">int</span> <span class="token function">sigdelset</span><span class="token punctuation">(</span><span class="token class-name">sigset_t</span><span class="token operator">*</span>_set<span class="token punctuation">,</span>int_signo<span class="token punctuation">)</span>			<span class="token comment">//将信号_signo从信号集中删除</span>
<span class="token keyword">int</span> <span class="token function">sigismember</span><span class="token punctuation">(</span>_const <span class="token class-name">sigset_t</span><span class="token operator">*</span>_set<span class="token punctuation">,</span>int_signo<span class="token punctuation">)</span>	<span class="token comment">//测试_signo是否在信号集中</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="进程信号掩码"><a href="#进程信号掩码" class="headerlink" title="进程信号掩码"></a>进程信号掩码</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">sigprocmask</span><span class="token punctuation">(</span><span class="token keyword">int</span> _how<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token class-name">sigset_t</span><span class="token operator">*</span> _set<span class="token punctuation">,</span> <span class="token class-name">sigset_t</span><span class="token operator">*</span> _oset<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>该函数可以用于设置或查看进程的信号掩码</li>
<li>_set参数指定新的信号掩码</li>
<li>_oset参数则输出原来的信号掩码</li>
<li>如果_set参数不为NULL，则_how参数指定设置进程信号掩码的方式<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202401091649948.png" alt="image-20240109164956927"></li>
</ul>
</li>
<li>如果_set为NULL，则进程信号掩码不变，此时仍然可以利用_oset参数来获取进程当前的信号掩码</li>
<li>成功时返回0，失败时返回-1并设置errno</li>
</ul>
<h3 id="被挂起的信号"><a href="#被挂起的信号" class="headerlink" title="被挂起的信号"></a>被挂起的信号</h3><p>设置进程信号掩码后，被屏蔽的信号将不能被进程接收，如果给一个进程发送一个被屏蔽的信号，则操作系统将该信号设置为进程的一个被挂起的信号；如果我们取消对被挂起信号的屏蔽，则它能立即被进程接收到</p>
<hr>
<p><strong>获取进程当前被挂起的信号集</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">sigpending</span><span class="token punctuation">(</span><span class="token class-name">sigset_t</span> <span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>set参数用于保存被挂起的信号集，进程即使多次接收到同一个被挂起的信号，sigpending函数也只能反映一次；并且，当使用sigprocmask使能该挂起的信号时，该信号的处理函数也只被触发一次</li>
<li>成功时返回0，失败时返回-1并设置errno</li>
</ul>
<h2 id="统一事件源"><a href="#统一事件源" class="headerlink" title="统一事件源"></a>统一事件源</h2><p>信号是一种异步事件，信号处理函数喝程序的主循环是两条不同的执行路线；信号处理函数需要尽可能快地执行完毕，以确保该信号不被屏蔽（为了避免一些竞态条件，信号在处理期间，系统不会再次触发它）太久</p>
<p>一种解决方案是把信号的主要处理逻辑放到程序的主循环中，当信号处理函数被触发时，它只是简单地通知主循环程序接收到信号，并把信号值传递给主循环，主循环再根据接收到的信号值执行目标信号对应的逻辑代码。</p>
<p>信号处理函数通常使用管道来将信号“传递”给主循环：信号处理函数往管道的写端写入信号值，主循环则从管道的读端读出该信号值，使用I/O复用系统调用来见监听管道的读端文件描述符上的可读事件，使主循环指导管道上何时有数据可读，这样，信号事件就能和其他I/O事件一样被处理，即统一事件源</p>
<hr>
<p><strong>简单实现</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token expression"><span class="token operator">&lt;</span>sys<span class="token operator">/</span>socket<span class="token punctuation">.</span>h＞</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netinet/in.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;errno.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/epoll.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_EVENT_NUMBER</span> <span class="token expression"><span class="token number">1024</span></span></span>
<span class="token keyword">static</span> <span class="token keyword">int</span> pipefd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">setnonblocking</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> old_option<span class="token operator">=</span><span class="token function">fcntl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>F_GETFL<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> new_option<span class="token operator">=</span>old_option<span class="token operator">|</span>O_NONBLOCK<span class="token punctuation">;</span>
	<span class="token function">fcntl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>F_SETFL<span class="token punctuation">,</span>new_option<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> old_option<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">addfd</span><span class="token punctuation">(</span><span class="token keyword">int</span> epollfd<span class="token punctuation">,</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">{</span>
	epoll_event event<span class="token punctuation">;</span>
	event<span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd<span class="token operator">=</span>fd<span class="token punctuation">;</span>
	event<span class="token punctuation">.</span>events<span class="token operator">=</span>EPOLLIN<span class="token operator">|</span>EPOLLET<span class="token punctuation">;</span>
	<span class="token function">epoll_ctl</span><span class="token punctuation">(</span>epollfd<span class="token punctuation">,</span>EPOLL_CTL_ADD<span class="token punctuation">,</span>fd<span class="token punctuation">,</span><span class="token operator">&amp;</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">setnonblocking</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*信号处理函数*/</span>
<span class="token keyword">void</span> <span class="token function">sig_handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token comment">/*保留原来的errno，在函数最后恢复，以保证函数的可重入性*/</span>
	<span class="token keyword">int</span> save_errno<span class="token operator">=</span>errno<span class="token punctuation">;</span>
	<span class="token keyword">int</span> msg<span class="token operator">=</span>sig<span class="token punctuation">;</span>
	<span class="token function">send</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>msg<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*将信号值写入管道，以通知主循环*/</span>
	errno<span class="token operator">=</span>save_errno<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*设置信号的处理函数*/</span>
<span class="token keyword">void</span> <span class="token function">addsig</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">struct</span> <span class="token class-name">sigaction</span> sa<span class="token punctuation">;</span>
	<span class="token function">memset</span><span class="token punctuation">(</span>＆sa<span class="token punctuation">,</span><span class="token char">'\0'</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>sa<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	sa<span class="token punctuation">.</span>sa_handler<span class="token operator">=</span>sig_handler<span class="token punctuation">;</span>
	sa<span class="token punctuation">.</span>sa_flags<span class="token operator">|=</span>SA_RESTART<span class="token punctuation">;</span>
	<span class="token function">sigfillset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sa<span class="token punctuation">.</span>sa_mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span><span class="token function">sigaction</span><span class="token punctuation">(</span>sig<span class="token punctuation">,</span>＆sa<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span><span class="token keyword">char</span><span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>argc<span class="token operator">&lt;=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"usage:%s ip_address port_number\n"</span><span class="token punctuation">,</span><span class="token function">basename</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> ip<span class="token operator">=</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> port<span class="token operator">=</span><span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> ret<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> address<span class="token punctuation">;</span>
	<span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	address<span class="token punctuation">.</span>sin_family<span class="token operator">=</span>AF_INET<span class="token punctuation">;</span>
	<span class="token function">inet_pton</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span>ip<span class="token punctuation">,</span><span class="token operator">&amp;</span>address<span class="token punctuation">.</span>sin_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	address<span class="token punctuation">.</span>sin_port<span class="token operator">=</span><span class="token function">htons</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> listenfd<span class="token operator">=</span><span class="token function">socket</span><span class="token punctuation">(</span>PF_INET<span class="token punctuation">,</span>SOCK_STREAM<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>listenfd<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	ret<span class="token operator">=</span><span class="token function">bind</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"errno is%d\n"</span><span class="token punctuation">,</span>errno<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	ret<span class="token operator">=</span><span class="token function">listen</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>ret<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	epoll_event events<span class="token punctuation">[</span>MAX_EVENT_NUMBER<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> epollfd<span class="token operator">=</span><span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>epollfd<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">addfd</span><span class="token punctuation">(</span>epollfd<span class="token punctuation">,</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">/*使用socketpair创建管道，注册pipefd[0]上的可读事件*/</span>
	ret<span class="token operator">=</span><span class="token function">socketpair</span><span class="token punctuation">(</span>PF_UNIX<span class="token punctuation">,</span>SOCK_STREAM<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>pipefd<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>ret<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">setnonblocking</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">addfd</span><span class="token punctuation">(</span>epollfd<span class="token punctuation">,</span>pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">/*设置一些信号的处理函数*/</span>
	<span class="token function">addsig</span><span class="token punctuation">(</span>SIGHUP<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">addsig</span><span class="token punctuation">(</span>SIGCHLD<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">addsig</span><span class="token punctuation">(</span>SIGTERM<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">addsig</span><span class="token punctuation">(</span>SIGINT<span class="token punctuation">)</span><span class="token punctuation">;</span>
    bool stop_server<span class="token operator">=</span>false<span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stop_server<span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">int</span> number<span class="token operator">=</span><span class="token function">epoll_wait</span><span class="token punctuation">(</span>epollfd<span class="token punctuation">,</span>events<span class="token punctuation">,</span>MAX_EVENT_NUMBER<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>number<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>errno<span class="token operator">!=</span>EINTR<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"epoll failure\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>number<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token keyword">int</span> sockfd<span class="token operator">=</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd<span class="token punctuation">;</span>
			<span class="token comment">/*如果就绪的文件描述符是listenfd，则处理新的连接*/</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>sockfd<span class="token operator">==</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">{</span>
				<span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> client_address<span class="token punctuation">;</span>
				<span class="token class-name">socklen_t</span> client_addrlength<span class="token operator">=</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>client_address<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">int</span> connfd<span class="token operator">=</span><span class="token function">accept</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>client_address<span class="token punctuation">,</span><span class="token operator">&amp;</span>client_addrlength<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token function">addfd</span><span class="token punctuation">(</span>epollfd<span class="token punctuation">,</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token comment">/*如果就绪的文件描述符是pipefd[0]，则处理信号*/</span>
			<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>sockfd<span class="token operator">==</span>pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events<span class="token operator">&amp;</span>EPOLLIN<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
				<span class="token keyword">int</span> sig<span class="token punctuation">;</span>
				<span class="token keyword">char</span> signals<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
				ret<span class="token operator">=</span><span class="token function">recv</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>signals<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>signals<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
					<span class="token keyword">continue</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
					<span class="token keyword">continue</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">else</span><span class="token punctuation">{</span>
					<span class="token comment">/*因为每个信号值占1字节，所以按字节来逐个接收信号。我们以SIGTERM为例，来说明如何安全地终止服务器主循环*/</span>
					<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>ret<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>
						<span class="token keyword">switch</span><span class="token punctuation">(</span>signals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
							<span class="token keyword">case</span> SIGCHLD<span class="token operator">:</span>
							<span class="token keyword">case</span> SIGHUP<span class="token operator">:</span><span class="token punctuation">{</span>
								<span class="token keyword">continue</span><span class="token punctuation">;</span>
							<span class="token punctuation">}</span>
							<span class="token keyword">case</span> SIGTERM<span class="token operator">:</span>
							<span class="token keyword">case</span> SIGINT<span class="token operator">:</span><span class="token punctuation">{</span>
								stop_server<span class="token operator">=</span>true<span class="token punctuation">;</span>
							<span class="token punctuation">}</span>
                        <span class="token punctuation">}</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"close fds\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="网络编程相关信号"><a href="#网络编程相关信号" class="headerlink" title="网络编程相关信号"></a>网络编程相关信号</h2><h3 id="SIGHUP"><a href="#SIGHUP" class="headerlink" title="SIGHUP"></a>SIGHUP</h3><p>当挂起进程的控制终端时，SIGHUP信号将被触发；对于没有控制终端的网络后台程序而言，它们通常利用SIGHUP信号来强制服务器重读配置文件</p>
<h3 id="SIGPIPE"><a href="#SIGPIPE" class="headerlink" title="SIGPIPE"></a>SIGPIPE</h3><p>默认情况下，往一个读端关闭的管道或socket连接中写数据将引发SIGPIPE信号，程序接收到SIGPIPE信号的默认行为时结束进程，引起SIGPIPE信号的写操作将设置errno为EPIPE</p>
<h3 id="SIGURG"><a href="#SIGURG" class="headerlink" title="SIGURG"></a>SIGURG</h3><p>通知带外数据是否到达</p>
]]></content>
      <tags>
        <tag>C++ socket</tag>
      </tags>
  </entry>
  <entry>
    <title>回文自动机(PAM)</title>
    <url>/2022/12/02/%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA-PAM/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>​    给定一个字符串<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex;" xmlns="http://www.w3.org/2000/svg" width="1.061ex" height="1.023ex" role="img" focusable="false" viewBox="0 -442 469 452"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g></g></g></svg></mjx-container>，求字符串<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex;" xmlns="http://www.w3.org/2000/svg" width="1.061ex" height="1.023ex" role="img" focusable="false" viewBox="0 -442 469 452"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g></g></g></svg></mjx-container>有多少个不同的回文子串？</p>
<p>​    如果使用<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="10.486ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 4635 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"></path></g><g data-mml-node="mi" transform="translate(1051,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(1580,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(2180,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(2709,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mi" transform="translate(3142,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g><g data-mml-node="mi" transform="translate(3718,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(4184,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container>算法来获得字符串中每个字符为中心的最长回文半径，再用<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="5.57ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 2462 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mi" transform="translate(888,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(1417,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(1886,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g></g></g></svg></mjx-container>来查重所有的回文子串，时间复杂度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="6.606ex" height="2.452ex" role="img" focusable="false" viewBox="0 -833.9 2919.8 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mn" transform="translate(975.3,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(2530.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container><del>（如果使用其他查重方式，时间复杂度可能更高）</del>，而<strong>回文自动机</strong>则能够以<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.495ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2429 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mo" transform="translate(2040,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>的时间复杂度来完成一些<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="10.486ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 4635 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"></path></g><g data-mml-node="mi" transform="translate(1051,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(1580,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(2180,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(2709,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mi" transform="translate(3142,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g><g data-mml-node="mi" transform="translate(3718,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(4184,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container>算法难以处理的回文串问题。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>​    回文自动机，也叫回文树，是一种在2014年发明的数据结构。</p>
<p>​    回文自动机，就是使用字典树来保存所有回文子串的回文半径，使用两棵树来分别保存偶数串和奇数串，<del>也可以像<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="10.486ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 4635 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"></path></g><g data-mml-node="mi" transform="translate(1051,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(1580,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(2180,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(2709,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mi" transform="translate(3142,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g><g data-mml-node="mi" transform="translate(3718,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(4184,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container>一样通过插入无意义的字符来只构建一棵树，但是这样处理起来比较麻烦</del>，在树上的一个节点代表一个回文子串，在最后使用节点数-2（减去两个根节点）就得到了不同回文子串的位置。</p>
<p>​    对于一个已知的字符串<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="13.294ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 5876 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(529,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(958,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(1387,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mi" transform="translate(1820,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(2249,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(2678,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(3107,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mi" transform="translate(3540,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(3969,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(4398,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(4827,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(5356,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g></g></g></svg></mjx-container>，假设我们已经遍历了<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="9.95ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 4398 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(529,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(958,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(1387,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mi" transform="translate(1820,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(2249,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(2678,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(3107,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mi" transform="translate(3540,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(3969,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g></g></g></svg></mjx-container>，当我们遍历下一个字符<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.971ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 429 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g></g></g></svg></mjx-container>时，会进行如下判断：</p>
<span id="more"></span>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202212212051013.png" alt="202212021838948"></p>
<p>​    依次与包含前一个字符的回文子串从长到短进行匹配，匹配成功时则插入，都不匹配时，最后与自身匹配，为仅有一个字符的回文子串。</p>
<h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>​    那么如何构建回文树呢？</p>
<p>​    我们首先定义如下变量：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int len[];  //len[u]表示回文树中u节点代表的回文串的长度
int trie[][]; //trie[u][c]表示编号为u的节点代表的回文串在两头加上字符c后的回文串的编号
int fail[];  //fail[u]表示节点u失配后跳转到不等于自身的最长后缀回文串的编号（如上图）
int cnt[];  //cnt[u]表示节点u所代表的回文串在整个字符串中出现了多少次
int num[];  //num[u]表示u节点所代表的回文串有多少个本质不同的后缀回文子串
int last;  //表示上一次插入字符的节点的编号
int tot;   //有多少个节点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    首先我们定义两个节点，0号节点和1号节点，0号节点是偶树的根，1号节点则为奇树的根，初始化数据为：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">len[0]=0;//偶树每添加一个节点长度+2
len[1]=-1;//奇树中间节点只算一次，所以是-1
fail[0]=fail[1]=1;//新插入一个字符无论如何也能形成一个回文串（只有自身），所以fail[0]指向1号节点，而1号节点指向自身（无所谓）
last=0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    下面为字符串<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="12.945ex" height="1.756ex" role="img" focusable="false" viewBox="0 -694 5721.6 776"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(469,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(830,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1558.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(2614.6,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(3143.6,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(3572.6,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(4001.6,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mi" transform="translate(4434.6,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(4863.6,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(5292.6,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g></g></g></svg></mjx-container>的回文树构建过程：</p>
<p>初始化：</p>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202212212052224.png" alt="image-20221202200101839"></p>
<p>插入第一个字符<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex;" xmlns="http://www.w3.org/2000/svg" width="1.197ex" height="1.02ex" role="img" focusable="false" viewBox="0 -441 529 451"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g></g></g></svg></mjx-container>:</p>
<p>首先last指向0，我们先获取<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="34.95ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 15448 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(469,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(830,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1281,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mn" transform="translate(1559,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mo" transform="translate(2281.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(3281.4,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(3579.4,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(4045.4,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(4645.4,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(4923.4,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(5221.4,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(5750.4,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(6219.4,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mo" transform="translate(6580.4,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(7080.7,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(8080.9,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(8580.9,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(9136.7,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(10192.4,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(10661.4,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(11022.4,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(11473.4,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mo" transform="translate(11751.4,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(12529.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(13029.4,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(13307.4,0)"><path data-c="21" d="M78 661Q78 682 96 699T138 716T180 700T199 661Q199 654 179 432T158 206Q156 198 139 198Q121 198 119 206Q118 209 98 431T78 661ZM79 61Q79 89 97 105T141 121Q164 119 181 104T198 61Q198 31 181 16T139 1Q114 1 97 16T79 61Z"></path></g><g data-mml-node="mo" transform="translate(13863.2,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(14919,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g></g></g></svg></mjx-container>，则将<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="19.817ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 8759.1 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(298,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(827,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(1296,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mo" transform="translate(1934.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(2990.6,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mi" transform="translate(3540.6,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(4069.6,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(4414.6,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mo" transform="translate(4712.6,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(4990.6,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(5288.6,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(5817.6,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(6286.6,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mo" transform="translate(6647.6,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(7203.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(8259.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container>，发现<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="32.561ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 14392 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(469,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(830,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1281,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mn" transform="translate(1559,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mo" transform="translate(2281.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(3281.4,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(3579.4,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(4045.4,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(4645.4,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(4923.4,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(5221.4,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(5750.4,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(6219.4,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mo" transform="translate(6580.4,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(7080.7,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(8080.9,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(8580.9,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(9136.7,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(10192.4,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(10661.4,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(11022.4,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(11473.4,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mn" transform="translate(11751.4,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mo" transform="translate(12251.4,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(12807.2,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(13863,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g></g></g></svg></mjx-container>，则在1号节点下新建节点插入<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex;" xmlns="http://www.w3.org/2000/svg" width="1.197ex" height="1.02ex" role="img" focusable="false" viewBox="0 -441 529 451"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g></g></g></svg></mjx-container>。</p>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202212212053362.png" alt="202212022048948"></p>
<p>插入第二个字符b：</p>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202212212053645.png" alt="202212022047647"></p>
<p>插入第三个字符b：</p>
<ul>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="32.964ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 14570 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(469,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(830,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1281,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mn" transform="translate(1559,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(2281.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(3281.4,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(3579.4,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(4045.4,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(4645.4,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(4923.4,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(5221.4,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(5750.4,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(6219.4,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mo" transform="translate(6580.4,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(7080.7,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(8080.9,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(8580.9,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(9136.7,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(10192.4,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(10661.4,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(11022.4,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(11473.4,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mn" transform="translate(11751.4,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mo" transform="translate(12251.4,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(12529.4,0)"><path data-c="21" d="M78 661Q78 682 96 699T138 716T180 700T199 661Q199 654 179 432T158 206Q156 198 139 198Q121 198 119 206Q118 209 98 431T78 661ZM79 61Q79 89 97 105T141 121Q164 119 181 104T198 61Q198 31 181 16T139 1Q114 1 97 16T79 61Z"></path></g><g data-mml-node="mo" transform="translate(13085.2,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(14141,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g></g></g></svg></mjx-container></li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="19.817ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 8759.1 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(298,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(827,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(1296,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mo" transform="translate(1934.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(2990.6,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mi" transform="translate(3540.6,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(4069.6,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(4414.6,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mo" transform="translate(4712.6,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(4990.6,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(5288.6,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(5817.6,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(6286.6,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mo" transform="translate(6647.6,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(7203.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(8259.1,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></svg></mjx-container></li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="32.335ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 14292 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(469,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(830,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1281,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mn" transform="translate(1559,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(2281.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(3281.4,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(3579.4,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(4045.4,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(4645.4,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(4923.4,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(5221.4,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(5750.4,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(6219.4,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mo" transform="translate(6580.4,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(7080.7,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(8080.9,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(8580.9,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(9136.7,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(10192.4,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(10661.4,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(11022.4,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(11473.4,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mn" transform="translate(11751.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(12251.4,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(12807.2,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(13863,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g></g></g></svg></mjx-container></li>
<li>在0号节点下新建b节点</li>
<li>接下来求<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="3.896ex" height="2.059ex" role="img" focusable="false" viewBox="0 -705 1722 910"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mi" transform="translate(550,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(1079,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1424,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g></g></g></svg></mjx-container></li>
<li>令<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="19.817ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 8759.1 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(298,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(827,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(1296,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mo" transform="translate(1934.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(2990.6,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mi" transform="translate(3540.6,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(4069.6,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(4414.6,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mo" transform="translate(4712.6,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(4990.6,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(5288.6,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(5817.6,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(6286.6,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mo" transform="translate(6647.6,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(7203.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(8259.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container>（不能指向自身）</li>
<li>判断<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="28.347ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 12529.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(469,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(830,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1281,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mn" transform="translate(1559,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(2281.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(3281.4,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(3579.4,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(4045.4,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(4645.4,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(4923.4,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(5221.4,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(5750.4,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(6219.4,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mo" transform="translate(6580.4,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(7080.7,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(8080.9,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(8580.9,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(9136.7,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(10192.4,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(10661.4,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(11022.4,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(11473.4,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mn" transform="translate(11751.4,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(12251.4,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g></g></g></svg></mjx-container>是否等于b</li>
<li>再判断1节点下有没有为b的子节点，有就指向，没有则继续更新<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="3.749ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 1657 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(298,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(827,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(1296,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g></g></g></svg></mjx-container></li>
<li>节点1下有为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.971ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 429 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g></g></g></svg></mjx-container>的节点（即存在<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.539ex" height="2.283ex" role="img" focusable="false" viewBox="0 -759 4216.5 1009"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(361,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(812,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1157,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mo" transform="translate(1623,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mn" transform="translate(1901,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(2401,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(2679,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mo" transform="translate(2957,0)"><path data-c="2035" d="M12 501Q12 527 31 542T63 558Q73 560 77 560Q114 560 128 528Q133 518 188 293T244 61Q244 56 223 50T195 43Q192 43 190 45T102 263T14 486Q12 496 12 501Z"></path></g><g data-mml-node="msup" transform="translate(3232,0)"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(462,363) scale(0.707)"><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"></path></g></g><g data-mml-node="mo" transform="translate(3938.5,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g></g></g></svg></mjx-container>），编号为3，则将<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="6.285ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2778 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mi" transform="translate(550,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(1079,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1424,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mo" transform="translate(1722,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mn" transform="translate(2000,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(2500,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g></g></g></svg></mjx-container>指向3</li>
<li>最后将<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="3.749ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 1657 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(298,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(827,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(1296,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g></g></g></svg></mjx-container>指向4</li>
</ul>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202212212054705.png" alt="202212022107319"></p>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202212212054443.png" alt="202212022111341"></p>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202212212055112.png" alt="202212022147852"></p>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202212212056858.png" alt="image-20221202215150351"></p>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202212212056070.png" alt="image-20221202220630334"></p>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202212212056276.png" alt="image-20221202220946755"></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;string&gt;

const int MAXN=1e6+7;
int len[MAXN],num[MAXN],fail[MAXN],cnt[MAXN];
int trie[MAXN][26],tot=1,last;
std::string str;

int getfail(int x,int u){
    while(u-len[x]-1&lt;0 || str[u-len[x]-1]!=str[u]) x=fail[x];
    return x;
}

int main(){
    std::cin&gt;&gt;str;
    int n=str.length();
    len[0]=0;len[1]=-1;
    fail[0]=fail[1]=1;
    for(int i=0;i&lt;n;++i){
        int u=last;
        u=getfail(u,i);
        if(!trie[u][str[i]-'a']){
			fail[++tot]=trie[getfail(fail[u],i)][str[i]-'a'];
            trie[u][str[i]-'a']=tot;
        	len[tot]=len[u]+2;
            num[tot]=num[fail[tot]]+1;
        }
        last=trie[u][str[i]-'a'];
        ++cnt[last];
	}
    for(int i=tot;i&gt;=2;--i){
        cnt[fail[i]]+=cnt[i];
    }
    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ul>
<li><a href="https://www.luogu.com.cn/problem/P5496">洛谷P5496</a></li>
<li><a href="https://www.luogu.com.cn/problem/P3649">洛谷P3649</a></li>
<li><a href="https://www.luogu.com.cn/problem/P4287">洛谷P4287</a></li>
</ul>
]]></content>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统—第一章—计算机系统概述</title>
    <url>/2023/09/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h2 id="1-1操作系统的基本概念-Operating-System"><a href="#1-1操作系统的基本概念-Operating-System" class="headerlink" title="1.1操作系统的基本概念 Operating System"></a>1.1操作系统的基本概念 Operating System</h2><h3 id="操作系统的概念"><a href="#操作系统的概念" class="headerlink" title="操作系统的概念"></a>操作系统的概念</h3><ul>
<li>控制和管理整个计算机系统的硬件与软件资源，合理地组织、调度计算机的工作与资源的分配，进而为用户和其他软件提供方便接口与环境的程序的集合</li>
<li>操作系统是计算机系统中最基本的系统软件</li>
<li>计算机系统自上而下可大致分为4部分<ul>
<li>硬件、操作系统、应用程序、用户</li>
</ul>
</li>
</ul>
<span id="more"></span>
<h3 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h3><ul>
<li>并发<ul>
<li>并发是指两个或多个事件在<strong>同一个时间间隔</strong>内发生</li>
<li>并发 和 并行 的区别：注意与并行（<strong>同一时刻</strong>）的区别</li>
</ul>
</li>
<li>共享<ul>
<li>互斥共享方式：比如打印机、磁带机虽然可以供多个进程使用，但是一段时间内只运行一个进程访问该资源</li>
<li>同时访问方式：比如键盘等</li>
</ul>
</li>
<li><p>虚拟</p>
<ul>
<li>虚拟是指把一个物理上的实体变为若干逻辑上的对应物</li>
<li>虚拟技术<ul>
<li>时分复用技术，如处理器的分时共享</li>
<li>空分复用技术，如虚拟存储器</li>
</ul>
</li>
</ul>
</li>
<li><p>异步</p>
</li>
<li><p>操作系统两个最基本的特征是——并发和共享</p>
</li>
</ul>
<h3 id="操作系统的目标和功能"><a href="#操作系统的目标和功能" class="headerlink" title="操作系统的目标和功能"></a>操作系统的目标和功能</h3><h4 id="操作系统作为计算机系统资源的管理者"><a href="#操作系统作为计算机系统资源的管理者" class="headerlink" title="操作系统作为计算机系统资源的管理者"></a>操作系统作为计算机系统资源的管理者</h4><ul>
<li>处理机管理</li>
<li>存储器管理</li>
<li>文件管理</li>
<li>设备管理</li>
</ul>
<h4 id="操作系统作为用户与计算机硬件系统之间的接口"><a href="#操作系统作为用户与计算机硬件系统之间的接口" class="headerlink" title="操作系统作为用户与计算机硬件系统之间的接口"></a>操作系统作为用户与计算机硬件系统之间的接口</h4><ul>
<li>命令接口<ul>
<li>脱机命令接口 | 批处理命令接口 —— 适用于批处理系统</li>
<li>联机命令接口 | 交互式命令接口 —— 适用于分时或实时系统的接口</li>
</ul>
</li>
<li>程序接口<ul>
<li>概念：程序接口由一系列系统调用（也称广义指令）组成</li>
<li>应用：图形用户界面 GUI</li>
<li>用户通过在程序中使用这些系统调用来请求操作系统为其提供服务</li>
</ul>
</li>
</ul>
<h4 id="操作系统实现了对计算机资源的扩充"><a href="#操作系统实现了对计算机资源的扩充" class="headerlink" title="操作系统实现了对计算机资源的扩充"></a>操作系统实现了对计算机资源的扩充</h4><ul>
<li>没有任何软件支持的计算机称为裸机</li>
<li>把覆盖了软件的机器称为扩充机器或虚拟机</li>
</ul>
<h3 id="库函数和系统调用"><a href="#库函数和系统调用" class="headerlink" title="库函数和系统调用"></a>库函数和系统调用</h3><p>库函数是语言或应用程序的一部分，可以运行在用户空间中</p>
<p>而系统调用是操作系统的一部分，是内核为用户提供的程序接口，运行在内核空间中，而且许多库函数都会使用系统调用来实现功能<br>未使用系统调用的库函数，其执行效率通常要比系统调用的高。因为使用系统调用时，需要上下文的切换及状态的转换（由用户态转向核心态）</p>
<h2 id="1-2-操作系统的发展与分类"><a href="#1-2-操作系统的发展与分类" class="headerlink" title="1.2 操作系统的发展与分类"></a>1.2 操作系统的发展与分类</h2><ul>
<li>手工操作阶段<ul>
<li>人机矛盾（速度和资源利用）越来越大</li>
<li>缺点<ul>
<li>用户独占全机，虽然不会出现因资源已被其他用户占用而等待的现象，但资源利用率低</li>
<li>CPU等待手工操作，CPU的利用不充分</li>
</ul>
</li>
</ul>
</li>
<li>批处理阶段<ul>
<li>单道批处理系统<ul>
<li>自动性 ~在顺利的情况下，磁带上的一批作业能自动逐个运行，无须人工干预~</li>
<li>顺序性 ~磁带上的各道作业顺序地进入内存，各道作业的完成顺序与它们进入内存的顺序在正常情况下完全相同，即先调入内存的作业先完成~</li>
<li>单道性 ~内存中仅有一道程序运行，即监督程序每次从磁带上只调入一道程序进入内存运行，当该程序完成或发生异常时，才换入后继程序~</li>
</ul>
</li>
<li>多道批处理<ul>
<li>多道~计算机内存中同时存放多道相互独立的程序~ </li>
<li>宏观上并行~同时进入系统的多道程序都处于运行过程中，即它们先后开始各自的运行，但都未运行完毕~</li>
<li>微观上串行~内存中的多道程序轮流占用着CPU，交替执行~</li>
<li>优点：资源利用率高，吞吐量大</li>
<li>缺点：用户响应时间长，不提供人机交互能力</li>
</ul>
</li>
</ul>
</li>
<li>分时操作系统<ul>
<li>按时间片轮流把处理器分配给各联机作业使用</li>
<li>特征<ul>
<li>同时性（多路性）~多个终端用户同时使用一台计算机~</li>
<li>交互性</li>
<li>独立性~多个用户彼此独立地进行操作~</li>
<li>及时性</li>
</ul>
</li>
<li>响应时间 T ≈ QN<ul>
<li>时间片一定的时候，用户数越多，响应时间越长</li>
<li>含义：T是响应时间，Q是时间片，N是用户数</li>
</ul>
</li>
<li>较好地解决了人机交互问题</li>
</ul>
</li>
<li>实时操作系统<ul>
<li>硬实时系统——某个动作必须绝对地在规定的时刻发生</li>
<li>软实时系统——能够接受偶尔违反时间规定且不会引起任何永久性的损害</li>
<li>特点：及时性、可靠性+</li>
</ul>
</li>
<li>网络操作系统和分布式操作系统</li>
<li>个人计算机操作系统<ul>
<li>此外还有嵌入式操作系统，服务操作系统，智能手机操作系统</li>
</ul>
</li>
</ul>
<h2 id="1-3-操作系统的运行环境"><a href="#1-3-操作系统的运行环境" class="headerlink" title="1.3 操作系统的运行环境"></a>1.3 操作系统的运行环境</h2><h3 id="操作系统的运行机制"><a href="#操作系统的运行机制" class="headerlink" title="操作系统的运行机制"></a>操作系统的运行机制</h3><ul>
<li>程序分类<ul>
<li>操作系统内核程序：执行特权指令<ul>
<li>特权指令：指计算机中不允许被用户直接使用的指令</li>
</ul>
</li>
<li>用户自编程序（应用程序）<ul>
<li>非特权指令：允许用户直接使用的指令~它不能直接访问系统中的软硬件资源，仅限于访问用户的地址空间~</li>
</ul>
</li>
<li>内核程序 是 应用程序 的管理程序</li>
</ul>
</li>
<li>CPU 状态<ul>
<li>用户态 / 目态<ul>
<li>可以在用户态下执行的指令 ↓<ul>
<li>读时钟指令（置时钟不行）</li>
<li>取数指令</li>
<li>寄存器清零指令</li>
<li>算术运算</li>
<li>访管指令<ul>
<li>访管中断<ul>
<li><strong>访管指令</strong>是一条可以在<strong>用户态</strong>下执行的指令。在用户程序中，因要求操作系统提供服务而有意识地使用访管中断，从而产生一个中断事件（自愿中断），将操作系统转换为<strong>核心态</strong>，称为访管中断</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>核心态/管态/内核态<ul>
<li>只能在核心态执行的指令―输入/输出指令 系统调用（广义指令）</li>
</ul>
</li>
<li>CPU 状态之间的转换<ul>
<li>用户态 —&gt; 内核态―中断、异常、访管指令——由硬件完成</li>
<li>内核态 —&gt; 用户态―设置程序状态字</li>
</ul>
</li>
</ul>
</li>
<li>大多数操作系统的内核分为 4 方面内容<ul>
<li>时钟管理</li>
<li>中断机制</li>
<li>原语 Atomic Operation<ul>
<li>处于操作系统的最底层，是最接近硬件的部分</li>
<li>这些程序的运行具有原子性，其操作只能一气呵成（主要从系统安全性和便于管理考虑），不能中断</li>
<li>这些程序的运行时间较短</li>
</ul>
</li>
<li>系统控制的数据结构及处理<ul>
<li>进程管理：进程状态管理、进程调度和分配、创建与撤销进程控制块等</li>
<li>存储器管理：存储器的空间分配和回收、内存信息保护程序、代码对换程序等</li>
<li>设备管理：缓冲区管理、设备分配和回收等</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="中断和异常的概念"><a href="#中断和异常的概念" class="headerlink" title="中断和异常的概念"></a>中断和异常的概念</h3><ul>
<li><p>中断和异常的定义</p>
<ul>
<li>中断也称外中断，指来自 CPU 执行指令以外的事件的发生，如设备发出的 I/O 结束中断或时钟中断<ul>
<li>可屏蔽中断~通过INTR线发出的中断~</li>
<li>不可屏蔽中断~通过NMI线发出的中断~</li>
<li>属于硬件中断</li>
</ul>
</li>
<li>异常也称内中断，指源自 CPU 执行指令内部的事件，如程序的非法操作码、地址越界、算术溢出、虚存系统的缺页及专门的陷入指令，比如访管指令<ul>
<li>软件中断（程序性异常）<ul>
<li>故障——通常是由指令执行引起的异常</li>
<li>自陷——一种事先安排的“异常”事件，用于在用户态下调用操作系统内核程序</li>
</ul>
</li>
<li>硬件中断</li>
<li>终止——出现了使得CPU无法继续执行的硬件故障</li>
</ul>
</li>
</ul>
</li>
<li><p>中断处理的过程 ↓</p>
<ol>
<li>关中断（中断状态寄存器）</li>
<li>保存断点：程序计数器 PC</li>
<li>中断服务程序寻址：程序状态字寄存器 PSWR</li>
<li>保存现场和屏蔽字</li>
<li>开中断</li>
<li>执行中断程序服务</li>
<li>关中断</li>
<li>恢复现场和屏蔽字</li>
<li>开中断、中断返回</li>
</ol>
<ul>
<li>1-3 步是在 CPU 进入中断周期后，由硬件自动（中断隐指令）完成</li>
<li>4-9 步由中断服务程序完成</li>
</ul>
</li>
<li><p>系统调用</p>
<ul>
<li>设备管理——完成设备的请求或释放，以及设备启动等功能</li>
<li>文件管理——完成文件的读、写、创建及删除等功能</li>
<li>进程控制——完成进程的创建、撤销、阻塞及唤醒等功能</li>
<li>进程通信——完成进程之间的消息传递或信号传递等功能</li>
<li>内存管理——完成内存的分配、回收以及获取作业占用内存区大小及始址等功能</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202308242018667.png" alt="image-20230824201838196"></li>
</ul>
</li>
</ul>
<h2 id="1-4-操作系统的体系结构"><a href="#1-4-操作系统的体系结构" class="headerlink" title="1.4 操作系统的体系结构"></a>1.4 操作系统的体系结构</h2><h3 id="分层结构"><a href="#分层结构" class="headerlink" title="分层结构"></a>分层结构</h3><ul>
<li>将操作系统分为若干层，最底层是硬件，最高层为用户接口</li>
<li>每层只能调用紧邻它的低层的功能和服务（单向依赖）</li>
<li>优点：<ul>
<li>便于系统的调试和验证，简化了系统的设计和实现</li>
<li>易扩充和易维护</li>
</ul>
</li>
<li>问题：<ul>
<li>仅可调用相邻底层，难以合理定义各层的边界</li>
<li>效率低，不可跨层调用，系统调用执行时间长</li>
</ul>
</li>
</ul>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><ul>
<li>模块化是将操作系统按功能划分为若干具有一定独立性的模块</li>
<li>衡量独立性标准<ul>
<li>内聚性，模块内部各部分间联系的紧密程度。内聚性越高，模块独立性越好</li>
<li>耦合度，模块间相互联系和相互影响的程度。耦合度越低，模块独立性越好</li>
</ul>
</li>
<li>优点：<ul>
<li>提高了操作系统设计的正确性、可理解性和可维护性</li>
<li>增强了操作系统的可适应性</li>
<li>加速了操作系统的开发过程</li>
</ul>
</li>
<li>缺点：<ul>
<li>模块间的接口规定很难满足对接口的实际需求</li>
<li>各模块设计者齐头并进，每个决定无法建立在上一个已验证的正确决定的基础上，因此无法找到一个可靠的决定顺序</li>
</ul>
</li>
</ul>
<h3 id="大内核和微内核"><a href="#大内核和微内核" class="headerlink" title="大内核和微内核"></a>大内核和微内核</h3><ul>
<li>大内核（宏内核/单内核）<ul>
<li>将操作系统的主要功能模块都作为系统内核，运行在核心态</li>
<li>优点：高性能</li>
<li>缺点：内核代码庞大，结构混论，难以维护</li>
<li>Linux、UNIX</li>
</ul>
</li>
<li>微内核<ul>
<li>只把最基本的功能保留在内核</li>
<li>将操作系统划分为两大部分<ul>
<li>微内核<ul>
<li>精心设计的、能实现操作系统最基本核心功能的小型内核<ul>
<li>与硬件处理紧密相关的部分</li>
<li>一些较基本的问题</li>
<li>客户和服务器之间的通信</li>
</ul>
</li>
</ul>
</li>
<li>多个服务器<ul>
<li>运行在用户态</li>
</ul>
</li>
</ul>
</li>
<li>基本功能<ul>
<li>进程（线程）管理</li>
<li>低级存储器管理</li>
<li>中断和陷入处理</li>
</ul>
</li>
<li>优点<ul>
<li>扩展性和灵活性</li>
<li>可靠性和安全性</li>
<li>可移植性</li>
<li>分布式计算</li>
</ul>
</li>
<li>缺点：需要频繁地在核心态和用户态之间切换，性能低</li>
<li>微内核结构通常利用”机制与策略分离“的原理来构造内核OS结构，基于C/S模式</li>
<li>Windows NT</li>
</ul>
</li>
</ul>
<h3 id="外核"><a href="#外核" class="headerlink" title="外核"></a>外核</h3><ul>
<li>外核负责为用户进程分配未经抽象的硬件资源，且有外核负责资源使用安全</li>
<li>优点<ul>
<li>外核可直接给用户进程分配“不虚拟、不抽象”的硬件资源，使用户进程可以更灵活的使用硬件资源</li>
<li>减少了虚拟硬件资源的“映射层”。提高效率</li>
</ul>
</li>
<li>缺点<ul>
<li>降低了系统的一致性</li>
<li>使系统变得更复杂 </li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/202308251654601.png" alt="image-20230825165435284"></p>
<h2 id="1-5-操作系统引导"><a href="#1-5-操作系统引导" class="headerlink" title="1.5 操作系统引导"></a>1.5 操作系统引导</h2><ul>
<li>激活CPU ~激活的CPU读取ROM中的boot程序，将指令寄存器置为BIOS（基本输入/输出系统）的第一条指令，即开始执行BIOS的指令~</li>
<li>硬件自检~启动BIOS程序后，先进行硬件自检，检查硬件是否出现故障，如有故障，主板会发出不同含义的蜂鸣，启动中止；如无故障，屏幕会显示CPU、内存、硬盘等信息~</li>
<li>加载带有操作系统的硬盘~硬件自检后，BIOS开始读取Boot\ Sequence（通过CMOS里保存的启动顺序，或者通过与用户交互的方式），把控制权交给启动顺序排在第一位的存储设备，然后CPU将该存储设备引导扇区的内容加载到内存中~</li>
<li>加载主引导记录MBR~硬盘以特定的标识符区分引导硬盘和非引导硬盘。如果发现一个存储设备不是可引导盘，就检查下一个存储设备。如无其他启动设备，就会死机。主引导记录MBR的作用是告诉CPU去硬盘的哪个主分区去找操作系统~</li>
<li>扫描硬盘风区表，并加载硬盘活动分区~MBR包含硬盘分区表，硬盘分区表以特定的标识符号区分活动分区和非活动分区。主引导记录扫描硬盘分区表，进而识别含有操作系统的硬盘分区（活动分区）。找到硬盘活动分区后，开始加载硬盘活动分区，将控制权交给活动分区~</li>
<li>加载分区引导记录PBR~读取活动分区的第一个扇区，这个扇区称为分区引导记录（PBR），其作用是寻找并激活分区根目录下用于引导操作系统的程序（启动管理器）~</li>
<li>加载启动管理器~分区引导记录搜索活动分区中的启动管理器，加载启动管理器~</li>
<li>加载操作系统</li>
</ul>
<h2 id="1-6-虚拟机"><a href="#1-6-虚拟机" class="headerlink" title="1.6 虚拟机"></a>1.6 虚拟机</h2><ul>
<li>虚拟即是一台逻辑计算机，是指利用特殊的虚拟化技术，通过隐藏特定计算平台的实际物理特性，为用户提供抽象的、统一的、模拟的计算环境</li>
<li><strong>第一类虚拟机管理程序</strong><ul>
<li>就像一个操作系统，是唯一一个运行在最高特权级的程序，在裸机上运行并且具有多道程序功能</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202308251731029.png" alt="image-20230825173133557"></li>
</ul>
</li>
<li><strong>第二类虚拟机管理程序</strong><ul>
<li>VMware Workstation</li>
<li>运行在两类虚拟机管理程序上的操作系统都称为客户操作系统，对于第二类，运行在底层的操作系统称为宿主操作系统</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202308251731357.png" alt="image-20230825173147236"></li>
</ul>
</li>
<li>虚拟机作为用户态的一个进程运行，不允许执行敏感指令</li>
<li>虚拟机上的操作系统认为自己运行在内核态（实际不是），称为虚拟内核态</li>
<li>虚拟机中的用户进程认为自己运行在用户态（实际上确实是）</li>
<li>当虚拟操作系统执行一条特权指令时，会陷入虚拟机管理程序</li>
</ul>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/202308251702236.png" alt="image-20230825170205827"></p>
]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统—第三章—内存管理</title>
    <url>/2023/09/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h2 id="3-1-内存管理概念"><a href="#3-1-内存管理概念" class="headerlink" title="3.1 内存管理概念"></a>3.1 内存管理概念</h2><h3 id="3-1-1内存管理的基本原理和要求"><a href="#3-1-1内存管理的基本原理和要求" class="headerlink" title="3.1.1内存管理的基本原理和要求"></a>3.1.1内存管理的基本原理和要求</h3><p><strong>内存管理的功能</strong></p>
<ul>
<li><p>内存空间的分配与回收</p>
<ul>
<li>由操作系统完成主存储器空间的分配和管理，使程序员摆脱存储分配的麻烦，提高编程效率</li>
</ul>
</li>
<li><p>地址转换</p>
<ul>
<li>在多道程序环境下，程序中的逻辑地址与内存中的物理地址不可能一致，因此存储管理必须提供地址变换功能，把逻辑地址转换成相应的物理地址</li>
</ul>
</li>
<li><p>内存空间的扩充</p>
<ul>
<li>利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存</li>
</ul>
</li>
<li><p>内存共享</p>
<ul>
<li>指允许多个进程访问内存的同一部分</li>
</ul>
</li>
<li><p>存储保护</p>
<ul>
<li>保证各道作业在各自的存储空间内运行，互不干扰</li>
</ul>
</li>
</ul>
<span id="more"></span>
<p><strong>程序装入和链接</strong></p>
<ul>
<li>步骤<ul>
<li>编译<ul>
<li>由编译程序将用户源代码编译成若干目标模块</li>
</ul>
</li>
<li>链接<ul>
<li>由链接程序将编译后形成的一组目标模块及™所需的库函数链接在一起，形成一个完整的装入模块</li>
</ul>
</li>
<li>装入<ul>
<li>由转装入程序将装入模块装入内存运行</li>
</ul>
</li>
</ul>
</li>
<li>程序的链接方式<ul>
<li>静态链接<ul>
<li>在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开</li>
</ul>
</li>
<li>装入时动态链接<ul>
<li>将各目标模块装入内存时，边装入边链接的链接方式，其优点是便于修改和更新，便于实现对目标模块的共享</li>
</ul>
</li>
<li>运行时动态链接<ul>
<li>在程序执行中需要该目标模块时，才对它进行链接，其优点是能加快程序的装入过程，还可节省大量的内存空间</li>
</ul>
</li>
</ul>
</li>
<li>内存的装入<ul>
<li>绝对装入<ul>
<li>概念<ul>
<li>在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存</li>
<li>编译和链接时就改变地址</li>
</ul>
</li>
<li>只适用于单道程序环境</li>
</ul>
</li>
<li>可重定位装入<ul>
<li>概念<ul>
<li>又称静态重定位</li>
<li>编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址</li>
<li>可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“重定位”，将逻辑地址变换为物理地址</li>
<li>地址变换是在装入时一次完成的</li>
</ul>
</li>
<li>必须分配其要求的全部内存空间</li>
<li>在运行期间就不能再移动</li>
</ul>
</li>
<li>动态运行时装入<ul>
<li>概念<ul>
<li>也称动态重定位</li>
<li>装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行</li>
<li>装入内存后所有的地址依然是逻辑地址</li>
<li>需要一个重定位寄存器的支持。</li>
</ul>
</li>
<li>可以将程序分配道不连续的存储区</li>
<li>在程序运行之前可以指装入部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存</li>
<li>便于程序段的共享</li>
</ul>
</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309031608870.png" alt="image-20230903160809914"></li>
</ul>
</li>
</ul>
<p><strong>逻辑地址空间与物理地址空间</strong></p>
<ul>
<li>相对地址（逻辑地址）<ul>
<li>编译后，每个目标模块都从0号单元开始编制，这称为目标模块的相对地址</li>
<li>链接程序顺序一次按各个模块的相对地址构成统一的从0号单元开始编址的逻辑地址空间（虚拟地址空间），对于32位系统，逻辑地址空间的范围为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="11.466ex" height="2.072ex" role="img" focusable="false" viewBox="0 -833.9 5068.1 915.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mo" transform="translate(777.8,0)"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g><g data-mml-node="msup" transform="translate(2055.6,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path></g></g></g><g data-mml-node="mo" transform="translate(3567.9,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(4568.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container></li>
</ul>
</li>
<li>物理地址空间<ul>
<li>内存中物理单元的集合，地址转换的最终地址</li>
</ul>
</li>
<li>地址重定位<ul>
<li>逻辑地址转换为物理地址的过程</li>
<li>通过内存管理部件（MMU）来实现</li>
</ul>
</li>
</ul>
<p><strong>进程的内存映像</strong></p>
<ul>
<li>组成<ul>
<li>代码段<ul>
<li>即程序的二进制代码，代码段是只读的，可以被多个进程共享</li>
</ul>
</li>
<li>数据段<ul>
<li>即程序运行时加工处理的对象，包括全局变量和静态变量</li>
</ul>
</li>
<li>进程控制块（PCB）<ul>
<li>存放在系统区。操作系统通过PCB来控制和管理进程</li>
</ul>
</li>
<li>栈<ul>
<li>用来存放动态分配的变量。通过调用mall oc函数动态地向高地址分配空间</li>
</ul>
</li>
<li>堆<ul>
<li>用来实现函数调用。从用户空间的最大地址往低地址方向增长</li>
</ul>
</li>
</ul>
</li>
<li>代码段和数据段在程序调入内存时就指定了大小，而堆和栈不一样</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309031607409.png" alt="image-20230903160738499"></li>
</ul>
<p><strong>内存保护</strong></p>
<ul>
<li>设置一对上、下限寄存器<ul>
<li>存放用户作业在主存中的下限和上限</li>
</ul>
</li>
<li>采用重定位寄存器（基地址寄存器）和界地址寄存器（限长寄存器）<ul>
<li>重定位地址含最小的物理地址值</li>
<li>界地址寄存器含逻辑地址的最大值</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309031607273.png" alt="image-20230903160713214"></li>
</ul>
</li>
</ul>
<p><strong>内存共享</strong></p>
<p><strong>内存分配与回收</strong></p>
<ul>
<li>单一连续分配——固定分区分配——动态分区分配</li>
<li>连续分配方式——离散分配方式（页式存储管理）</li>
<li>引入分段存储管理的目的<ul>
<li>满足用户在编程和使用方面的要求</li>
</ul>
</li>
</ul>
<h3 id="3-1-2-覆盖与交换（不要求）"><a href="#3-1-2-覆盖与交换（不要求）" class="headerlink" title="*3.1.2 覆盖与交换（不要求）"></a>*3.1.2 覆盖与交换（不要求）</h3><h3 id="3-1-3连续分配管理方式"><a href="#3-1-3连续分配管理方式" class="headerlink" title="3.1.3连续分配管理方式"></a>3.1.3连续分配管理方式</h3><ul>
<li>连续分配方式是指为一个用户程序分配一个连续的内存空间</li>
<li><p>内部碎片</p>
<ul>
<li>分配给某进程的内存区域中，有些部分没有用上</li>
</ul>
</li>
<li><p>外部碎片</p>
<ul>
<li>内存中的某些空闲分区由于太小而难以利用</li>
</ul>
</li>
</ul>
<p><strong>单一连续分配</strong></p>
<ul>
<li><p>内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据。内存中只能有一道用户程序，用户程序独占整个用户区空间</p>
</li>
<li><p>优点：</p>
<ul>
<li>简单、无外部碎片，无须进行内存保护</li>
</ul>
</li>
<li>缺点<ul>
<li>只能用于单用户、单任务的操作系统中，有内部碎片，存储器的利用率极低</li>
</ul>
</li>
</ul>
<p><strong>固定分区分配</strong></p>
<ul>
<li><p>将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式</p>
</li>
<li><p>分区方法</p>
<ul>
<li><p>分区大小相等</p>
<ul>
<li>程序太小会造成浪费，太大又无法装入，缺乏灵活性</li>
</ul>
</li>
<li><p>分区大小不等</p>
<ul>
<li>划分为多个较小的分区、适量的中等分区和少量的大分区</li>
</ul>
</li>
</ul>
</li>
<li><p>空闲分区链</p>
</li>
<li><p>分区使用表（空闲分区表）</p>
<ul>
<li>记录每个分区的起始地址、大小以及状态（是否已分配）</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309031937364.png" alt="image-20230903193754349"></li>
</ul>
</li>
<li><p>存在两个问题</p>
<ul>
<li>程序过大放不进任何一个分区中</li>
<li>主存利用率低，存在内部碎片</li>
</ul>
</li>
</ul>
<p><strong>动态分区分配（可变分区分配）</strong></p>
<ul>
<li><p>在进程装入内存时，根据进程的实际需要，动态地为之分配内存，并使分区的大小正好适合进程的需要</p>
</li>
<li><p>紧凑技术</p>
<ul>
<li>解决外部碎片问题</li>
<li>操作系统不时对进程进行移动和整理</li>
<li>需要动态重定位寄存器的支持，相对费时</li>
</ul>
</li>
<li>动态分区的分配策略<ul>
<li>首次适应算法 First Fit<ul>
<li>空闲分区以地址递增的次序链接，分配内存时，从链首开始顺序查找，找到大小能满足要求的第一个空闲分区分配作业</li>
<li>优点<ul>
<li>最简单、最快、最好</li>
</ul>
</li>
<li>缺点<ul>
<li>内存的低地址部分出现很多小的空闲分区，每次查找都要绕开这些分区，增加了开销</li>
</ul>
</li>
</ul>
</li>
<li>邻近适应算法 Next Fit<ul>
<li>又称循环首次适应算法</li>
<li>分配内存时从上次查找结束的位置开始继续查找</li>
<li>缺点<ul>
<li>可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，性能比首次适应算法差</li>
</ul>
</li>
</ul>
</li>
<li>最佳适应算法 Best Fit<ul>
<li>空闲分区以容量递增的次序形成空闲分区链，找到第一个能满足要求且最小的分区分配给作业</li>
<li>缺点<ul>
<li>每次分配会留下很小的难以利用的内存块，产生很多的外部碎片，性能很差</li>
</ul>
</li>
</ul>
</li>
<li>最坏适应算法 Worst Fit<ul>
<li>空闲分区以容量递减的次序链接，找到第一个能满足要求的，即最大的分区，从中分割一部分存储空间给作业</li>
<li>缺点：<ul>
<li>快速消耗大分区，导致后面无大分区可用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="非连续分配管理方式"><a href="#非连续分配管理方式" class="headerlink" title="非连续分配管理方式"></a>非连续分配管理方式</h3><ul>
<li>分页存储管理<ul>
<li>基本分页存储管理</li>
<li>请求分页存储管理</li>
</ul>
</li>
<li>分段存储管理</li>
</ul>
<h3 id="3-1-4-基本分页存储管理方式"><a href="#3-1-4-基本分页存储管理方式" class="headerlink" title="3.1.4 基本分页存储管理方式"></a>3.1.4 基本分页存储管理方式</h3><ul>
<li><p>从计算机角度考虑，提高内存的利用率和计算机的性能，通过硬件机制实现，对用户完全透明</p>
</li>
<li><p>把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位，每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存的块空间</p>
</li>
<li>不会产生外部碎片</li>
<li>每个进程平均只产生半个块大小的内部碎片（页内碎片）</li>
<li>不方便按照逻辑模块实现信息的共享和保护</li>
</ul>
<p><strong>分页存储的几个基本概念</strong></p>
<ul>
<li>页面和页面大小<ul>
<li>进程中的块称为页/页面（Page）<ul>
<li>大小应是2的整数幂<ul>
<li>逻辑地址的拆分更加迅速</li>
<li>物理地址的计算更加迅速</li>
</ul>
</li>
<li>过小<ul>
<li>使进程的页面数过多，这样页表就会过长，占用大量内存，而且增加硬件地址转换的开销。，降低页面换入/换出的效率</li>
</ul>
</li>
<li>过大<ul>
<li>使页内碎片增多，降低主存的利用率</li>
</ul>
</li>
</ul>
</li>
<li>内存中的块称为页框（Page Frame，或页帧）</li>
<li>外存直接称为块/盘块（Block）</li>
</ul>
</li>
<li>地址结构<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309041913870.png" alt="image-20230904191338566"><ul>
<li>上图地址长度为32位，其中0-11位为页内地址，即每页大小为4KB；12-31位为页号，即最多允许<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.919ex" height="1.887ex" role="img" focusable="false" viewBox="0 -833.9 1290.1 833.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path></g></g></g></g></g></svg></mjx-container>页</li>
</ul>
</li>
</ul>
</li>
<li>页表<ul>
<li>实现从页号到物理块号的地址映射</li>
<li>由页表项组成</li>
<li>第一部分为页号（隐藏），第二部分是物理内存中的块号</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309041917922.png" alt="image-20230904191756167"></li>
</ul>
</li>
</ul>
<p><strong>基本地址变换机构</strong></p>
<ul>
<li>页表寄存器（PTR）<ul>
<li>存放页表在内存的起始地址F和页表长度M</li>
</ul>
</li>
<li>过程<ul>
<li>设页面大小为L，逻辑地址为A，物理地址为E</li>
<li>页号P = L/A；页内偏移量W = A%L</li>
<li>比较页号P与页面长度M，若P≥M则产生越界中断</li>
<li>页表中页号P对应的页表项地址 = 页表始址F + 页号P × 页表项长度，取出该页表项内容b，即物理块号</li>
<li>计算 物理地址E = b × L + W</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309041924860.png" alt="image-20230904192440613"></li>
</ul>
</li>
<li>页表项的大小<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309041922520.png" alt="image-20230904192202285"></li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309041930281.png" alt="image-20230904193029310"></li>
</ul>
</li>
<li>分页管理方式存在的主要问题<ul>
<li>地址转换必须足够快，否咋访存速度会降低<ul>
<li>每次访存操作都需要进行逻辑地址到物理地址的转换</li>
</ul>
</li>
<li>页表不能过大，否则内存利用率会降低<ul>
<li>每个进程都要引入页表，用于存储映射机制</li>
</ul>
</li>
</ul>
</li>
<li>两次访存</li>
</ul>
<p><strong>具有快表的地址变换机构</strong></p>
<ul>
<li>高速缓冲存储器——快表（相联存储器TLB），主存中的页表常称为慢表</li>
<li>地址变换过程<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309041936325.png" alt="image-20230904193657148"></li>
<li>CPU给出逻辑地址后，由硬件进行地址转换，将页号送入高速缓存寄存器，并将此页号与快表中的所有页号进行比较</li>
<li>若找到匹配的页号，说明所要访问的页表项在快表中，则直接从中取出该页对应的页框号，与页内偏移量拼接形成物理地址。这样，存取数据仅一次访存便可实现</li>
<li>若未找到匹配的页号，则需要访问主存中的页表，读出页表项后，应同时将其存入快表，以便后面可能的再次访问。若快表已满，则须按特定的算法淘汰一个旧页表项</li>
</ul>
</li>
<li>给定快表命中率a和快表访问时间b，慢表访问时间c，求平均耗时T<ul>
<li>先块表后慢表<ul>
<li>$T=(b+c)<em>a+(b+c+c)</em>(1-a)$</li>
</ul>
</li>
<li>块表慢表同时查询<ul>
<li>$T=(b+c)<em>a+(c+c)</em>(1-a)$</li>
</ul>
</li>
</ul>
</li>
<li>基于局部性原理</li>
<li>快表命中——一次访存；未命中——两次</li>
</ul>
<p><strong>两级页表</strong></p>
<ul>
<li><p>单级页表的问题</p>
<ul>
<li>页表必须连续存放，当页表很大时，需要占用很多个连续的页框</li>
<li>没有必要让整个页表常驻内存，因为进程在一段时间内只需要访问某几个特点的页面</li>
</ul>
</li>
<li><p>==顶级页表最多只能有一个页面==</p>
</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309041951525.png" alt="image-20230904195152347"></li>
<li>访存次数（假设没有快表）<ul>
<li>二级——三次</li>
<li>三级——四次</li>
<li>……</li>
</ul>
</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309041952608.png" alt="image-20230904195239664"></li>
</ul>
<h3 id="3-1-5基本分段存储管理方式"><a href="#3-1-5基本分段存储管理方式" class="headerlink" title="3.1.5基本分段存储管理方式"></a>3.1.5基本分段存储管理方式</h3><ul>
<li>从用户和程序员的角度考虑，以满足方便编程、信息保护和共享、动态增长及动态链接等多方面的需要</li>
<li>分配大的连续空间不方便，会产生外部碎片</li>
</ul>
<p><strong>分段</strong></p>
<ul>
<li>按照用户进程中的自然段划分逻辑空间</li>
<li>段内要求连续，段间无要求</li>
<li>二维（标识一个地址，既要给出段名，也要给出段内地址）<ul>
<li>段长不固定</li>
<li>分页——一维</li>
<li>二级分页——一维<ul>
<li>页长固定，给定一个整数能自己推算出偏移等</li>
</ul>
</li>
</ul>
</li>
<li>每段都从0开始编址</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309041958378.png" alt="image-20230904195812180"></li>
</ul>
<p><strong>段表</strong></p>
<ul>
<li>组成<ul>
<li>段号（隐藏）</li>
<li>段长（不固定）</li>
<li>本段在主存中的起始地址</li>
</ul>
</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309042000900.png" alt="image-20230904200058714"></li>
</ul>
<p><strong>地址变换机构</strong></p>
<ul>
<li>段表寄存器<ul>
<li>存放段表起始地址F和段表长度M</li>
</ul>
</li>
<li>过程<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309042001366.png" alt="image-20230904200155470"></li>
<li>取出逻辑地址A的前几位为段号S，后几位为段内偏移量W</li>
<li>比较段号S和段表长度M，若<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.312ex;" xmlns="http://www.w3.org/2000/svg" width="6.854ex" height="1.907ex" role="img" focusable="false" viewBox="0 -705 3029.6 843"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path></g><g data-mml-node="mo" transform="translate(922.8,0)"><path data-c="2265" d="M83 616Q83 624 89 630T99 636Q107 636 253 568T543 431T687 361Q694 356 694 346T687 331Q685 329 395 192L107 56H101Q83 58 83 76Q83 77 83 79Q82 86 98 95Q117 105 248 167Q326 204 378 228L626 346L360 472Q291 505 200 548Q112 589 98 597T83 616ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(1978.6,0)"><path data-c="1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"></path></g></g></g></svg></mjx-container>，则产生越界中断</li>
<li>段号S对应的段表项地址 = 段表始址F + 段号S * 段表项长度，取出该段表项的前几位得到段长C，若段内偏移量<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.312ex;" xmlns="http://www.w3.org/2000/svg" width="4.108ex" height="1.907ex" role="img" focusable="false" viewBox="0 -705 1815.8 843"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2265" d="M83 616Q83 624 89 630T99 636Q107 636 253 568T543 431T687 361Q694 356 694 346T687 331Q685 329 395 192L107 56H101Q83 58 83 76Q83 77 83 79Q82 86 98 95Q117 105 248 167Q326 204 378 228L626 346L360 472Q291 505 200 548Q112 589 98 597T83 616ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(1055.8,0)"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g></g></g></svg></mjx-container>，则产生越界中断</li>
<li>取出段表项中该段的始址b，计算物理地址<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="10.853ex" height="1.756ex" role="img" focusable="false" viewBox="0 -694 4797 776"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"></path></g><g data-mml-node="mo" transform="translate(1041.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(2097.6,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(2748.8,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(3749,0)"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"></path></g></g></g></svg></mjx-container></li>
</ul>
</li>
</ul>
<p><strong>段的共享和保护</strong></p>
<ul>
<li>段的共享<ul>
<li>两个作业的段表中相应表项指向被共享的段的同一个物理副本</li>
</ul>
</li>
<li>纯代码/可重入代码<ul>
<li>不属于临界资源</li>
<li>不能被修改</li>
<li>可修改的代码和数据不能共享</li>
</ul>
</li>
<li>存取控制保护</li>
<li>地址越界保护<ul>
<li>比较段表寄存器中的段长与逻辑地址中的段号</li>
<li>比较段表项中的段长和逻辑地址中的段内偏移</li>
<li>分页管理只需判断页号是否越界</li>
</ul>
</li>
</ul>
<h3 id="3-1-6段页式管理方式"><a href="#3-1-6段页式管理方式" class="headerlink" title="3.1.6段页式管理方式"></a>3.1.6段页式管理方式</h3><ul>
<li><p>作业的逻辑地址</p>
<ul>
<li><p>段表项（定长）</p>
<ul>
<li><p>段号（隐藏）</p>
<ul>
<li>决定每个进程最多可以分为多少个段</li>
</ul>
</li>
<li><p>页号</p>
<ul>
<li>决定每个段最大有多少页</li>
</ul>
</li>
<li><p>页内偏移量</p>
<ul>
<li>决定页面大小</li>
</ul>
</li>
</ul>
</li>
<li><p><img src="https://gitee.com/renmale-sztu/image/raw/master/202309042023970.png" alt="image-20230904202356146"></p>
</li>
</ul>
</li>
<li><p>段表寄存器</p>
<ul>
<li>指出作业的段表始址和段表长度</li>
<li>段表寄存器和页表寄存器的作用都有两个<ul>
<li>在段表或页表中寻址</li>
<li>判断是否越界</li>
</ul>
</li>
</ul>
</li>
<li>在一个进程中，段表只有一个，而页表可能有多个</li>
<li>段页式管理的地址空间是二维的</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309042027016.png" alt="image-20230904202719134"><ul>
<li>三次访存</li>
<li>首先通过段表查询到页表始址</li>
<li>然后通过页表找到页帧号</li>
<li>最后形成物理地址</li>
</ul>
</li>
</ul>
<h2 id="3-2-虚拟内存管理"><a href="#3-2-虚拟内存管理" class="headerlink" title="3.2 虚拟内存管理"></a>3.2 虚拟内存管理</h2><h3 id="3-2-1虚拟内存的基本概念"><a href="#3-2-1虚拟内存的基本概念" class="headerlink" title="3.2.1虚拟内存的基本概念"></a>3.2.1虚拟内存的基本概念</h3><p><strong>传统存储管理方式的特征</strong></p>
<ul>
<li>一次性<ul>
<li>作业必须一次性全部装入内存，才能开始运行<ul>
<li>当作业量很大而不能全部装入内存时，将使该作业无法运行</li>
<li>当大量作业要求运行时，由于内存不足以容纳所有作业，只能使少数作业先运行，导致多道程序度的下降</li>
</ul>
</li>
</ul>
</li>
<li>驻留性<ul>
<li>作业被装入内存后，就一直驻留在内存中，其任何部分斗不会被换出，直至作业运行结束<ul>
<li>运行中的进程会因等待I/O而被阻塞，可能处于长期等待状态</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>局部性原理</strong></p>
<ul>
<li>时间局部性<ul>
<li>如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问（因为程序中存在大量的循环）</li>
</ul>
</li>
<li>空间局部性<ul>
<li>一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问（因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的）</li>
</ul>
</li>
<li>高速缓存技术<ul>
<li>依赖局部性原理<ul>
<li>快表</li>
<li>页高速缓存</li>
<li>虚拟内存</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>虚拟存储器的定义和特征</strong></p>
<ul>
<li>定义<ul>
<li>基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行。在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存</li>
</ul>
</li>
<li>特征<ul>
<li>多次性<ul>
<li>无须在作业运行时一次性地全部装入内存，而允许被分成多次调入内存运行，即只需将当前要运行地那部分程序和数据装入内存即可开始运行</li>
<li>多次性是虚拟存储器最重要的特征</li>
</ul>
</li>
<li>对换性<ul>
<li>无须在作业运行时一直常驻内存，在进程运行期间，允许将那些暂不使用的程序和数据从内存调至外存的对换区（换出），待以后需要时再将它们从外存调至内存（换入）</li>
</ul>
</li>
<li>虚拟性<ul>
<li>从逻辑上扩充内存的容量，使用户所看到的内存容量远大于实际的内存容量</li>
<li>虚拟存储器所表现出的最重要特征</li>
<li>实现虚拟存储器的最重要目标</li>
</ul>
</li>
</ul>
</li>
<li>容量<ul>
<li>最大容量<ul>
<li>有计算机的地址结构（CPU寻址范围）确定</li>
</ul>
</li>
<li>实际容量<ul>
<li>min(内存和外存容量之和，CPU寻址范围)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>虚拟内存技术的实现</strong></p>
<ul>
<li><p>建立在离散分配的内存管理方式的基础上</p>
</li>
<li><p>三种方式</p>
<ul>
<li>请求分页存储管理</li>
<li>请求分段存储管理</li>
<li>请求段页式存储管理</li>
</ul>
</li>
<li><p>虚拟内存的容量要满足两个条件</p>
<ul>
<li>虚存的实际容量 ≤ 内存容量和外存容量之和</li>
<li>虚存的最大容量 ≤ 计算机的地址位数能容纳的最大容量</li>
</ul>
</li>
</ul>
<h3 id="3-2-2-请求分页管理方式"><a href="#3-2-2-请求分页管理方式" class="headerlink" title="3.2.2 请求分页管理方式"></a>3.2.2 请求分页管理方式</h3><p><strong>页表机制</strong></p>
<ul>
<li>新增字段<ul>
<li>状态位P<ul>
<li>用户指示该页是否已调入内存</li>
<li>供程序访问时参考</li>
</ul>
</li>
<li>访问字段A<ul>
<li>用于记录本页在一段时间内被访问的次数或本页最近已有多长时间未被访问</li>
<li>供置换算法换出页面时参考</li>
</ul>
</li>
<li>修改位M<ul>
<li>标识该页在调入内存后是否被修改过，以确定页面置换时是否写回内存</li>
</ul>
</li>
<li>外存地址<ul>
<li>用于指出该页在外存上的地址，通常是物理块号，供调入该页时参考</li>
</ul>
</li>
</ul>
</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309051537126.png" alt="image-20230905153735003"></li>
</ul>
<p><strong>缺页中断机构</strong></p>
<ul>
<li>在指令执行期间而非一条指令执行完后产生和处理中断信号，属于内部中断（内中断）</li>
<li>一条指令在执行期间，可能产生多次缺页中断</li>
</ul>
<p><strong>地址变换机构</strong></p>
<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309051541445.png" alt="image-20230905154122573"><ul>
<li>先检查快表</li>
<li>若找到要访问的页，则修改页表项中的访问位（写指令还需要重置修改位），然后利用页表项中给出的物理块号和页内地址形成物理地址</li>
<li>若未找到该页的页表项，则应到内存中去查找页表，再对比页表项中的状态位P，看该页是否已调入内存，若页面已调入，则将该页的页表写入快表，若快表已满，则需采用某种算法替换。若页面未调入，则产生缺页中断，请求从外存把该页调入内存</li>
</ul>
</li>
<li>只有“写指令”才需要修改“修改位”。并且，一般来说只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表。这样可以减少访存次数。</li>
<li>和普通的中断处理一样，缺页中断处理依然需要保留CPU现场</li>
<li>需要用某种“页面置换算法”来决定一个换出页面</li>
<li>换入/换出页面都需要启动慢速的I/O操作，可见，如果换入/换出太频繁，会有很大的开销。</li>
<li>页面调入内存后，需要修改慢表，同时也需要将表项复制到快表中。</li>
</ul>
<h3 id="3-2-3页框分配"><a href="#3-2-3页框分配" class="headerlink" title="3.2.3页框分配"></a>3.2.3页框分配</h3><p><strong>驻留集大小</strong></p>
<ul>
<li>给一个进程分配的物理页框的集合就是这个进程的驻留集</li>
<li>分配给一个进程的页框越少，驻留在主存中的进程就越多，从而可提高CPU的利用率</li>
<li>若一个进程在主存中的页面过少，则尽管有局部性原理，缺页率仍相对较高</li>
<li>若分配的页框过多，则由于局部性原理，对该进程的缺页率没有太明显的影响</li>
</ul>
<p><strong>内存分配策略</strong></p>
<ul>
<li><p>概念</p>
<ul>
<li>固定分配<ul>
<li>操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，驻留集大小不变</li>
</ul>
</li>
<li>可变分配<ul>
<li>先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即，驻留集大小可变</li>
</ul>
</li>
<li>局部置换<ul>
<li>发生缺页时只能选进程自己的物理块进行置换</li>
</ul>
</li>
<li>全局置换<ul>
<li>可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程</li>
</ul>
</li>
</ul>
</li>
<li><p>策略</p>
<ul>
<li><p>固定分配局部置换</p>
<ul>
<li>系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面</li>
<li>这种策略的缺点是：很难在刚开始就确定应为每个进程分配多少个物理块才算合理。<ul>
<li>太少会频繁出现缺页中断，太多又会降低CPU和其他资源的利用率</li>
</ul>
</li>
</ul>
</li>
<li><p>可变分配全局置换</p>
<ul>
<li>刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程；若已无空闲物理块，则可选择一个未锁定（锁定的页面不能换出外存）的页面换出外存，再将该物理块分配给缺页的进程。采用这种策略时，只要某进程发生缺页，都将获得新的物理块，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出。被选择调出的页可能是系统中任何一个进程中的页，因此这个被选中的进程拥有的物理块会减少，缺页率会增加。</li>
<li>盲目地给进程增加物理块，从而导致系统多道程序的并发能力下降</li>
</ul>
</li>
<li><p>可变分配局部置换</p>
<ul>
<li>刚开始会为每个进程分配一定数量的物理块。当某进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存。如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当程度；反之，如果进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。</li>
<li>这种方法在保证进程不会过多地调页的同时，也保持了系统的多道程序并发能力。当然它需要更复杂的实现，也需要更大的开销，但对比频繁地换入/换出所浪费的计算机资源，这种牺牲是值得的</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>物理块调入算法</strong></p>
<ul>
<li>固定分配分配算法<ul>
<li>平均分配算法<ul>
<li>将系统中所有可供分配的物理块平均分配给各个进程</li>
</ul>
</li>
<li>按比例分配算法<ul>
<li>根据进程的大小按比例分配物理块</li>
</ul>
</li>
<li>优先权分配算法<ul>
<li>为重要和紧迫的进程分配较多的物理块</li>
<li>通常采取把所有可分配的物理块分成两部分，一部分按比例，一部分按优先权</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>调入页面的时机</strong></p>
<ul>
<li>预调页策略（运行前调入）<ul>
<li>主要用户进程的首次调入</li>
</ul>
</li>
<li>请求调页策略<ul>
<li>在运行期间发现缺页时才将所缺页面调入内存</li>
</ul>
</li>
</ul>
<p><strong>从何处调入页面</strong></p>
<ul>
<li>外存分为两部分<ul>
<li>用于存放文件的文件区：通常采用离散分配方式</li>
<li>用于存放对换页面的对换区：通常采用连续分配方式</li>
</ul>
</li>
<li>三种情况<ul>
<li>系统拥有足够的对换区空间<ul>
<li>可以全部从对换区调入所需页面，以提高调页速度。为此在进程运行前，需将与该进程有关的文件从文件区复制到对换区</li>
</ul>
</li>
<li>系统缺少足够的对换区空间<ul>
<li>凡是不会被修改的文件都直接从文件区调入；而当换出这些页面时，由于它们未被修改而不必再将它们换出。但对于那些可能被修改的部分，在将它们换出时须调到对换区，以后需要时再从对换区调入（因为读比写的速度快）</li>
</ul>
</li>
<li>UNIX方式<ul>
<li>与进程有关的文件都放在文件区，因此未运行过的页面都应从文件区调入曾经运行过但又被换出的页面，由于是放在对换区，因此在下次调入时应从对换区调入进程请求的共享页面若被其他进程调入内存，则无须再从对换区调入</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>如何调入页面</strong></p>
<ol>
<li>缺页</li>
<li>缺页中断</li>
<li>缺页中断处理程序</li>
<li>…….</li>
</ol>
<h3 id="3-2-4页面置换算法"><a href="#3-2-4页面置换算法" class="headerlink" title="3.2.4页面置换算法"></a>3.2.4页面置换算法</h3><p><strong>最佳（OPT）置换算法</strong></p>
<ul>
<li>每次选择的页面是以后永不使用的页面，或者最长时间内不再被访问的页面，以确保最低的缺页率</li>
<li>该算法无法实现</li>
</ul>
<p><strong>先进先出（FIFO）算法</strong></p>
<ul>
<li><p>优先淘汰最早进入内存的页面，即淘汰在内存中驻留最久的页面</p>
</li>
<li><p>Belady异常</p>
<ul>
<li>当为进程分配的物理块数增大时，缺页次数不减反增的异常现象</li>
<li>只有FIFO算法会产生Belady异常</li>
</ul>
</li>
<li>实现简单，算法性能差</li>
</ul>
<p><strong>最近最久未使用（LRU）算法</strong></p>
<ul>
<li>每次选择最近最长时间未访问过的页面淘汰，该算法未每个页面设置一个访问字段，用来记录页面上一次被访问以来所经历的时间，淘汰页面时选择现有页面中值最大的淘汰</li>
<li>性能好，当需要寄存器和栈的硬件支持，开销大（需要对所有的页进行排序）</li>
</ul>
<p><strong>时钟（CLOCK）置换算法</strong></p>
<ul>
<li><p>简单的CLOCK置换算法</p>
<ul>
<li>为每帧设置一位访问位，当某页首次被装入或被访问时，其访问位被置为1</li>
<li>将内存中的所有页面视为一个循环队列，并有一个替换指针与之相关联，当某一页被替换时，该指针被设置指向被替换页面的下一页。在选择一页淘汰时，只需检查页的访问位。若为0，就选择该页换出：若为1，则将它置为0，暂不换出，给予该页第二次驻留内存的机会，再依次顺序检查下一个页面。当检查到队列中的最后一个页面时，若其访问位仍为1，则返回到队首去循环检查</li>
<li>该算法是循环地检查各个页面的使用情况，故称CLOCK算法但是，因为该算法只有一位访问位，而置换时将未使用过的页面换出，故又称最近未用(N RU）算法</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309051710784.png" alt="image-20230905171026827"></li>
</ul>
</li>
<li><p>改进型CLOCK置换算法</p>
<ul>
<li>将一个页面换出时，若该页已被修改过，则要将该页写回磁盘，若该页未被修改过，则不必将它写回磁盘。可见，对于修改过的页面，替换代价更大。在改进型CLOCK算法中，除考虑页面使用情况外，还增加了置换代价——修改位</li>
<li></li>
<li>访问位A和修改位M<ul>
<li>A=0,M=0；最近未被访问且未被修改，是最佳淘汰页</li>
<li>A=0，M=1；最近未被访问，但已被修改，不是很好的淘汰页</li>
<li>A=1.M=0:最近已被访问，但未被修改，可能再被访问</li>
<li>A=1,M=1:最近已被访问且已被修改，可能再被访问</li>
</ul>
</li>
<li>过程<ol>
<li>从指针的当前位置开始，扫描循环队列，寻找A=0且M=0的1类页面，将遇到的第一个1类页面作为选中的淘汰页。在第一次扫描期间不改变访问位A</li>
<li>若第1）步失败，则进行第二轮扫描，寻找A=0且M=1的2类页面。将遇到的第一个2类页面作为淘汰页。在第二轮扫描期间，将所有扫描过的页面的访问位都置0</li>
<li>若第2）步也失败，则将指针返回到开始的位置，并将所有帧的访问位复0。重复第1）步，并且若有必要，重复第2）步，此时一定能找到被淘汰的页</li>
</ol>
</li>
<li>最多进行4轮循环</li>
<li>改进型CLOCK算法优于简单CLOCK算法的地方在于，可减少磁盘的I/O操作次数。但为了找到一个可置换的页，可能要经过几轮扫描，即实现算法本身的开销将有所增加</li>
</ul>
</li>
</ul>
<h3 id="3-2-5抖动和工作集"><a href="#3-2-5抖动和工作集" class="headerlink" title="3.2.5抖动和工作集"></a>3.2.5抖动和工作集</h3><p><strong>抖动（颠簸）</strong></p>
<ul>
<li>发生的原因：某个进程频繁访问的页面数目高于可用的物理页帧数目</li>
</ul>
<p><strong>工作集</strong></p>
<ul>
<li>某段时间间隔内，进程要访问的页面集合</li>
<li>驻留集大小不能小于工作集大小</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309051930871.png" alt="image-20230905193013779"></li>
</ul>
<h3 id="3-2-6内存映射文件"><a href="#3-2-6内存映射文件" class="headerlink" title="3.2.6内存映射文件"></a>3.2.6内存映射文件</h3><ul>
<li>将磁盘文件的全部或部分内容与进程虚拟地址空间的某个区域建立映射关系，便可以直接访问被映射的文件，而不必执行文件I/O操作，也无须对文件内容进行缓存处理</li>
<li>使用内存映射文件所进行的任何实际交互都是在内存中进行的，并且是以标准的内存地址形式来访问的</li>
<li>系统内存中的所有页面都由虚拟存储器负责管理，虚拟存储器以统一的方式处理所有磁盘I/O.当进程退出或显式地解除文件映射时，所有被改动的页面会被写回磁盘文件。</li>
<li>多个进程允许并发地内存映射同一文件，以便允许数据共享，共享内存是通过内存映射来实现的</li>
</ul>
<h3 id="3-2-7虚拟存储器性能影响因素"><a href="#3-2-7虚拟存储器性能影响因素" class="headerlink" title="3.2.7虚拟存储器性能影响因素"></a>3.2.7虚拟存储器性能影响因素</h3><ul>
<li>缺页率（缺页率高即为抖动）是影响虚拟存储器性能的主要因素<ul>
<li>页面大小<ul>
<li>根据局部性原理，页面较大则缺页率较低，页面较小则缺页率较高。页面较小时，一方面减少了内存碎片，有利于提高内存利用率；另一方面，也会使每个进程要求较多的页面，导致页表过长，占用大量内存。页面较大时，虽然可以减少页表长度，但会使页内碎片增大</li>
</ul>
</li>
<li>工作集<ul>
<li>分配给进程的物理块数越多，缺页率就越低，但是当物理块超过某个数目时，再为进程增加一个物理块对缺页率的改善是不明显的</li>
</ul>
</li>
<li>页面置换算法<ul>
<li>好的页面置换算法可使进程在运行过程中具有较低的缺页率</li>
</ul>
</li>
<li>程序的编制方法<ul>
<li>编写程序的局部化程度越高，执行时的缺页率就越低。如果存储采用的是按行存储，访问时就要尽量采用相同的访问方式，避免按列访问造成缺页率过高的现象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-2-8-地址翻译"><a href="#3-2-8-地址翻译" class="headerlink" title="3.2.8 地址翻译"></a>3.2.8 地址翻译</h3><ul>
<li>计算机组成原理结合</li>
</ul>
]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统—第五章—输入输出（IO）管理</title>
    <url>/2023/09/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E7%AC%AC%E4%BA%94%E7%AB%A0%E2%80%94%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%EF%BC%88IO%EF%BC%89%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1 id="5-1I-O管理概述"><a href="#5-1I-O管理概述" class="headerlink" title="5.1I/O管理概述"></a>5.1I/O管理概述</h1><h3 id="5-1-1-I-O设备"><a href="#5-1-1-I-O设备" class="headerlink" title="5.1.1 I/O设备"></a>5.1.1 I/O设备</h3><p><strong>设备的分类</strong></p>
<ul>
<li><p>按信息交换的单位</p>
<ul>
<li><p>块设备——有结构设备</p>
</li>
<li><p>字符设备——无结构设备</p>
</li>
</ul>
</li>
<li><p>按传输速率</p>
<ul>
<li>低速设备——几字节~数百字节</li>
<li>中速设备——数千字节~数万字节</li>
<li>高速设备——数百千字节~千兆字节</li>
</ul>
</li>
<li>按使用特性<ul>
<li>人机交互类外部设备</li>
<li>存储设备</li>
<li>网络通信设备</li>
</ul>
</li>
</ul>
<span id="more"></span>
<p><strong>I/O结构</strong></p>
<ul>
<li>I/O接口（设备控制器）位于CPU与设备之间</li>
<li>组成<ul>
<li><img src="C:\Users\lvxr\AppData\Roaming\Typora\typora-user-images\image-20230912151053142.png" alt="image-20230912151053142"></li>
<li>设备控制器与CPU的接口<ul>
<li>用于实现CPU与控制器之间的通信</li>
<li>CPU通过控制线发出命令；通过地址线指明要操作的设备；通过数据线来取出（输入）数据，或放入（输出）数据</li>
</ul>
</li>
<li>设备控制器与设备的接口<ul>
<li>用于实现控制器与设备之间的通信</li>
</ul>
</li>
<li>I/O逻辑<ul>
<li>负责接收和识别CPU的各种命令（如地址译码），并负责对设备发出命令</li>
</ul>
</li>
</ul>
</li>
<li>一个I/O控制器可能会对应多个设备</li>
<li>数据寄存器、控制寄存器、状态寄存器可能有多个</li>
<li>主要功能<ul>
<li>接收和识别CPU发来的命令</li>
<li>数据交换</li>
<li>标识和报告设备的状态，供CPU处理</li>
<li>地址识别</li>
<li>数据缓冲</li>
<li>差错控制</li>
</ul>
</li>
</ul>
<p><strong>I/O端口</strong></p>
<ul>
<li>I/O端口是值设备控制器中可被CPU直接访问的寄存器<ul>
<li>数据寄存器<ul>
<li>实现CPU和外设之间的数据缓冲</li>
</ul>
</li>
<li>状态寄存器<ul>
<li>获取执行结果和设备的状态信息，以让CPU知道是否准备好</li>
</ul>
</li>
<li>控制寄存器<ul>
<li>由CPU写入，以便启动命令或更改设备模式</li>
</ul>
</li>
</ul>
</li>
<li>CPU与I/O端口通信的两种方式<ul>
<li>独立编址<ul>
<li>为每个端口分配一个I/O端口空号，所有I/O端口形成I/O端口空间，普通用户程序不能对其进行访问，只有操作系统使用特殊的IIO指令才能访问端口</li>
</ul>
</li>
<li>同一编址（内存映像I/O）<ul>
<li>每个端口被分配唯一的内存地址，且不会有内存被分配这一地址，通常分配给端口的地址靠近地址空间的顶端</li>
</ul>
</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309121522818.png" alt="image-20230912152203048"></li>
</ul>
</li>
</ul>
<h3 id="5-1-2-I-O控制方式"><a href="#5-1-2-I-O控制方式" class="headerlink" title="5.1.2 I/O控制方式"></a>5.1.2 I/O控制方式</h3><p><strong>程序直接控制方式</strong></p>
<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309121527513.png" alt="image-20230912152738683"></li>
<li>计算机从外部设备读取的每个字，CPU需要对外设状态进行循环检查，直到确定该字已经在I/O控制器的数据寄存器中</li>
<li>简单且易于实现，但CPU和I/O设备只能串行工作，导致CPU的利用率相当低</li>
</ul>
<p><strong>中断驱动方式</strong></p>
<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309121541722.png" alt="image-20230912154121528"></li>
<li>允许I/O设备主动打断CPU的运行并请求服务。从而“解放”CPU，使得其向I/O控制器发送读命令后可以继续做其他有用的工作</li>
<li>优点：CPU和I/O设备可以并行工作</li>
<li>缺点：<ul>
<li>每个字在I/O设备与内存之间的传输，都需要经过CPU</li>
<li>频繁的中断处理会消耗较多的CPU时间</li>
</ul>
</li>
</ul>
<p><strong>DMA方式</strong></p>
<ul>
<li><p><img src="https://gitee.com/renmale-sztu/image/raw/master/202309121547871.png" alt="image-20230912154703888"></p>
</li>
<li><p>在I/O设备和内存之间开辟直接的数据交换通路，彻底“解放”CPU</p>
</li>
<li>特点：<ul>
<li>基本单位是数据块</li>
<li>所传送的数据，是从设备直接送入内存的，或者相反</li>
<li>仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在DMA控制器的控制下完成的</li>
</ul>
</li>
<li>DMA控制器<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309121549376.png" alt="image-20230912154913622"></li>
<li>命令/状态寄存器（CR）：接收从CPU发来的I/O命令、有关控制信息，或设备的状态</li>
<li>内存地址寄存器（MAR）：在输入时，它存放把数据从设备传送到内存的起始目标地址；在输出时，它存放由内存到设备的内存源地址</li>
<li>数据寄存器（DR）：暂存从设备到内存或从内存到设备的数据</li>
<li>数据计数器（DC）：存放本次要传送的字（节）数</li>
</ul>
</li>
<li>优点<ul>
<li>数据传输以“块”为单位，CPU介入频率进一步降低</li>
<li>数据的传输不再需要先经过CPU再写入内存，数据传输效率进一步增加</li>
<li>CPU和I/O设备的并行性得到提升</li>
</ul>
</li>
<li>缺点<ul>
<li>CPU每发出一条I/O指令，只能读/写一个或多个连续的数据块，</li>
<li>如果要读/写多个离散存储的数据块，或者要将数据分别写到不同的内存区域时，CPU要分别发出多条I/O指令，进行多次中断处理才能完成</li>
</ul>
</li>
</ul>
<p><strong>*通道控制方式</strong></p>
<ul>
<li>通道<ul>
<li>一种硬件，“弱鸡版”CPU，可以识别并执行一系列的通道指令</li>
<li>通道指令类型单一，没有自己的内存，所执行的通道程序是放在主机的内存中的，与CPU共享内存</li>
</ul>
</li>
<li>与DMA的区别<ul>
<li>DMA方式需要CPU来控制传输的数据块大小，内存位置等，而通道方式中这些信息是由通道来控制的</li>
<li>DMA控制器对应一台设备与内存传递数据；一个通道可以控制多台设备与内存的数据交换</li>
</ul>
</li>
<li>优点：CPU、I/O设备、通道可以并行工作，资源利用率很高</li>
<li>缺点：需要专门的通道硬件支持，实现困难</li>
<li>通道分类<ul>
<li>字节多路通道——大量的低速、中速I/O设备</li>
<li>数组选择通道——少量的高速I/O设备</li>
<li>数组多路通道——大量的高速I/O设备</li>
</ul>
</li>
</ul>
<p><strong>总结</strong></p>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/202309121559468.png" alt="image-20230912155859442"></p>
<h3 id="5-1-3-I-O软件层次结构"><a href="#5-1-3-I-O软件层次结构" class="headerlink" title="5.1.3 I/O软件层次结构"></a>5.1.3 I/O软件层次结构</h3><h4 id="用户层I-O软件"><a href="#用户层I-O软件" class="headerlink" title="用户层I/O软件"></a>用户层I/O软件</h4><ul>
<li>用户层软件实现了与用户交互的接口，用户可直接使用该层提供的、与I/O操作相关的库函数对设备进行操作</li>
</ul>
<h4 id="设备独立性软件"><a href="#设备独立性软件" class="headerlink" title="设备独立性软件"></a>设备独立性软件</h4><ul>
<li>设备独立性又称设备无关性</li>
<li>用于实现用户程序和设备驱动器的统一接口、设备命令、设备的保护及设备的分配与释放等，为设备管理和数据传送提供必要的存储空间</li>
<li>功能<ul>
<li>用用户层（或文件层）提供同一的接口</li>
<li>对设备的分配与回收</li>
<li>将逻辑设备名映射为物理设备名</li>
<li>对设备进行保护，禁止用户直接访问设备</li>
<li>缓冲管理</li>
<li>差错控制</li>
<li>提供独立于设备的大小统一的逻辑块，屏蔽设备之间信息交换单位大小和传输速率的差异</li>
</ul>
</li>
</ul>
<h4 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h4><ul>
<li>主要负责对硬件设备的具体控制，将上层发出的一系列命令（如read/write）转化成特定设备“能听得懂”的一系列操作。包括设置设备寄存器；检查设备状态等</li>
<li>驱动程序一般会以一个独立进程的方式存在</li>
</ul>
<h4 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h4><ul>
<li>用于保存中断进程的CPU环境，转入相应的中断处理程序进行处理，处理完毕再恢复被中断进程的线程后，返回到被中断进程</li>
<li><p>主要任务</p>
<ul>
<li>进行进程上下文的切换，对处理中断信号源进行测试，读取设备状态和修改进程状态等</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309121622404.png" alt="image-20230912162222830"></li>
</ul>
</li>
</ul>
<h3 id="5-1-4-应用程序I-O接口"><a href="#5-1-4-应用程序I-O接口" class="headerlink" title="5.1.4 应用程序I/O接口"></a>5.1.4 应用程序I/O接口</h3><p><strong>字符设备接口</strong></p>
<ul>
<li>字符设备时指数据的存取和传输时以字符为单位的设备，属于独占设备，为此接口还需要提供打开和关闭操作，实现互斥</li>
<li>如 get/put 系统调用</li>
</ul>
<p><strong>块设备接口</strong></p>
<ul>
<li>块设备是指数据的存取和传输是以数据块为单位的设备，基本特征是传输速率较高，可寻址</li>
<li>典型的块设备是磁盘，I/O采用DMA方式</li>
<li>如read/write/seek 系统调用</li>
</ul>
<p><strong>网络设备接口</strong></p>
<ul>
<li>又称网络套接字（socket）接口</li>
<li>如 socket/bind 系统调用</li>
</ul>
<p><strong>阻塞/非阻塞 I/O</strong></p>
<ul>
<li>阻塞I/O<ul>
<li>用户进程调用I/O操作时，进程就被阻塞，需要等待I/O操作完成，进程才被唤醒继续执行</li>
</ul>
</li>
<li>非阻塞I/O<ul>
<li>用户进程调用I/O操作时，不阻塞该进程，该I/O调用返回一个错误返回值，通常，进程需要通过轮询的方式来5.25查看I/O操作是否完成</li>
</ul>
</li>
</ul>
<h1 id="5-2设备独立性软件"><a href="#5-2设备独立性软件" class="headerlink" title="5.2设备独立性软件"></a>5.2设备独立性软件</h1><ul>
<li>I/O核心子系统<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309131512882.png" alt="image-20230913151157707"></li>
</ul>
</li>
<li>在UNIX中，设备被看做是一种特殊的文件</li>
<li>设备的独立性主要是指用户使用设备的透明性，即用户程序和实际使用的物理设备无关</li>
</ul>
<h3 id="5-2-1-与设备无关的软件"><a href="#5-2-1-与设备无关的软件" class="headerlink" title="5.2.1 与设备无关的软件"></a>5.2.1 与设备无关的软件</h3><ul>
<li>设备独立性软件包括执行所有设备公有操作的软件</li>
</ul>
<h3 id="5-2-2-高速缓存与缓冲区"><a href="#5-2-2-高速缓存与缓冲区" class="headerlink" title="5.2.2 高速缓存与缓冲区"></a>5.2.2 高速缓存与缓冲区</h3><h4 id="磁盘高速缓存（Disk-Cache）"><a href="#磁盘高速缓存（Disk-Cache）" class="headerlink" title="磁盘高速缓存（Disk Cache）"></a><strong>磁盘高速缓存（Disk Cache）</strong></h4><ul>
<li>逻辑上属于磁盘，物理上则是驻留在内存中的盘块</li>
<li>在内存中分为两种形式<ul>
<li>在内存中开辟一个单独的空间作为磁盘高速缓存，大小固定</li>
<li>把未利用地内存空间作为一个缓冲池，供请求分页系统和磁盘I/O时共享</li>
</ul>
</li>
</ul>
<h4 id="缓冲区（Buffer）"><a href="#缓冲区（Buffer）" class="headerlink" title="缓冲区（Buffer）"></a><strong>缓冲区（Buffer）</strong></h4><ul>
<li>引入缓冲区的目的<ul>
<li>缓和CPU与I/O设备间速度不匹配的矛盾</li>
<li>减少对CPU的中断频率，放宽对CPU中断响应时间的限制</li>
<li>解决基本数据单元大小（即数据粒度）不匹配的问题</li>
<li>提高CPU和I/O设备之间的并行性</li>
</ul>
</li>
<li>实现方法<ul>
<li>采用硬件缓冲器——成本太高</li>
<li>采用缓冲区</li>
</ul>
</li>
</ul>
<h5 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h5><ul>
<li>操作系统会在主存中为其分配一个缓冲区（若题目中没有特别说明，一个缓冲区的大小就是一个块）</li>
<li>当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出；当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出。</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309131541164.png" alt="image-20230913154104260"></li>
<li>假定从磁盘把一块数据输入到缓冲区的时间为T，操作系统将该缓冲区中的数据传送到用户区的时间为M，而CPU对这一块数据处理的时间为C<ul>
<li>单缓冲区处理每块数据用时为</li>
<li><script type="math/tex; mode=display">max(C,T) + M</script></li>
</ul>
</li>
</ul>
<h5 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h5><ul>
<li>操作系统会在主存中为其分配两个缓冲区</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309131546435.png" alt="image-20230913154644611"></li>
<li>假定从磁盘把一块数据输入到缓冲区的时间为T，操作系统将该缓冲区中的数据传送到用户区的时间为M，而CPU对这一块数据处理的时间为C<ul>
<li>单缓冲区处理每块数据用时为</li>
<li><script type="math/tex; mode=display">max(C+M,T)</script></li>
</ul>
</li>
<li>在通信中，单缓冲区在任意时刻只能实现单向的数据传输，双缓冲区可以实现全双工通信</li>
</ul>
<h5 id="循环缓冲"><a href="#循环缓冲" class="headerlink" title="循环缓冲"></a>循环缓冲</h5><ul>
<li>包含多个大小相等的缓冲区，每个缓冲区中有一个连接指针指向下一个缓冲区，最后一个缓冲区指针指向第一个缓冲区，多个缓冲区构成一个环形</li>
<li>in/out指针<ul>
<li>输入时<ul>
<li>in指针指向可以输入数据的第一个空缓冲区</li>
<li>out指针指向可以提取数据的第一个满缓冲区</li>
</ul>
</li>
<li>输出时相反</li>
</ul>
</li>
</ul>
<h5 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h5><ul>
<li><p>缓冲池由系统中共用的缓冲区组成</p>
</li>
<li><p>这些缓冲区按使用状况可以分为</p>
<ul>
<li><p>空缓冲队列</p>
</li>
<li><p>装满输入数据的缓冲队列（输入队列）</p>
</li>
<li>装满输出数据的缓冲队列（输出队列）</li>
</ul>
</li>
<li><p>根据一个缓冲区在实际运算中扮演的功能不同，又设置了四种工作缓冲区</p>
<ul>
<li>用于收容输入数据的工作缓冲区（hin）</li>
<li>用于提取输入数据的工作缓冲区（sin）</li>
<li>用于收容输出数据的工作缓冲区（hout）</li>
<li>用于提取输出数据的工作缓冲区（sout）</li>
</ul>
</li>
<li><p><img src="https://gitee.com/renmale-sztu/image/raw/master/202309131607916.png" alt="image-20230913160713729"></p>
</li>
<li>当输入进程需要输入数据时，便从空缓冲队列的队首摘下一个空缓冲区，把它作为收容输入工作缓冲区，然后把输入数据输入其中，装满后再将它挂到输入队列队尾。当计算进程需要输入数据时，便从输入队列取得一个缓冲区作为提取输入工作缓冲区，计算进程从中提取数据，数据用完后再将它挂到空缓冲队列尾。当计算进程需要输出数据时，便从空缓冲队列的队首取得一个空缓冲区，作为收容输出工作缓冲区，当其中装满输出数据后，再将它挂到输出队列队尾。当要输出时，由输出进程从输出队列中取得一个装满输出数据的缓冲区，作为提取输出工作缓冲区，当数据提取完后，再将它挂到空缓冲队列的队尾</li>
</ul>
<h4 id="高速缓冲与缓冲区的对比"><a href="#高速缓冲与缓冲区的对比" class="headerlink" title="高速缓冲与缓冲区的对比"></a>高速缓冲与缓冲区的对比</h4><ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309131611021.png" alt="image-20230913161131015"></li>
</ul>
<h3 id="5-2-3-设备分配与回收"><a href="#5-2-3-设备分配与回收" class="headerlink" title="5.2.3 设备分配与回收"></a>5.2.3 设备分配与回收</h3><script type="math/tex; mode=display">设备分配时应考虑的因素\left\{ \begin{matrix} 设备的固有属性\left\{ \begin{matrix} 独占性 \\ 共享性 \\ 虚拟性  \end{matrix}  \right.\\设备的分配算法\left\{ \begin{matrix} 先来先服务 \\ 虚拟性  \end{matrix} \right.\\ 设备分配中的安全性\left\{ \begin{matrix} 安全分配方式 \\ 不安全分配方式  \end{matrix} \right.  \end{matrix} \right.</script><h4 id="设备分配概述"><a href="#设备分配概述" class="headerlink" title="设备分配概述"></a>设备分配概述</h4><ul>
<li>设备分配是指根据用户的I/O请求分配所需的设备</li>
<li>分配的总原则是充分发挥设备的使用效率，尽可能让设备忙碌，又要避免由于不合理的分配造成进程的死锁</li>
<li>设备的固有属性<ul>
<li>独占设备——一个时段只能分配给一个进程</li>
<li>共享设备——可同时分配给多个进程，宏观上同时共享使用设备</li>
<li>虚拟设备——采用SPOOLing技术将独占设备改造成虚拟的共享涉笔，可同时分配给多个进程使用</li>
</ul>
</li>
</ul>
<h4 id="设备分配的数据结构"><a href="#设备分配的数据结构" class="headerlink" title="设备分配的数据结构"></a>设备分配的数据结构</h4><ul>
<li>设备控制表 DCT<ul>
<li>一个设备控制表就表征一个设备，整个控制表中的表项就是设备的各个属性</li>
<li>凡因请求本设备而未得到满足的进程，应将其PCB按某种策略排成一个设备请求队列，设备队列的队首指针指向该请求队列队首PCB</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309131625163.png" alt="image-20230913162556172"></li>
</ul>
</li>
<li>控制器控制表 COCT 与 通道控制表 CHCT<ul>
<li>设备控制器控制设备与内存交换数据，有需要请求通道为它服务，因此每个COCT有一个表下个存放指向相应通道控制表CHCT的指针</li>
<li>一个通道可以为多个设备控制器服务，因此CHCT中有一个指针，指向一个表，表中信息表达的是CHCT提供服务的那几个设备控制器</li>
<li>CHCT和COCT是一对多的关系</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309131631155.png" alt="image-20230913163103273"></li>
</ul>
</li>
<li>系统设备表 SDT<ul>
<li>整个系统只有一张SDT，记录已连接到系统中的所有物理设备的情况，每个物理设备占一个表目</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309131631974.png" alt="image-20230913163111205"></li>
</ul>
</li>
</ul>
<h4 id="设备分配的策略"><a href="#设备分配的策略" class="headerlink" title="设备分配的策略"></a>设备分配的策略</h4><ul>
<li><p>设备分配原则</p>
<ul>
<li>设备分配应根据设备特性、用户要求和系统配置情况。既要充分发挥设备的使用效率，又要避免造成进程死锁，还要将用户程序和具体设备隔离开</li>
</ul>
</li>
<li><p>设备分配方式</p>
<ul>
<li>静态分配<ul>
<li>进程运行前为其分配全部所需资源，运行结束后归还资源——破坏“保持和请求”条件，不会死锁</li>
<li>主要用于对独占设备的分配</li>
<li>设备的使用效率低</li>
</ul>
</li>
<li>动态分配<ul>
<li>进程运行过程中动态申请设备资源</li>
<li>有利于提高设备利用率，但如果分配算法使用不当，会造成死锁</li>
</ul>
</li>
</ul>
</li>
<li>设备分配算法<ul>
<li>先请求先服务</li>
<li>优先级高者优先</li>
<li>……</li>
</ul>
</li>
</ul>
<h4 id="设备分配的安全性"><a href="#设备分配的安全性" class="headerlink" title="设备分配的安全性"></a>设备分配的安全性</h4><ul>
<li>安全分配方式<ul>
<li>每当进程发出I/O请求后便进入阻塞态，直到其I/O操作完成时才被唤醒</li>
<li>优点——设备分配安全</li>
<li>缺点——CPU和I/O设备串行工作</li>
</ul>
</li>
<li>不安全分配方式<ul>
<li>仅当进程所请求的设备已被另一进程占用时，才进入阻塞态</li>
<li>优点——一个进程可以同时操作多台设备</li>
<li>缺点——可能造成死锁</li>
</ul>
</li>
</ul>
<h4 id="将逻辑设备名映射为物理设备名"><a href="#将逻辑设备名映射为物理设备名" class="headerlink" title="将逻辑设备名映射为物理设备名"></a>将逻辑设备名映射为物理设备名</h4><ul>
<li>逻辑设备名的好处<ul>
<li>增加设备分配的灵活性和设备的利用率</li>
<li>易于实现I/O重定向，所谓I/O重定向，是指用于I/O操作的设备可以更换，而不必改变应用程序</li>
<li>引入设备独立性<ul>
<li>指应用程序独立于具体使用的物理设备</li>
</ul>
</li>
</ul>
</li>
<li>逻辑设备表 LUT<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309121616786.png" alt="image-20230912161651913"></li>
<li>两种方式<ul>
<li>整个系统值设置一张LUT，适用于单用户操作系统</li>
<li>每个用户设置一张</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="设备分配的过程"><a href="#设备分配的过程" class="headerlink" title="设备分配的过程"></a>设备分配的过程</h4><ol>
<li>根据进程请求的物理设备名查找SDT</li>
<li>查找SDT，找到用户进程指定类型的、并且空闲的设备，将其分配给该进程。操作系统在逻辑设备表（LUT）中新增一个表项</li>
<li>根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程</li>
<li>根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程</li>
</ol>
<h3 id="5-2-4-SPOOLing技术（假脱机技术）"><a href="#5-2-4-SPOOLing技术（假脱机技术）" class="headerlink" title="5.2.4 SPOOLing技术（假脱机技术）"></a>5.2.4 SPOOLing技术（假脱机技术）</h3><ul>
<li>为了缓和CPU的高速性与I/O设备低速性之间的矛盾，引入了脱机输入/输出技术，它是操作系统中采用的一项将独占设备改造成共享设备的技术。该技术利用专门的外围控制机，将低速I/O设备上的数据传送到高速磁盘上，或者相反</li>
</ul>
<p><strong>组成</strong></p>
<ul>
<li>输入井和输出井<ul>
<li>在磁盘上开辟出的两个存储区域</li>
<li>输入井模拟脱机输入时的磁盘，用于收容I/O设备输入的数据</li>
<li>输出井模拟脱机输出时的磁盘，用于收容I/O设备输出的数据</li>
</ul>
</li>
<li>输入缓冲区和输出缓冲区<ul>
<li>在内存中开辟的两个缓冲区</li>
<li>输入缓冲区用于暂存输入设备送来的数据，以后再传送到输入井</li>
<li>输出缓冲区用于暂存从输出井送来的数据，以后再传送的输出设备</li>
</ul>
</li>
<li>输入进程和输出进程<ul>
<li>输入/输出进程用于模拟脱机输入/输出时的外围控制机</li>
</ul>
</li>
</ul>
<p><strong>共享打印机</strong></p>
<ul>
<li>共享打印机是使用SPOOLing技术的实例。当用户进程请求打印输出时，SPOOLing系统同意打印，但是并不真正立即把打印机分配给该进程，而由假脱机管理进程完成两项任务<ul>
<li>在磁盘缓冲区中为之申请一个空闲盘块，并将要打印的数据送入其中暂存</li>
<li>为用户进程申请一张空白的用户请求打印表，并将用户的打印要求填入其中，再将该表挂到假脱机文件队列上</li>
</ul>
</li>
<li>这两项工作完成后，虽然还没有任何实际的打印输出，但是对于用户进程而言，其打印任务已完成</li>
<li>真正的打印操作是在打印机空闲且该打印任务已排在等待队列队首进行的</li>
</ul>
<p><strong>特点</strong></p>
<ul>
<li>提高了 IO的速度，将对低速I/O设备执行的IO操作演变为对磁盘缓冲区中数据的存取，如同脱机输入/输出一样，缓和了CPU和低速I/O设备之间的速度不匹配的矛盾</li>
<li>将独占设备改造为共享设备，在假脱机打印机系统中，实际上并没有为任何进程分配设备</li>
<li>实现了虚拟设备功能，对每个进程而言，它们都认为自己独占了一个设备</li>
<li>空闲换时间</li>
</ul>
<h3 id="5-2-5-设备驱动程序接口"><a href="#5-2-5-设备驱动程序接口" class="headerlink" title="5.2.5 设备驱动程序接口"></a>5.2.5 设备驱动程序接口</h3><ul>
<li>每个设备驱动程序于操作系统之间都有着相同或相近的接口</li>
</ul>
<h1 id="5-3-磁盘和固态硬盘"><a href="#5-3-磁盘和固态硬盘" class="headerlink" title="5.3 磁盘和固态硬盘"></a>5.3 磁盘和固态硬盘</h1><h3 id="5-3-1-磁盘"><a href="#5-3-1-磁盘" class="headerlink" title="5.3.1 磁盘"></a>5.3.1 磁盘</h3><p><img src="https://gitee.com/renmale-sztu/image/raw/master/202309132023402.png" alt="image-20230913202340589" style="zoom:80%;"></p>
<p><strong>构造</strong></p>
<ul>
<li>磁盘<ul>
<li>表面涂有磁性物质的物理盘片，通过一个称为磁头的导体线圈从磁盘存取数据</li>
</ul>
</li>
<li>磁头</li>
<li>磁道<ul>
<li>磁盘上的数据存储在一组同心圆中，称为磁道</li>
</ul>
</li>
<li>扇区<ul>
<li>一个磁道划分为几百个扇区，每个扇区固定存储大小，一个扇区称为一个盘块</li>
</ul>
</li>
</ul>
<p><strong>磁盘地址</strong></p>
<ul>
<li>用“ 柱面号·盘面号·扇区号” 表示</li>
<li>不可以改变顺序</li>
</ul>
<p><strong>磁盘的分类</strong></p>
<ul>
<li>固定头磁盘<ul>
<li>磁头不可移动</li>
</ul>
</li>
<li>活动头磁盘<ul>
<li>磁头可移动</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>可换盘磁盘<ul>
<li>盘片可更换</li>
</ul>
</li>
<li>固定盘磁盘<ul>
<li>盘片不可更换</li>
</ul>
</li>
</ul>
<h3 id="5-3-2-磁盘的管理"><a href="#5-3-2-磁盘的管理" class="headerlink" title="5.3.2 磁盘的管理"></a>5.3.2 磁盘的管理</h3><h4 id="磁盘初始化"><a href="#磁盘初始化" class="headerlink" title="磁盘初始化"></a>磁盘初始化</h4><ul>
<li>低级格式化（物理格式化）- step1<ul>
<li>将磁盘的各个磁道划分为扇区</li>
</ul>
</li>
<li>每个扇区的数据结构通常由头部、数据区域（通常为512B）和尾部组成，头部和尾部包含了一些磁盘控制器的信息</li>
</ul>
<h4 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h4><ul>
<li>分区 - step2<ul>
<li>将磁盘分为一个或多个柱面组成的分区，每个分区的起始扇区和大小都记录在磁盘主引导记录的分区表中</li>
</ul>
</li>
<li>逻辑格式化（创建文件系统） - step3<ul>
<li>操作系统将初始的文件系统数据结构存储到磁盘上，这些数据结构包括空闲空间和已分配的空间以及一个初始为空的目录</li>
</ul>
</li>
<li>簇（Linux中称为块）~前面提过~<ul>
<li>多个相邻扇区的组合</li>
<li>提高效率——扇区的单位太小</li>
</ul>
</li>
</ul>
<h4 id="引导块"><a href="#引导块" class="headerlink" title="引导块"></a>引导块</h4><ul>
<li>自举程序（初始化程序）<ul>
<li>计算机开机需要进行一系列初始化的工作</li>
<li>初始化CPU、寄存器、设备控制器和内存等，接着启动操作系统</li>
<li>通常存放在ROM中<ul>
<li>只在ROM中保留很小的自举装入程序，完整功能的引导程序保存在磁盘的启动块上，启动快位于磁盘的固定位置</li>
</ul>
</li>
</ul>
</li>
<li>启动磁盘（系统磁盘）<ul>
<li>具有启动分区的磁盘</li>
</ul>
</li>
</ul>
<h4 id="坏块"><a href="#坏块" class="headerlink" title="坏块"></a>坏块</h4><ul>
<li>由于磁盘有移动部件且容错能力弱，因此容易导致一个或多个扇区损坏</li>
<li>简单磁盘——手动处理</li>
<li>复杂磁盘——备用扇区<ul>
<li>控制器维护磁盘内的坏块列表。这个列表在出厂低级格式化时就已初始化，并在磁盘的使用过程中不断更新</li>
<li>低级格式化将一些块保留作为备用，操作系统看不到这些块，控制器可以采用备用块来逻辑地替代坏块</li>
</ul>
</li>
</ul>
<h3 id="5-3-3-磁盘调度算法"><a href="#5-3-3-磁盘调度算法" class="headerlink" title="5.3.3 磁盘调度算法"></a>5.3.3 磁盘调度算法</h3><h4 id="决定一次磁盘读写操作时间的因素"><a href="#决定一次磁盘读写操作时间的因素" class="headerlink" title="决定一次磁盘读写操作时间的因素"></a>决定一次磁盘读写操作时间的因素</h4><p><strong>寻找时间<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.355ex;" xmlns="http://www.w3.org/2000/svg" width="2.259ex" height="1.887ex" role="img" focusable="false" viewBox="0 -677 998.6 834.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mi" transform="translate(617,-150) scale(0.707)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g></g></g></g></svg></mjx-container></strong></p>
<ul>
<li>活动头磁盘在读写信息前，将磁头移动到指定磁道所需要的时间</li>
<li>包括跨越n条磁道的时间，启动磁臂的时间s</li>
<li><script type="math/tex; mode=display">T_s=m*n+s</script></li>
<li>m是磁盘驱动器速度有关的常数，约为0.2ms</li>
<li>磁臂的启动时间约为2ms</li>
</ul>
<p><strong>旋转延迟时间<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.231ex" height="1.889ex" role="img" focusable="false" viewBox="0 -677 985.9 834.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mi" transform="translate(617,-150) scale(0.707)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container></strong></p>
<ul>
<li>磁头定位都某一磁道的扇区所需要的时间</li>
<li>设磁盘的旋转速度为r转/s</li>
<li><script type="math/tex; mode=display">T_r = \frac{1}{2r}</script></li>
</ul>
<p><strong>传输时间<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.087ex" height="1.889ex" role="img" focusable="false" viewBox="0 -677 922.3 834.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mi" transform="translate(617,-150) scale(0.707)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g></g></g></g></svg></mjx-container></strong></p>
<ul>
<li>从磁盘读出或向磁盘写入数据所经历的时间</li>
<li>取决于每次所读/写的字节数b和磁盘的旋转速度</li>
<li><script type="math/tex; mode=display">T_t=\frac{b}{rN}</script></li>
<li>N为一个磁道上的字节数</li>
</ul>
<p><strong>总平均存取时间<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.355ex;" xmlns="http://www.w3.org/2000/svg" width="2.355ex" height="1.887ex" role="img" focusable="false" viewBox="0 -677 1041.1 834.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mi" transform="translate(617,-150) scale(0.707)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g></g></g></g></svg></mjx-container></strong></p>
<ul>
<li><script type="math/tex; mode=display">T_a=T_s+\frac{1}{2r}+\frac{b}{rN}</script></li>
</ul>
<h4 id="先来先服务算法-FCFS"><a href="#先来先服务算法-FCFS" class="headerlink" title="先来先服务算法 FCFS"></a>先来先服务算法 FCFS</h4><ul>
<li>根据进程请求访问磁盘的先后顺序进行调度</li>
<li>具有公平性</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309132053732.png" alt="image-20230913205309935"></li>
</ul>
<h4 id="最短寻找时间优先算法-SSTF"><a href="#最短寻找时间优先算法-SSTF" class="headerlink" title="最短寻找时间优先算法 SSTF"></a>最短寻找时间优先算法 SSTF</h4><ul>
<li>选择调度处理的磁道是与当前磁头所在磁道距离最近的磁道</li>
<li>并不能保证平均寻找时间最小</li>
<li>性能比FCFS好</li>
<li>会产生“饥饿”现象</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309132054882.png" alt="image-20230913205447189"></li>
</ul>
<h4 id="扫描算法-SCAN（电梯调度算法）"><a href="#扫描算法-SCAN（电梯调度算法）" class="headerlink" title="扫描算法 SCAN（电梯调度算法）"></a>扫描算法 SCAN（电梯调度算法）</h4><ul>
<li>在磁头当前移动方向上选择与当前磁头所在磁道距离最近的请求作为下一次服务的对象</li>
<li>不到端不可改变方向</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309132057290.png" alt="image-20230913205701522"></li>
</ul>
<h4 id="循环扫描算法-C-SCAN"><a href="#循环扫描算法-C-SCAN" class="headerlink" title="循环扫描算法 C-SCAN"></a>循环扫描算法 C-SCAN</h4><ul>
<li>在扫面算法的基础上规定磁道单向移动，回返时直接快速移动至起起始端而不服务任何请求</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309132059967.png" alt="image-20230913205908094"></li>
<li>改进——磁头移动到最远的一个请求即可返回，不需要到达磁盘端点<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309132100262.png" alt="image-20230913210002342"></li>
</ul>
</li>
</ul>
<h4 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a>算法总结</h4><p><img src="https://gitee.com/renmale-sztu/image/raw/master/202309132102702.png" alt="image-20230913210205860"></p>
<h4 id="减少延迟时间的方法"><a href="#减少延迟时间的方法" class="headerlink" title="减少延迟时间的方法"></a>减少延迟时间的方法</h4><h5 id="交替编号"><a href="#交替编号" class="headerlink" title="交替编号"></a>交替编号</h5><ul>
<li>让相邻的扇区在物理上不相邻</li>
<li>原因——读完每个扇区后需要一定时间处理，需要再转一圈才能继续读，交替编号可以使用读中间盘块的时间来处理</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309132106444.png" alt="image-20230913210602666"></li>
</ul>
<h5 id="错位命名"><a href="#错位命名" class="headerlink" title="错位命名"></a>错位命名</h5><ul>
<li>让相邻盘面的扇区编号错位</li>
<li>原因——当要读取的数据连续且跨盘面时可以节省时间——为什么用“ 柱面号·盘面号·扇区号” 表示磁盘地址</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309132108224.png" alt="image-20230913210837343"></li>
</ul>
<h3 id="5-3-4-固态硬盘"><a href="#5-3-4-固态硬盘" class="headerlink" title="5.3.4 固态硬盘"></a>5.3.4 固态硬盘</h3><h4 id="固态硬盘的特性"><a href="#固态硬盘的特性" class="headerlink" title="固态硬盘的特性"></a>固态硬盘的特性</h4><ul>
<li>固态硬盘（SSD）<ul>
<li>基于闪存技术的存储器</li>
<li>由一个或多个闪存芯片和闪存翻译层组成</li>
<li>闪存翻译层——将来自CPU的逻辑块读写请求翻译成对底层物理设备的读写控制信号</li>
</ul>
</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309132112576.png" alt="image-20230913211200754"><ul>
<li>由B块组成，每块有P页</li>
<li>只有在一页所属的块整个被擦除后，才能写这一页（擦除有磨损）</li>
</ul>
</li>
<li>随机写很慢<ul>
<li>擦除块比较慢，比访问页高一个数量级</li>
<li>修改已包含数据的页<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.192ex" height="1.902ex" role="img" focusable="false" viewBox="0 -683 969 840.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mi" transform="translate(675,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container>，那么这个块中含有有用数据的页都必须被复制到一个新块中，才能进行写操作</li>
</ul>
</li>
<li>优点（相较于传统磁盘）<ul>
<li>由半导体存储器构成，没有移动的部件，因而随机访问速度比机械硬盘快很多</li>
<li>没有噪音和震动，能耗更低、抗震性好、安全性高</li>
</ul>
</li>
</ul>
<h4 id="磨损均衡"><a href="#磨损均衡" class="headerlink" title="磨损均衡"></a>磨损均衡</h4><ul>
<li>SSD的擦写寿命有限，弥补寿命缺陷</li>
</ul>
<p><strong>动态磨损均衡</strong></p>
<ul>
<li>写入数据时，自动选择较新的闪存块</li>
</ul>
<p><strong>静态磨损均衡</strong></p>
<ul>
<li>更为先进</li>
<li>SSD监测并自动进行数据分配，让老旧的闪存块承担以读为主的存储任务，较新的承担更多的写任务</li>
</ul>
]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>计组-第三章-存储系统</title>
    <url>/2023/09/16/%E8%AE%A1%E7%BB%84-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="3-1-存储器概述"><a href="#3-1-存储器概述" class="headerlink" title="3.1 存储器概述"></a>3.1 存储器概述</h1><h3 id="3-1-1-存储器的分类"><a href="#3-1-1-存储器的分类" class="headerlink" title="3.1.1 存储器的分类"></a>3.1.1 存储器的分类</h3><h5 id="按在计算机中的作用（层次）分类"><a href="#按在计算机中的作用（层次）分类" class="headerlink" title="按在计算机中的作用（层次）分类"></a><strong>按在计算机中的作用（层次）分类</strong></h5><ul>
<li>主存储器<ul>
<li>简称主存，又称内存储器（内存）</li>
<li>存放计算机运行期间所需的程序和数据，CPU可以直接随机地对其进行访问，也可以和高速缓冲存储器及辅助存储器交换数据</li>
<li>容量较小，存取速度较快，价格较高</li>
</ul>
</li>
</ul>
<span id="more"></span>
<ul>
<li>辅助存储器<ul>
<li>简称辅存，又称外存储器（外存）</li>
<li>存放当前暂时不用地程序和数据，以及一些需要永久性保存地信息</li>
<li>辅存的内容需要调入主存后才能被访问</li>
<li>容量大，存取速度较慢，单位成本低</li>
</ul>
</li>
<li>高速缓冲存储器<ul>
<li>简称Cache，位于主存和CPU之间</li>
<li>存放当前CPU经常使用的指令和数据，以便CPU能高速访问它们</li>
<li>存储容量小，价格高</li>
<li>现代计算机集成在CPU中</li>
</ul>
</li>
</ul>
<h5 id="按存储介质分类"><a href="#按存储介质分类" class="headerlink" title="按存储介质分类"></a><strong>按存储介质分类</strong></h5><ul>
<li>磁表面存储器——磁盘、磁带</li>
<li>磁芯存储器</li>
<li>半导体存储器——MOS型存储器、双极型存储器</li>
<li>光存储器——光盘</li>
</ul>
<h5 id="按存取方式分类"><a href="#按存取方式分类" class="headerlink" title="按存取方式分类"></a><strong>按存取方式分类</strong></h5><ul>
<li>随机存储器（RAM）<ul>
<li>读写任何一个存储单元所需时间都相同，与存储单元所在的物理位置无关</li>
<li>读写方便、使用灵活、主要用作主存或高速缓冲存储器</li>
</ul>
</li>
<li>只读存储器（ROM）<ul>
<li>存储器的内容只能随机读出而不能写入，断电内容也不会丢失</li>
<li>派生出的存储器页包含可以反复重写的类型，广义的只读存储器可通过电擦除等方式写入，保留了断电内容保护、随机读取特性，但写入速度比读取速度慢得多</li>
</ul>
</li>
<li>串行访问存储器<ul>
<li>对存储单元进行读/写操作时，需按其物理位置得先后顺序寻址</li>
<li>顺序存取存储器（SAM）<ul>
<li>只能按某种顺序存取，存取时间的长短与信息在存储体上的物理位置有关</li>
<li>存取速度慢</li>
</ul>
</li>
<li>直接存取存储器（DAM）<ul>
<li>既有随机存取特性，也有顺序存取特性</li>
<li>先直接选取信息所在区域，然后按顺序方式存取</li>
</ul>
</li>
</ul>
</li>
<li>相联存储器<ul>
<li>即可以按内容访问的存储器（CAM）</li>
<li>可以按照内容检索到存储位置进行读写</li>
<li>”快表“</li>
</ul>
</li>
</ul>
<h5 id="按信息的可保存性分类"><a href="#按信息的可保存性分类" class="headerlink" title="按信息的可保存性分类"></a><strong>按信息的可保存性分类</strong></h5><ul>
<li>易失性存储器<ul>
<li>断电后，存储信息即消失</li>
<li>RAM</li>
</ul>
</li>
<li>非易失性存储器<ul>
<li>断电后信息仍然保存的存储器</li>
<li>ROM、磁表面存储器和光存储器</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>破坏性读出<ul>
<li>存储单元所存储的信息被读出时，原存储信息被破坏</li>
<li>具有破坏性读出性能的存储器，每次读出操作后，必须紧接一个再生的操作，以恢复被破坏的信息1</li>
</ul>
</li>
<li>非破坏性读出<ul>
<li>被读单元原存储信息不被破坏</li>
</ul>
</li>
</ul>
<h3 id="3-1-2-存储器的性能指标"><a href="#3-1-2-存储器的性能指标" class="headerlink" title="3.1.2 存储器的性能指标"></a>3.1.2 存储器的性能指标</h3><ul>
<li>3个主要性能指标<ul>
<li>存储容量<ul>
<li>存储容量 = 存储字数 * 字长</li>
<li>存储字数表示存储器的地址空间大小</li>
<li>字长表示一次存取操作的数据量</li>
</ul>
</li>
<li>单位成本<ul>
<li>每位价格 = 总成本 / 总容量</li>
</ul>
</li>
<li>存储速度<ul>
<li>数据传输率 = 数据的宽度 / 存取周期</li>
<li>存取时间<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.355ex;" xmlns="http://www.w3.org/2000/svg" width="2.355ex" height="1.887ex" role="img" focusable="false" viewBox="0 -677 1041.1 834.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mi" transform="translate(617,-150) scale(0.707)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g></g></g></g></svg></mjx-container><ul>
<li>指从启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间</li>
</ul>
</li>
<li>存取周期<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.914ex" height="1.889ex" role="img" focusable="false" viewBox="0 -677 1287.8 834.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mi" transform="translate(617,-150) scale(0.707)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container><ul>
<li>又称读写周期或访问周期</li>
<li>指存储器进行一次完整的读写操作所需的全部时间，即连续两次独立访问存储器操作（读/写）之间所需的最小时间间隔</li>
</ul>
</li>
<li>主存宽带<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="3.31ex" height="1.902ex" role="img" focusable="false" viewBox="0 -683 1462.8 840.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g><g data-mml-node="mi" transform="translate(792,-150) scale(0.707)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container><ul>
<li>又称数据传输率，表示每秒从主存进出信息的最大数量</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>目标——大容量、低成本、高速度</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309161514010.png" alt="image-20230916151409810"></li>
</ul>
<h3 id="3-1-3-多级层次的存储系统"><a href="#3-1-3-多级层次的存储系统" class="headerlink" title="3.1.3 多级层次的存储系统"></a>3.1.3 多级层次的存储系统</h3><ul>
<li>解决存储系统大容量、高速度和低成本3个相互制约的矛盾</li>
<li>Cache—主存层<ul>
<li>解决CPU和主存速度不匹配的问题</li>
</ul>
</li>
<li>主存—辅存层<ul>
<li>解决存储系统的容量问题</li>
</ul>
</li>
<li>Cache、主存能直接和CPU交换信息，辅存通过主存和CPU交换信息</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309161519637.png" alt="image-20230916151900700"></li>
<li>主存和Cache之间的数据调动是由硬件自动完成的，对所有程序员均是透明的</li>
<li>主存和辅存之间的数据调动则是由硬件和操作系统共同完成的</li>
</ul>
]]></content>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统—第二章—进程与线程</title>
    <url>/2023/09/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h2 id="2-1进程和线程"><a href="#2-1进程和线程" class="headerlink" title="2.1进程和线程"></a>2.1进程和线程</h2><h3 id="进程的概念和特征"><a href="#进程的概念和特征" class="headerlink" title="进程的概念和特征"></a>进程的概念和特征</h3><ul>
<li>概念<ul>
<li>进程是程序的一次执行过程</li>
<li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动</li>
<li>进程时具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位</li>
</ul>
</li>
</ul>
<span id="more"></span>
<ul>
<li>特征<ul>
<li>动态性<ul>
<li>动态性是进程最基本的特征</li>
</ul>
</li>
<li>并发性<ul>
<li>并发性事进程的重要特征，也是操作系统的重要特征</li>
</ul>
</li>
<li>独立性<ul>
<li>进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位</li>
</ul>
</li>
<li>异步性<ul>
<li>各并发的进程以各自独立的、不可预知的速度向前推进</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h3><ul>
<li><p>5种状态</p>
<ul>
<li>运行态</li>
<li>就绪态</li>
<li>阻塞态</li>
<li>创建态</li>
<li>结束态</li>
</ul>
</li>
<li><p>前3种是基本状态</p>
</li>
<li>状态的转换<ul>
<li>就绪态→运行态</li>
<li>运行态→就绪态</li>
<li>运行态→阻塞态</li>
<li>阻塞态→就绪态</li>
<li><img src="https://th.bing.com/th/id/Rac88fec7ff0914ae100f5e5e16e8dcfe?rik=7YelQuouaD%2bGjA&amp;riu=http%3a%2f%2fbbs.yanzhishi.cn%2fimage%2fshow%2fattachments-2020-06-xiLvreQp5eddd748e949a.jpg&amp;ehk=ltevwD1oUrnv7VDTg627MgfwonKq5e28Z%2bNCcgsA8E8%3d&amp;risl=&amp;pid=ImgRaw" alt=""></li>
<li>一个进程从运行态变成阻塞态是主动行为</li>
<li>从阻塞态变成就绪态是被动行为，需要其他相关进程的协助</li>
</ul>
</li>
<li>进程的组织方式<ul>
<li>链接方式<ul>
<li>按照进程状态将PCB分为多个队列</li>
<li>操作系统持有指向各个队列的指针</li>
</ul>
</li>
<li>索引方式<ul>
<li>根据进程状态的不同，建立几张索引表</li>
<li>操作系统持有指向各个索引表的指针</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h3><ul>
<li>进程控制块（PCB）<ul>
<li>系统利用PCB来描述进场的基本情况和运行状态，进而控制和管理进程</li>
<li>PCB是进程存在的唯一标志</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202308262144282.png" alt="image-20230826214434112"></li>
</ul>
</li>
<li>相关数据段<ul>
<li>可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果</li>
</ul>
</li>
<li>程序段<ul>
<li>能被进程调度程序调度到CPU执行的程序代码段</li>
</ul>
</li>
</ul>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><ul>
<li>概念<ul>
<li>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能</li>
</ul>
</li>
<li><p>原语</p>
<ul>
<li>一般把进程控制用的程序称为原语</li>
<li>执行期间不允许中断</li>
<li>不可分割的基本单位</li>
<li>开中断/关中断</li>
</ul>
</li>
<li><p>进程的创建：创建原语</p>
<ul>
<li>过程<ul>
<li>为新进程分配一个唯一的进程标识号，并申请一个空白PCB</li>
<li>为进程分配其运行所需的资源</li>
<li>初始化PCB</li>
<li>将新进程插入就绪队列</li>
</ul>
</li>
<li>引起进程创建的事件<ul>
<li>用户登陆</li>
<li>作业调度</li>
<li>提供服务</li>
<li>应用请求</li>
</ul>
</li>
</ul>
</li>
<li>进程的终止：撤销原语<ul>
<li>过程<ul>
<li>从PCB集合中超导终止终止进程的PCB</li>
<li>若进程正在运行，立即剥夺CPU，将CPU分配给其他进程</li>
<li>终止其所有子进程</li>
<li>将该进程拥有的所有资源归还给父进程或操作系统</li>
<li>删除PCB</li>
</ul>
</li>
<li>引起进程终止的事件主要 <ul>
<li>正常结束</li>
<li>异常结束</li>
<li>外界干预</li>
</ul>
</li>
</ul>
</li>
<li>进程的阻塞和唤醒：阻塞原语（Block）、唤醒原语（Wakeup）<ul>
<li>阻塞原语<ul>
<li>过程<ul>
<li>找到要阻塞的进程对应的PCB</li>
<li>保护进程运行现场，将PCB状态信息设置为“阻塞态“，暂时停止进程运行</li>
<li>将PCB插入相应事件的等待队列</li>
</ul>
</li>
<li>引起事件<ul>
<li>需要等待系统分配某种资源</li>
<li>需要等待相互合作的其他进程完成工作</li>
</ul>
</li>
</ul>
</li>
<li>唤醒原语<ul>
<li>过程<ul>
<li>在事件等待中找到PCB</li>
<li>将PCB从等待队列移除，设置进程为就绪态</li>
<li>将PCB插入就绪队列，等待被调度</li>
</ul>
</li>
<li>引起事件<ul>
<li>等待的事件发生</li>
</ul>
</li>
</ul>
</li>
<li>阻塞原语和唤醒原语作用相反，必须成对使用</li>
</ul>
</li>
<li>进程切换：切换原语<ul>
<li>引起事件<ul>
<li>当前进程时间片到</li>
<li>有更高优先级的进程到达</li>
<li>当前进程主动阻塞</li>
<li>当前进程终止</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="进程的通信"><a href="#进程的通信" class="headerlink" title="进程的通信"></a>进程的通信</h3><ul>
<li>低级通信方式―PV操作</li>
<li>高级通信方法 ↓ <ul>
<li>共享存储<ul>
<li>在通信的进程之间存在一块可直接访问的共享空间，通过对共享空间进行写/读操作实现进程之间的信息交换</li>
<li>在对共享空间进行读/写操作时，需要使用同步互斥工具</li>
<li>分类<ul>
<li>基于数据结构的共享——低级</li>
<li>基于存储区的共享——高级</li>
</ul>
</li>
<li>操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具，数据交换由用户自己安排读/写指令</li>
</ul>
</li>
<li>消息传递：<ul>
<li>在消息传递系统中，进程间的数据交换以格式化的消息为单位</li>
<li>通过操作系统提供的发送消息和接受消息两个原语来进行数据交换</li>
<li>微内核与服务器之间的通信就采用了消息传递</li>
<li>分类<ul>
<li>直接通信方式<ul>
<li>发送进程直接把消息发送给接收进程</li>
</ul>
</li>
<li>间接通信方式<ul>
<li>发送进程把消息发送到某个中间实体，接收进程从中间实体取得消息</li>
<li>中间实体一般称为信箱</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>管道通信―是消息传递的一种特殊方式<ul>
<li>pipe文件</li>
<li>允许进程按生产者-消费者方式进行通信</li>
<li>数据在管道中先进先出</li>
<li>克服文件进行通信<ul>
<li>限制管道大小</li>
<li>读进程也可能工作得比写进程快</li>
</ul>
</li>
<li>从管道读数据时一次性操作，数据一旦被读取，就被管道抛弃<ul>
<li>一个管道允许多个写进程，一个读进程（2014年408真题高教社官方答案）</li>
<li>多个写进程，多个读进程（Linux）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="线程概念和多线程模型"><a href="#线程概念和多线程模型" class="headerlink" title="线程概念和多线程模型"></a>线程概念和多线程模型</h3><p><strong>线程的基本概念</strong></p>
<ul>
<li><p>概念</p>
<ul>
<li>线程最直接的理解就是“轻量级进程”，他是一个基本的CPU执行单元</li>
</ul>
</li>
<li><p>组成</p>
<ul>
<li>线程ID</li>
<li>程序计数器</li>
<li>寄存器集合</li>
<li>堆栈</li>
</ul>
</li>
<li>进程与线程的比较<ul>
<li>调度<ul>
<li>线程是独立调度的基本单位，进程是拥有资源的基本单位</li>
<li>同一进程的线程切换不会引起进程切换</li>
<li>不同进程的线程切换会引起进程切换</li>
</ul>
</li>
<li>拥有资源<ul>
<li>进程是拥有资源的基本单位，而线程不拥有系统资源（除了一点点必不可少的资源）</li>
</ul>
</li>
<li>并发性<ul>
<li>一个进程中的多个线程之间可以并发执行，甚至不同进程中的线程也能并发执行</li>
<li>提高了系统资源的利用率和系统的吞吐量</li>
</ul>
</li>
<li>独立性<ul>
<li>每个进程都拥有独立的地址空间和资源，除了共享全局变量，不允许其他进程访问</li>
<li>某进程中的线程对其他进程不可见</li>
<li>同一进程的线程共享进程的地址空间和资源</li>
</ul>
</li>
<li>系统开销<ul>
<li>线程的创建和切换易于进程</li>
<li>线程之间的同步与通信非常容易实现，无须操作系统的干预</li>
<li>进程间通信（IPC）需要进程同步和互斥手段的辅助，以保证数据的一致性</li>
</ul>
</li>
<li>支持多处理机系统<ul>
<li>各个线程可以占用不同的CPU</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>线程的属性</strong> </p>
<ul>
<li>线程是一个轻型实体，它不拥有系统资源，但每个线程都应有一个唯一的标识符和一个线程控制块，线程控制块记录线程执行的寄存器和栈等现场状态</li>
<li>不同线程可以执行相同的程序，即同一个服务程序被不同的用户调用时，操作系统把它们创建成不同的线程</li>
<li>同一进程的各个线程共享该进程所拥有的资源</li>
<li>线程是处理机的独立调度单位，多个线程是可以并发执行的；在多CPU的计算机系统中，各线程可同时占用不同的CPU</li>
<li>一个线程被创建后，便开始了它的生命周期，直至终止。线程在生命周期内会经历阻塞态、就绪态和运行态等各种状态变化、</li>
</ul>
<p><strong>线程的状态和转移</strong></p>
<ul>
<li>执行状态：线程已获得处理机而正在运行</li>
<li>就绪状态：线程已具备各种执行条件，只需再获得CPU便可立即执行</li>
<li>阻塞状态：线程在执行中因某事件受阻而处于暂停状态</li>
<li>线程着三种基本状态之间的转换和进程基本状态之间的转换是一样的</li>
</ul>
<p><strong>线程的组织和控制</strong></p>
<ul>
<li>线程控制块TCB<ul>
<li>线程标识符，TID（与PID类似）</li>
<li>一组寄存器，包括程序计数器，状态寄存器和通用寄存器</li>
<li>线程运行状态，用于描述线程正处于何种状态</li>
<li>优先级</li>
<li>线程专有存储区，线程切换时用于保存现场</li>
<li>堆栈指针，由于过程调用时保存局部变量和返回地址</li>
</ul>
</li>
<li>同一进程中的所有线程都完全共享进程的地址空间和全局变量，一个线程可以读、写、甚至清楚另一个线程的堆栈、</li>
<li>”初始化线程“——用于创建新线程</li>
<li>通常，线程被终止后并不立即释放它所占有的资源，只有当进程中的其他线程执行了分离函数后，被终止线程才与资源分离，此时的资源才能被其他线程利用</li>
<li>被终止但尚未释放资源的线程仍可被其他线程调用，以使被终止线程重新恢复运行</li>
</ul>
<p><strong>线程的实现方式</strong></p>
<ul>
<li>用户级线程 ULT<ul>
<li>有关线程管理（创建、撤销和切换等）的所有工作都由应用程序在用户空间（应用程序）中完成，内核意识不到线程的存在</li>
<li>优点：<ul>
<li>进程切换不需要转换到内核空间，节省了模式切换的开销</li>
<li>调度算法可以是进程专用的，不同的进程可根据自身的需要，对自己的线程选择不同的调度算法</li>
<li>用户及线程的实现和操作系统平台无关，对线程管理的代码时属于用户程序的一部分</li>
</ul>
</li>
<li>缺点<ul>
<li>系统调用的阻塞问题，当线程执行一个系统调用时，不仅该线程会被阻塞，而且进程内的所有线程都会被阻塞</li>
<li>不能发挥多处理机的优势，内核每次分配给一个进程的仅有一个CPU，因此进程中仅有一个线程能执行</li>
</ul>
</li>
</ul>
</li>
<li>内核级线程 KLT（内核支持的线程）<ul>
<li>线程管理的所有工作由操作系统内核完成</li>
<li>优点<ul>
<li>能发挥多处理机的优势，内核能同时调度同一进程中的多个线程并行执行</li>
<li>如果进程中的一个线程被阻塞，内核可以调度该进程中的其他线程占用处理机，也可以运行其他进程中的线程</li>
<li>内核支持线程具有很小的数据结构和堆栈，线程切换比较快、开销小</li>
<li>内核本身与可采用多线程技术，可以提高系统的执行速度和效率</li>
</ul>
</li>
<li>缺点<ul>
<li>同一进程中的线程切换，需要从用户态转到核心态进行，系统开销较大，这是因为用户进程的线程在用户态运行，而线程调度和管理是在内核实现的</li>
</ul>
</li>
</ul>
</li>
<li>组合方式<ul>
<li>结合上述两种方式</li>
</ul>
</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202308301513927.png" alt="image-20230830151304967"></li>
</ul>
<p><strong>多线程模型</strong></p>
<ul>
<li>有些系统同时支持用户线程和内核线程，由此产生了不同的多线程模型  </li>
<li>多对一模型<ul>
<li>将多个用户级线程映射到一个内核级线程</li>
<li>优点——线程管理是在用户空间进行的，因而效率比较高</li>
<li>缺点——如果一个线程在访问内核时发送阻塞，则整个进程都会被阻塞；在任何时刻，只有一个线程能够访问内核，多个线程不能同时在多个处理机上运行</li>
</ul>
</li>
<li>一对一模型<ul>
<li>将每个用户及线程映射到一个内核级线程</li>
<li>优点——当一个线程被阻塞后，允许调度另一个线程运行，所以并发能力较强</li>
<li>缺点——没创建一个用户线程，相应地就需要创建以一个内核线程，开销较大</li>
</ul>
</li>
<li>多对多模型<ul>
<li>将N个用户及线程映射到M个内核级线程上（N ≥ M）</li>
<li>既克服了多对一模型并发度不高的缺点，又克服了一对一模型的一个用户进程占用太多内核级线程而开销太大的缺点；此外，还拥有上述两种模型各自的优点</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202308301518606.png" alt="image-20230830151836929"></li>
</ul>
</li>
</ul>
<h2 id="2-2-处理机的调度"><a href="#2-2-处理机的调度" class="headerlink" title="2.2 处理机的调度"></a>2.2 处理机的调度</h2><h3 id="调度的概念"><a href="#调度的概念" class="headerlink" title="调度的概念"></a>调度的概念</h3><ul>
<li>调度的基本概念<ul>
<li>处理机调度是对处理机进行分配，即从就绪队列按照一定的算法（公平、高效）选择一个进程并将处理机分配给他运行，以实现进程并发地执行</li>
<li>处理机调度是多道程序操作系统的基础，是操作系统设计的核心问题</li>
</ul>
</li>
<li>调度层次<ul>
<li>作业调度/高级调度<ul>
<li>按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程</li>
<li>每个作业只调入一次，调出一次</li>
<li>内存与辅存之间的调度</li>
<li>多道批处理系统大多配有作业调度，而其他系统中通常不需要配置作业调度</li>
<li>外存→内存（面向作业）</li>
</ul>
</li>
<li>中继调度/内存调度<ul>
<li>按照某种规则，从挂起队列中选择合适的进程将其数据调回内存</li>
<li>作用：提高内存利用率和系统吞吐量</li>
<li>为此将哪些暂时不能运行的进程调至外存等待，把此时的进程状态称为<strong>挂起态</strong> ，当它们已具备运行条件且内存稍有空闲时，则重新调入内存，并修改其状态为就绪态，挂在就绪队列上等待</li>
<li>外存→内存（面向进程）</li>
</ul>
</li>
<li>进程调度/低级调度<ul>
<li>按照某种规则，从就绪队列中选择一个进程为其分配处理机</li>
<li>是操作系统中最基本的一种调度，进程调度的频率很高，一般十几毫秒一次</li>
<li>内存→CPU</li>
</ul>
</li>
</ul>
</li>
<li>三级调度的联系<ul>
<li>作业调度为进程活动做准备，进程调度使进程正常活动起来</li>
<li>中级调度将暂时不能运行的进程挂起，中级调度处于作业调度和进程调度之间</li>
<li>作业调度次数少，中级调度次数略多，进程调度频率最高</li>
<li>进程调度是最基本的，不可或缺</li>
</ul>
</li>
</ul>
<h3 id="调度的目标"><a href="#调度的目标" class="headerlink" title="调度的目标"></a>调度的目标</h3><ul>
<li>CPU利用率<ul>
<li>利用率 = CPU有效工作时间 / ( CPU有效工作时间 + CPU空闲等待时间)</li>
</ul>
</li>
<li>系统吞吐量<ul>
<li>单位时间内CPU完成作业的数量</li>
</ul>
</li>
<li>周转时间<ul>
<li>作业提交到完成所经历的时间</li>
<li>周转时间 = 作业完成时间 - 作业提交时间</li>
<li>平均周转时间 = （作业1周转时间 + … + 作业n周转时间）/ n</li>
<li>带权周转时间 = 作业周转时间  / 作业实际运行时间</li>
<li>平均带权周转时间 = （作业1带权周转时间 + … + 作业n带权周转时间）/ n</li>
</ul>
</li>
<li>等待时间<ul>
<li>进程处于等处理机的时间之和</li>
</ul>
</li>
<li>响应时间<ul>
<li>用户提交请求到系统首次产生响应所用的时间</li>
</ul>
</li>
</ul>
<h3 id="调度的实现"><a href="#调度的实现" class="headerlink" title="调度的实现"></a>调度的实现</h3><p><strong>调度程序（调度器）</strong></p>
<ul>
<li><p>用于调度和分派CPU的组件</p>
</li>
<li><p><img src="https://gitee.com/renmale-sztu/image/raw/master/202308301807183.png" alt="image-20230830173250356"></p>
</li>
<li>组成<ul>
<li>排队器<ul>
<li>将进程插入到相应的就绪队列中</li>
</ul>
</li>
<li>分派器<ul>
<li>将CPU分配给新进程</li>
</ul>
</li>
<li>上下文切换器<ul>
<li>将当前进程的上下文保存到其PCB中，再装入分派程序的上下文</li>
<li>移出分派程序的上下文，将新选进程的CPU现场信息装入处理机的各个相应寄存器</li>
</ul>
</li>
</ul>
</li>
<li>调度时机<ul>
<li>创建新进程</li>
<li>进程退出</li>
<li>运行进程阻塞</li>
<li>I/O中断发生</li>
</ul>
</li>
</ul>
<p><strong>调度的时机、切换与过程</strong></p>
<ul>
<li>不能进行进程的调度与切换的情况<ul>
<li>在处理中断的过程中</li>
<li>进程在操作系统<strong>内核程序临界区</strong>中</li>
<li>其他需要完全屏蔽中断的原子操作过程中。如加锁、解锁、中断保护现场、恢复等原子操作</li>
</ul>
</li>
<li>应该进行进程调度与切换的情况<ul>
<li>发生引起调度条件且当前进程无法继续运行下去时，可以马上进行调度与切换</li>
<li>中断处理结束或自陷处理解除后，返回被中断进程的用户态程序执行现场前，若置上请求调度标志，即可马上进行进程调度与切换</li>
</ul>
</li>
<li>进程切换<ul>
<li>保存原进程当前断点的现场信息</li>
<li>恢复被调度进程的现场信息</li>
<li>进程调度、切换是有代价的</li>
</ul>
</li>
</ul>
<p><strong>进程调度方式</strong></p>
<ul>
<li>非剥夺调度方式（非抢占方式）<ul>
<li>只能由当前运行的进程主动放弃CPU</li>
<li>实现简单，系统开销小，适用于大多数的批处理系统，但它不能用于分时操作系统和大多数的实时系统</li>
</ul>
</li>
<li>剥夺调度方式（抢占方式）<ul>
<li>可由操作系统剥夺当前进程的CPU使用权</li>
<li>对提高系统吞吐率和响应效率都有明显的好处</li>
</ul>
</li>
</ul>
<p><strong>闲逛进程</strong></p>
<ul>
<li>如果系统中没有就绪进程，就会调度闲逛进程（idle）运行，如果没有其他进程就绪，该进程就一直运行，并在执行过程中测试中断</li>
<li>优先级最低，只要有进程就绪，就会立即让出处理机</li>
<li>不需要CPU之外的资源，不会被阻塞</li>
</ul>
<p><strong>两种线程的调度</strong></p>
<ul>
<li>用户级线程调度</li>
<li>内核级线程调度</li>
</ul>
<h3 id="典型的调度算法"><a href="#典型的调度算法" class="headerlink" title="典型的调度算法"></a>典型的调度算法</h3><p><strong>先来先服务调度算法 FCFS</strong></p>
<ul>
<li>属于不可剥夺算法</li>
<li>作业/进程调度</li>
<li>优缺点<ul>
<li>算法简单，效率低</li>
<li>对长作业有利，对短作业不利</li>
<li>有利于CPU繁忙型作业，不利于I/O繁忙型作业</li>
</ul>
</li>
</ul>
<p><strong>短作业优先算法 SJF</strong></p>
<ul>
<li>默认为非抢占式</li>
<li>抢占式-最短剩余时间优先算法</li>
<li>作业（SJF）/进程调度（SPF）</li>
<li>优点<ul>
<li>SJF调度算法的平均等待时间、平均周转时间”最少“</li>
</ul>
</li>
<li>缺点<ul>
<li>长作业周转时间增加</li>
<li>不能保证紧迫性作业被及时处理</li>
<li>长作业「饥饿」现象</li>
</ul>
</li>
</ul>
<p><strong>优先级调度算法</strong></p>
<ul>
<li><p>作业/进程调度</p>
</li>
<li><p>是否能抢占</p>
<ul>
<li><p>非剥夺式优先级调度算法</p>
</li>
<li><p>剥夺式优先级调度算法</p>
</li>
</ul>
</li>
<li><p>优先级能否改变</p>
<ul>
<li><p>静态优先级</p>
<ul>
<li>优先级再创建进程时确认，运行期间保持不变</li>
</ul>
</li>
<li><p>动态优先级</p>
<ul>
<li>在进程运行过程中，根据进程情况的变化动态调整优先级</li>
</ul>
</li>
</ul>
</li>
<li><p>进程优先级设置</p>
<ul>
<li>系统进程 &gt; 用户进程</li>
<li>交互型进程 &gt; 非交互型进程（或者前台进程 &gt; 后台进程）</li>
<li>I/O型进程 &gt; 计算型进程</li>
</ul>
</li>
<li>优点<ul>
<li>用优先级区分紧急程度、重要程度，适用于实时操作系统，可灵活地调整对各种作业/进程的偏好程度</li>
</ul>
</li>
<li>缺点<ul>
<li>若源源不断地有高优先级进程到来，则可能导致饥饿</li>
</ul>
</li>
</ul>
<p><strong>高响应比优先调度算法</strong></p>
<ul>
<li>非抢占式的调度算法</li>
<li></li>
<li>作业/进程调度</li>
<li><script type="math/tex; mode=display">响应比 = \frac{等待时间 + 要求服务时间}{要求服务时间}</script></li>
<li>优缺点<ul>
<li>等待时间相同时，要求服务时间短的优先（SJF的优点）</li>
<li>要求服务时间相同时，等待时间长的优点（FCFS的优点）</li>
<li>对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题</li>
</ul>
</li>
</ul>
<p><strong>时间片轮转调度算法 RR</strong></p>
<ul>
<li><p>剥夺式调度算法</p>
</li>
<li><p>适用于分时系统</p>
</li>
<li>进程调度</li>
<li>时间片过大退化为FCFS，过小切换频繁，开销增大</li>
<li>时间片的长短通常由下列因素确定<ul>
<li>系统响应时间</li>
<li>就绪队列中的进程数目</li>
<li>系统的处理能力</li>
</ul>
</li>
<li>优点<ul>
<li>公平，响应快，适用于分时操作系统</li>
</ul>
</li>
<li>缺点<ul>
<li>高频率的进程切换会有一定的开销</li>
<li>不区分任务紧急程度</li>
</ul>
</li>
</ul>
<p><strong>多级队列调度算法</strong></p>
<ul>
<li>该算法在系统中设置多个就绪队列，将不同类型或性质的进程固定分配到不同的就绪队列</li>
<li>每个队列可实施不同的调度算法</li>
<li>同一队列中的进程可以设置不同的优先级，不同的队列本身也可以设置不同的优先级</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202308311526189.png" alt="image-20230831152636226"></li>
</ul>
<p><strong>多级反馈队列调度算法</strong></p>
<ul>
<li><p>抢占式</p>
</li>
<li><p>进程调度</p>
</li>
<li><p>是时间片轮转调度算法和优先级调度算法的综合和发展</p>
</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202308311523426.png" alt="image-20230831152308190"></li>
<li>优点<ul>
<li>课本<ul>
<li>终端型作业用户：短作业优先</li>
<li>短批处理作业用户：周转时间较短</li>
<li>长批处理作业用户：经过前面几个队列得到部分执行，不会长期得不到处理</li>
</ul>
</li>
<li>课件<ul>
<li>对各类型进程相对公平（FCFS的优点）</li>
<li>每个新到达的进程都可以很快就得到响应（RR的优点）</li>
<li>短进程只用较少的时间就可以完成（SPF的优点）</li>
<li>不必实现估计进程的运行时间（避免用户造假）</li>
<li>可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程</li>
</ul>
</li>
</ul>
</li>
<li>会导致饥饿</li>
</ul>
<h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><ul>
<li>上下文切换<ul>
<li>上下文是指某一时刻CPU寄存器和程序计数器的内容</li>
<li>过程<ul>
<li>挂起一个进程，保存CPU上下文，包括程序计数器和其他寄存器</li>
<li>更新PCB信息</li>
<li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列</li>
<li>选择另一个进程执行，并更新其PCB</li>
<li>跳转到新进程PCB中的程序计数器所指向的位置执行</li>
<li>恢复处理机上下文</li>
</ul>
</li>
</ul>
</li>
<li>上下文的切换（即进程切换）是需要耗费资源的</li>
<li>与模式切换的区别<ul>
<li>用户态和内核态之间的切换称为模式切换</li>
<li>模式切换时，CPU逻辑上可能还在执行同一进程</li>
<li>上下文切换只能发生在内核态，他是多任务操作系统的一个必需的特性</li>
</ul>
</li>
</ul>
<h2 id="2-3同步与互斥"><a href="#2-3同步与互斥" class="headerlink" title="2.3同步与互斥"></a>2.3同步与互斥</h2><h3 id="同步与互斥的基本概念"><a href="#同步与互斥的基本概念" class="headerlink" title="同步与互斥的基本概念"></a>同步与互斥的基本概念</h3><p><strong>临界资源</strong></p>
<ul>
<li>概念：一次仅允许一个进程使用的资源称为临界资源</li>
<li><p>临界资源的访问过程</p>
<ul>
<li>进入区——负责检查是否可以进入临界区，若可以，设置正在访问临界区资源的标志（上锁）</li>
<li>临界区——访问临界资源的那段代码</li>
<li>退出区——将正在访问临界区的标志清除</li>
<li>剩余区</li>
</ul>
</li>
<li><p>```cpp<br>do{<br>entry section; // 进入区<br>critical section; // 临界区<br>exit section; // 退出区<br>remainder section; // 剩余区<br>} while(true)</p>
</li>
</ul>
<p><strong>同步―直接制约关系</strong></p>
<p><strong>互斥―间接制约关系</strong></p>
<ul>
<li>为了防止两个进程同时进入临界区，同步机制应该遵循以下原则<ul>
<li>空闲让进</li>
<li>忙则等待</li>
<li>有限等待——对请求访问的进程，应保证能在有限时间内进入临界区</li>
<li>让权等待——当进程不能进入临界区时，应立即释放处理器，防止进程忙等待 ~不一定非得实现~</li>
</ul>
</li>
</ul>
<h3 id="实现临界区互斥的基本方法"><a href="#实现临界区互斥的基本方法" class="headerlink" title="实现临界区互斥的基本方法"></a>实现临界区互斥的基本方法</h3><p><strong>软件实现方法</strong></p>
<ul>
<li>单标志法<ul>
<li>思想：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是每个进程进入临界区的权限只能被另一个进程赋予</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202308311700037.png" alt="image-20230831170041925"></li>
<li>违背“空闲让进”——两个进程必须交替进入临界区，若某个进程不再进入临界区，则另一个进程也将无法进入临界区，造成资源利用不充分</li>
</ul>
</li>
<li>双标志法先检查<ul>
<li>思想——在每个进程访问临界区资源之前，先查看临界资源是否正在被访问，若正被访问，该进程需等待；否则，进程才进入自己的临界区。</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202308311711985.png" alt="image-20230831171112985"></li>
<li>违背“忙则等待”——按照①⑤②⑥③⑦…的顺序执行，P0和P1会同时访问临界区——进入区的“检查”和”上锁“两个处理不是一气呵成的</li>
<li>优点——不用交替进入，可连续使用</li>
</ul>
</li>
<li>双标志法后检查<ul>
<li>思想——先将自己的标志设置为TRUE，再检查对方的状态标志，若对方标志为TRUE，则进程等待，否则进入临界区</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202308311717270.png" alt="image-20230831171722602"></li>
<li>违背了”空闲让进“和”有限等待“——产生”饥饿“现象——按照①⑤②⑥…的顺序执行，P0和P1都将无法进入临界区——两个进程几乎同时都想进入临界区时，他们分别将自己的标志置为TRUE，并且同时检查对方的状态，发现对方也要进入临界区，双方互相谦让，结果谁也进不了临界区</li>
</ul>
</li>
<li>Peterson’s Algorithm<ul>
<li>结合双标志法、单标志法的思想</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202308311734452.png" alt="image-20230831173447377"></li>
<li>遵循了空闲让进、忙则等待、有限等待三个原则，但是未遵循让权等待的原则——进入区会一直卡在while循环，没有及时释放资源</li>
</ul>
</li>
</ul>
<p><strong>硬件实现方法（低级方法，元方法）</strong></p>
<ul>
<li><p>中断屏蔽方法（屏蔽中断，关中断）</p>
<ul>
<li>```<br>…<br>关中断;<br>临界区;<br>开中断;<br>…<br>// 关中断后即不允许当前进程被中断，也必然不会发生进程切换<pre class="line-numbers language-none"><code class="language-none">
  - 优点：简单、高效（很方便）

  - 缺点：

    - 限制了处理机交替执行的能力，执行的效率会明显降低
    - 不适用于多处理机
    - 只适用于操作系统内核进程（开/关中断指令只能运行在内核态，让用户随意使用会很危险）

- 硬件指令方法

  - 硬件实现—原子操作—不允许中断
  - TestAndSet指令
    - ![image-20230831184916916](https://gitee.com/renmale-sztu/image/raw/master/202308311849954.png)
  - Swap指令
    - ![image-20230831184956966](https://gitee.com/renmale-sztu/image/raw/master/202308311849272.png)
  - 优点： 
    - 适用于任意数目的进程，而不管是单处理机还是多处理机
    - 简单容易检验正确性 
    - 可以支持进程内有多个临界区
  - 缺点
    - 进程等待进入临界区时要耗费处理机时间，不能实现让权等待，导致”饥饿“现象

### 互斥锁

- 解决临界区最简单的工具就是互斥锁
- 进入临界区获得锁，退出临界区释放锁
- 函数acquire()获得锁，release()释放锁——原子操作
- 需要连续循环忙等的互斥锁，都可称为自旋锁，如TSL指令、swap指令、单标志法
- 缺点
  - 需忙等，进程时间片用完才下处理机，违反”让权等待“
  - 不太适用于单处理机系统，忙等的过程中不可能解锁

- 优点：
  - 等待期间不用切换进程上下文，多处理器系统中，若上锁的时间短，则等待代价很低
  - 常用于多处理器系统，一个核忙等，其他核照常工作，并快速释放临界区、

### 信号量

**信号量**

- 概念：只能被两个标准的原语 wait(S) 和 signal(S) 访问，也可以记作 P操作和V操作
- PV操作——低级进程通信原语
- 原语——完成某种功能且不被分割、不被中断执行的操作序列——屏蔽中断方式

**整型信号量**

- 一个用于表示资源数目的整型量S

- ```cpp
  int S = 1; 		//初始化整形信号量S，表示当前系统中可用的打印机资源数
  
  void wait(int S){	//wait原语，相当于“进入区”
  	while(S &lt;= 0);	//如果资源数不够，就一直循环等待
  	S--;			//如果资源数够，就占用一个资源
  }	
  
  void signal(int S){	//signal原语，相当于“退出区”
  	S++;			//使用完资源后，在退出区释放资源
  }

- 只要信号量$S\le0$，就会不断测试。违背“让权等待”

**记录型信号量**

- 一种不存在“忙等”现象的进程同步机制
- ```cpp
  // 记录型信号量的定义
  typedef struct{
  	int value;				//剩余资源数
  	struct process *L;		//等待队列
  }semaphore;
  
  // 某进程需要使用资源时，通过wait原语申请
  void wait(semaphore S){
  	S.value--;
  	if(S.value &lt; 0){
  		block(S.L);		//block原语，进程自我阻塞，并插入到该资源的等待队列
  	}
  }
  
  void signal(semaphore S){ // 相当于释放资源
  	S.value++;
  	if(S.value &lt;= 0){
  		wakeup(P);		//wakeup原语，将该资源等待队列中的第一个进程唤醒
  	}
  }

**利用信号量实现同步**

- 初值为0
- 前V后P
  - 在“前操作”之后执行V(S)
  - 在“后操作”之前执行P(S)

  - ```cpp
  semaphore S = 0; // 初始化信号量，初始值位0
  P1(){
  	x;		// x语句
  	V(S);   // 告诉进程2，语句x已经完成
  }
  
  P2(){
  	P(S);   // 检查语句x是否运行完成
  	y;		// 检查无误，运行y语句
  }

**利用信号量实现进程互斥**

- 初值为1
- 对不同的临界资源需要设置不同的互斥信号量

 - ```cpp
    semaphore S = 1; // 初始化信号量，初始值位1
    P1(){
      ...
      P(S)				//加锁

  	进程1的临界区;
  	V(S);				//解锁
  	  ...
  }

  P2(){
  	...
      P(S)		
  	进程2的临界区;
  	V(S);
      ...
  }

**利用信号量实现前驱关系**

- ![image-20230901162736897](https://gitee.com/renmale-sztu/image/raw/master/202309011627623.png)

### 管程

- 概念
  - 统一管理共享资源的所有访问，实现进程互斥，这个代表共享资源的数据结构，以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序，称为管程
  - 一种语法范围，无法创建和撤销
- 组成
  - 管程的名称
  - 局部于管程内部的共享结构数据说明
  - 对该数据结构进行操作的一组过程（或函数）
  - 对局部于管程内部的共享数据设置初始值的语句
- 特征
  - 局部于管程的数据只能被局部于管程的过程所访问
  - 一个进程只有通过调用管城内的过程才能进入管程访问共享数据
  - 每次仅允许一个进程在管程内执行某个内部过程（★）

- 条件变量 condition
  - 表示阻塞原因，可以有多个
  - x.wait
    - 当x对应的条件不满足时，正在调用管程的进程调用x.wait将自己插入x条件的等待队列，并释放管程。此时其他进程可以使用该管程

  - x.signal
    - x对应的条件发生了变化，则调用x.signal，唤醒一个因x条件而阻塞的进程

- ![image-20230901184035807](https://gitee.com/renmale-sztu/image/raw/master/202309011840437.png)

- V操作一定改变信号量的值，signal不一定

### 经典同步问题  

**生产者-消费者问题**

- 问题描述
  - 系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。（注：这里的“产品”理解为某种数据）
  - 生产者、消费者共享一个初始为空、大小为n的缓冲区。
  - 只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。
  - 只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。
  - 缓冲区是临界资源，各进程必须互斥地访问。
- ![image-20230901165651086](https://gitee.com/renmale-sztu/image/raw/master/202309011656115.png)
- 交换两个P操作的顺序——导致死锁——实现互斥的P操作一定要在实现同步的P操作之后
- 两个V操作的顺序可以交换

**多生产者-多消费者问题**

- 问题描述
  - 桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。用PV操作实现上述过程。
  - 互斥关系
    - 对缓冲区（盘子）的访问要互斥进行
  - 同步关系
    - 父亲将苹果放入盘子后，女儿才能取苹果
    - 母亲将橘子放入盘子后，儿子才能取橘子
    - 只有盘子为空时，父亲/母亲才能放入水果
- ![image-20230901190031019](https://gitee.com/renmale-sztu/image/raw/master/202309011900105.png)
- 上诉代码中可以取消互斥信号量吗
  - 可以，当缓冲区大小为1时可以不使用互斥信号量，程序也可以正常运行

**读者-写者问题**

- 问题描述
  - 允许多个读者可以同时对文件执行读操作
    - 与消费者进程不同，读者进程在读数据后并不会将数据清空，不会改变数据
  - 只允许一个写者往文件中写信息
  - 任一写者在完成写操作之前不允许其他读者或写者工作
  - 写者执行写操作前，应让已有的读者和写者全部退出。
- 互斥关系
  - 读进程—读进程
  - 写进程—写进程
- ![image-20230901193650356](https://gitee.com/renmale-sztu/image/raw/master/202309011936331.png)
  - 如果没有mutex互斥量
    - 如果没有mutex互斥量，可能存在两个进程同时访问rw互斥量，count变量的修改和rw互斥量的上锁/解锁不是一气呵成的
  - 如果没有w互斥量——写进程饿死
    - 源源不断的读者进程
    - 只有最后一个读者进程会释放rw互斥量

**哲学家进餐问题**

- 问题描述

  - 一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。
  - ![image-20230901200247747](https://gitee.com/renmale-sztu/image/raw/master/202309012002779.png)

- 死锁——五个哲学家一人一只筷子

- 解决

  - 各哲学家互斥地拿筷子
  - 最多允许四个哲学家同时进餐
  - 奇数号哲学家先拿左边筷子，偶数号相反
  - ......

- ```c++
  semaphore chopstick[5]={1, 1, 1, 1, 1};
  semaphore mutex = 1;			// 互斥地取筷子
  Pi(){
  	while(1){
  		P(mutex);
  		P(chopstick[i]);		// 拿左
  		P(chopstick[i+1]%5);	// 拿右
  		V(mutex);
  		吃饭...
  		P(chopstick[i]);		// 放左
  		P(chopstick[i+1]%5);	// 放右
  		思考...
  	}
  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
</ul>
<p><strong>吸烟者问题</strong></p>
<ul>
<li>问题描述<ul>
<li>假设一个系统有<strong>三个抽烟者进程</strong>和<strong>一个供应者进程</strong>。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料再桌上，这个过程一直重复（让三个抽烟者<strong>轮流</strong>地抽烟）</li>
<li>“可生产多种产品的单生产者-多消费者”问题</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309011915547.png" alt="image-20230901191506660"></li>
</ul>
</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309011915093.png" alt="image-20230901191526884"></li>
</ul>
<h2 id="2-4死锁"><a href="#2-4死锁" class="headerlink" title="2.4死锁"></a>2.4死锁</h2><h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h3><p><strong>死锁的定义</strong></p>
<ul>
<li>概念<ul>
<li>各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象</li>
</ul>
</li>
<li>死锁、饥饿、死循环<ul>
<li>死锁<ul>
<li>至少有两个或两个以上的进程同时发生死锁</li>
</ul>
</li>
<li>饥饿<ul>
<li>概念——由于长期得不到想要的资源，某进程无法向前推进的现象</li>
<li>可能只有一个进程发生饥饿</li>
</ul>
</li>
<li>死循环<ul>
<li>概念——某进程执行过程中一直跳不出某个循环的现象</li>
<li>死锁和饥饿时管理者（操作系统）的问题，死循环是被管理者的问题</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>死锁产生的原因</strong></p>
<ul>
<li>系统资源的竞争<ul>
<li>通常系统中拥有的不可剥夺资源，其数量不足以满足多个进程运行的需要</li>
<li>只有对不可剥夺资源的竞争会产生死锁</li>
</ul>
</li>
<li>进程推进顺序非法<ul>
<li>进程在运行过程中，请求和释放资源的顺序不当</li>
</ul>
</li>
<li>信号量使用不当<ul>
<li>进程间彼此等待对方发来的消息</li>
</ul>
</li>
</ul>
<p><strong>死锁产生的必要条件</strong>（必要而非充分条件）</p>
<ul>
<li>互斥条件<ul>
<li>一段时间内某资源仅为一个进程所占有</li>
</ul>
</li>
<li>不剥夺条件<ul>
<li>进程所获得的资源在未使用完之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放</li>
</ul>
</li>
<li>请求并保持条件<ul>
<li>进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放</li>
</ul>
</li>
<li>循环等待条件<ul>
<li>存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求</li>
</ul>
</li>
</ul>
<p><strong>死锁的处理策略</strong></p>
<ul>
<li><p>设法破坏死锁的4个必要条件之一，或允许死锁产生，但当死锁发生时能检测出死锁，并有能力恢复</p>
<ul>
<li><p>死锁预防</p>
<ul>
<li>破坏死锁产生的四个必要条件中的一个或几个</li>
</ul>
</li>
<li><p>避免死锁</p>
<ul>
<li>用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）</li>
</ul>
</li>
<li><p>死锁的检测及解除</p>
<ul>
<li>允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁</li>
</ul>
</li>
</ul>
</li>
<li><p>事先预防策略</p>
<ul>
<li>死锁预防</li>
<li>死锁避免</li>
</ul>
</li>
<li><p><img src="https://gitee.com/renmale-sztu/image/raw/master/202309021437402.png" alt="image-20230902143700140"></p>
</li>
</ul>
<h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><ul>
<li><p>静态策略</p>
</li>
<li><p>破坏互斥条件</p>
<ul>
<li>若允许系统资源都能共享使用，则系统不会进入死锁状态</li>
<li>缺点<ul>
<li>为了系统安全，很多地方还需要保护这种互斥性，因此，很多时候都无法破坏互斥条件</li>
</ul>
</li>
</ul>
</li>
<li>破坏不剥夺条件<ul>
<li>当一个已保持了某些不可剥夺资源的进程请求新的资源而得不到满足时，它必须释放已经保持的所有资源</li>
<li>缺点<ul>
<li>实现复杂</li>
<li>释放已获得的资源可能造成前一阶段工作的失效，只适用于易保存和恢复状态的资源，如CPU</li>
<li>反复地申请和释放资源会增加系统开销，降低系统吞吐量</li>
<li>可能导致饥饿</li>
</ul>
</li>
</ul>
</li>
<li>破坏请求并保持条件<ul>
<li>静态分配方法<ul>
<li>一次申请所有资源，资源未满足前，不让它投入运行，一旦投入，资源一直归它所有</li>
</ul>
</li>
<li>实现简单</li>
<li>缺点<ul>
<li>系统资源被严重浪费</li>
<li>可能导致饥饿</li>
</ul>
</li>
</ul>
</li>
<li>破坏循环等待条件<ul>
<li>顺序资源分配法<ul>
<li>可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程须按编号递增的顺序请求资源，同类资源（即编号相同的资源）一次申请完</li>
<li>只要进程提出申请<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.457ex" height="1.902ex" role="img" focusable="false" viewBox="0 -683 1086 840.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g><g data-mml-node="mi" transform="translate(792,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container>资源，以后只能申请编号大于<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.457ex" height="1.902ex" role="img" focusable="false" viewBox="0 -683 1086 840.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g><g data-mml-node="mi" transform="translate(792,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container>的资源</li>
</ul>
</li>
<li>缺点<ul>
<li>不方便增加新的设备，因为可能需要重新分配所有的编号</li>
<li>进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费</li>
<li>必须按规定次序申请资源，用户编程麻烦</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><ul>
<li>动态策略</li>
</ul>
<p><strong>系统安全状态</strong></p>
<ul>
<li>安全状态<ul>
<li>所谓安全状态，是指系统能按某种进程推进的顺序（<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="13.527ex" height="1.984ex" role="img" focusable="false" viewBox="0 -683 5979 877"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mo" transform="translate(1078.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(1523.2,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(2601.8,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mo" transform="translate(3046.4,0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"></path></g><g data-mml-node="mo" transform="translate(4385.1,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(4829.8,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mi" transform="translate(675,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container>）为每个进<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.192ex" height="1.902ex" role="img" focusable="false" viewBox="0 -683 969 840.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mi" transform="translate(675,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container>分配其所需的资源，直至满足每个进程对资源的最大需求，使每个进程都可顺序完成，此时称<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="13.527ex" height="1.984ex" role="img" focusable="false" viewBox="0 -683 5979 877"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mo" transform="translate(1078.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(1523.2,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(2601.8,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mo" transform="translate(3046.4,0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"></path></g><g data-mml-node="mo" transform="translate(4385.1,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(4829.8,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mi" transform="translate(675,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container>为安全序列，</li>
<li>若系统无法找到一个安全序列，则称系统处于不安全状态</li>
</ul>
</li>
<li>并非所有的不安全状态都是死锁状态<ul>
<li>系统进入不安全状态，有可能死锁</li>
<li>系统处于安全状态，一定不可能死锁</li>
</ul>
</li>
</ul>
<p><strong>银行家算法</strong></p>
<ul>
<li><p>思想</p>
<ul>
<li>在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全态，如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待</li>
</ul>
</li>
<li><p>数据结构描述</p>
<ul>
<li>最大需求矩阵Max<ul>
<li>各进程对资源的最大需求数</li>
</ul>
</li>
<li>分配矩阵Alocation<ul>
<li>已经给各进程分配了多少资源</li>
</ul>
</li>
<li>需求矩阵Need<ul>
<li>各进程最多还需要多少资源</li>
<li>Need = Max - Allocation</li>
</ul>
</li>
<li>一维数组 Available<ul>
<li>表示还有多少可用资源</li>
</ul>
</li>
</ul>
</li>
<li><p>银行家算法描述</p>
<ul>
<li>用长度为m的一维数组 Request表示进程此次申请的各种资源数</li>
</ul>
<ol>
<li>如果 Requesti[j]≤Need[i, j] (0<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.312ex;" xmlns="http://www.w3.org/2000/svg" width="1.76ex" height="1.751ex" role="img" focusable="false" viewBox="0 -636 778 774"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g></g></g></svg></mjx-container>j<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.312ex;" xmlns="http://www.w3.org/2000/svg" width="1.76ex" height="1.751ex" role="img" focusable="false" viewBox="0 -636 778 774"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g></g></g></svg></mjx-container>m)便转向②；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。</li>
<li>如果 Requesti[j]≤Available[j] (0<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.312ex;" xmlns="http://www.w3.org/2000/svg" width="1.76ex" height="1.751ex" role="img" focusable="false" viewBox="0 -636 778 774"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g></g></g></svg></mjx-container>j<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.312ex;" xmlns="http://www.w3.org/2000/svg" width="1.76ex" height="1.751ex" role="img" focusable="false" viewBox="0 -636 778 774"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g></g></g></svg></mjx-container>m)，便转向③ ；否则表示尚无足够资源，Pi必须等待</li>
<li>系统试探着把资源分配给进程Pi，并修改相应的数据（并非真的分配，修改数值只是为了做预判）：<ul>
<li>Available = Available - Requesti;</li>
<li>Allocation[i, j] = Allocation[i, j] + Requesti[j];</li>
<li>Need[i, j] = Need[i, j] – Requesti[j]</li>
</ul>
</li>
<li>操作系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，才正式分配；否则，恢复相应数据，让进程阻塞等待</li>
</ol>
</li>
<li><p>安全性算法</p>
<ul>
<li>检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收</li>
<li>不断重复上述过程，看最终是否能让所有进程都加入安全序列</li>
</ul>
</li>
</ul>
<h3 id="死锁检测和解除"><a href="#死锁检测和解除" class="headerlink" title="死锁检测和解除"></a>死锁检测和解除</h3><p><strong>资源分配图</strong></p>
<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309021525964.png" alt="image-20230902152540879" style="zoom: 67%;"></li>
<li>圆圈代表一个进程</li>
<li>框代表一类资源，框中的一个圆表示该类的一个资源</li>
<li>从进程到资源的有向边称为请求边，表示该进程申请一个单位的该类资源</li>
<li>从资源到进程的边称为分配边，表示该类资源已有一个资源分配给了该进程</li>
</ul>
<p><strong>死锁定理</strong></p>
<ul>
<li>在资源分配图中，找出既不阻塞又不是孤点的进程 Pi（即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。如上图中，R1没有空闲资源，R2有一个空闲资源。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源）。消去它所有的请求边和分配变，使之称为孤立的结点。在下图中，P1 是满足这一条件的进程结点，于是将P1的所有边消去</li>
<li>进程 Pi 所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。在上图中，P2 就满足这样的条件。根据（1）中的方法进行一系列简化后，若能消去途中所有的边，则称该图是可完全简化的。</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309021531843.png" alt="image-20230902153140746"></li>
<li>死锁定理<ul>
<li>如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁</li>
</ul>
</li>
</ul>
<p><strong>死锁解除</strong></p>
<ul>
<li>资源剥夺法<ul>
<li>挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿</li>
</ul>
</li>
<li>撤销进程法<ul>
<li>强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来</li>
</ul>
</li>
<li>进程回退法<ul>
<li>让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>C++多线程基础</title>
    <url>/2023/02/19/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<label style="color:yellow">记笔记时翻阅了一些其他大佬的资料，如有侵权，联系我删除</label>

<h1 id="一、并发、进程、线程"><a href="#一、并发、进程、线程" class="headerlink" title="一、并发、进程、线程"></a>一、并发、进程、线程</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h2><p><strong>并发</strong>：两个或者更多的任务<del>同时发生</del>（实际上是多个任务轮流占有处理器），某一时刻只能执行一个任务：由于操作系统调度，每秒钟进行多次所谓的“任务切换”，这种切换（上下文切换）死有时间开销的。  </p>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202302272053004.png" alt="img"></p>
<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">并发是指一个处理器同时处理多个任务
并行是指多个处理器或者是多核的处理器同时处理多个不同的任务
并发是逻辑上的同时发生，而并行是物理上的同时发生
并发是一个人同时吃三个馒头，而并行的3个人同时吃三个馒头<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<span id="more"></span>
<p><strong>进程</strong>：正在运行的程序</p>
<p><strong>线程</strong>：线程是执行应用程序种的某个具体任务，比如一段程序、一个函数等</p>
<p><strong>进程和线程的关系</strong></p>
<p>进程和线程之间的关系类似于工厂和工人之间的关系，进程好比是工厂，线程就如同工厂中的工人，一个工厂可以容纳多个工人，工厂负责为所有工人提供必要的资源，所有工人<strong><em>共享这些资源</em></strong>，每个工人负责完成一项具体的任务，他们相互配合，共同保证整个工厂的平稳运行</p>
<p><strong>一个进程至少包含 1 个线程（主线程），可以包含多个线程，所有线程共享进程的资源，各个线程也可以拥有属于自己的私有资源</strong></p>
<p><strong>进程仅负责为各个线程提供所需的资源，真正执行任务的是线程，而不是进程</strong></p>
<p>线程并不是越多越好，每个线程，都需要一个独立的堆栈空间（1M），线程之间的切换要保存很多中间状态，会耗费本该属于程序运行的时间</p>
<hr>
<h2 id="2-并发的实现"><a href="#2-并发的实现" class="headerlink" title="2 并发的实现"></a>2 并发的实现</h2><p>实现方法：</p>
<ol>
<li>通过多个进程来实现并发</li>
<li>在单独的进程中，通过代码来创建除了主线程之外的其他线程来实现并发</li>
</ol>
<h3 id="2-1多进程并发"><a href="#2-1多进程并发" class="headerlink" title="2.1多进程并发"></a>2.1多进程并发</h3><p><strong>进程之间通信：</strong></p>
<p>同一台电脑上：管道，文件，消息队列，共享内存</p>
<p>不同的电脑上：socket通信技术</p>
<h3 id="2-2多线程并发"><a href="#2-2多线程并发" class="headerlink" title="2.2多线程并发"></a>2.2多线程并发</h3><p>线程：像是轻量级的进程，每个线程都有自己独立的运行路径，但是每一个进程中的所有线程共享地址空间（共享内存）</p>
<p>多线程之间的通信可以使用全局变量，指针，引用等，因此使用多线程的开销远远小于多进程</p>
<p>但是共享内存也带来了两个线程间数据一致性的问题</p>
<h1 id="二、线程的启动和结束"><a href="#二、线程的启动和结束" class="headerlink" title="二、线程的启动和结束"></a>二、线程的启动和结束</h1><p>主线程从main()开始执行，我们自己创建的线程，也需要<strong>从一个函数开始运行</strong>（初始函数），一旦这个函数运行完毕，就代表这个线程也运行结束了</p>
<p>整个进程是否执行完毕的标志是<strong>主线程是否执行完毕</strong>，如果主线程执行完毕了，就代表整个进程执行完毕了，此时，如果其他子线程还没有执行完毕，那么这些子线程会被系统<strong>强行终止</strong>，<strong>一般情况下</strong>，如果要保持子线程的运行状态的话，要让主线程保持运行</p>
<h2 id="thread-amp-join"><a href="#thread-amp-join" class="headerlink" title="thread & join"></a>thread &amp; join</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">
#include&lt;iostream&gt;
#include&lt;thread&gt; //C++标准线程库

void myprint(){
	std::cout&lt;&lt;"Hello ";
}

int main(){
	std::thread mythread(myprint); //初始化一个线程，并开始运行
	//阻塞子线程并等待myprint子线程执行完
	//当子线程执行完毕，join就执行完毕，主线程向下继续运行
	mythread.join();
	std::cout&lt;&lt;"World!"&lt;&lt;std::endl;
	return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注：线程初始化即运行，如果不如用join函数使主线程等待子线程，主线程可能比子线程先结束，导致异常</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">
#include&lt;iostream&gt;
#include&lt;thread&gt;

void doit(){
    std::cout&lt;&lt;"World!"&lt;&lt;std::endl;
}

int main(){
    std::thread a([]{
        std::cout&lt;&lt;"Hello, ";
    }),b(doit);
    a.join();
    b.join();
    return 0;
}

//输出结果为
Hello, World!
或者
World！
Hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="detach"><a href="#detach" class="headerlink" title="detach"></a>detach</h2><p>在传统的多线程程序中，主线程要等待子线程执行完毕，然后自己再退出，而在C++11新标准下，引入了detach（分离）函数，使得主线程不必再等待子线程结束，此时，子线程与主线程失去关联，子线程会驻留在后台运行</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">
#include&lt;iostream&gt;
#include&lt;thread&gt;

void myprint(){
	std::cout&lt;&lt;"Hello ";
}

int main(){
	std::thread mythread(myprint);
	mythread.detach();
	std::cout&lt;&lt;"World!"&lt;&lt;std::endl;
	return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202302282054227.png" alt="image-20230228205410147"></p>
<h2 id="joinable"><a href="#joinable" class="headerlink" title="joinable"></a>joinable</h2><p>joinable()函数：<strong>判断是否可以成功使用join()或detach()函数</strong>，返回<strong><em>true</em></strong>则可以使用join()和detach()函数，返回<strong><em>false</em></strong>则不行</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">	std::thread mythread(myprint);
	if(mythread.joinable()){
		mythread.detach();
	}
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="thread传入函数参数"><a href="#thread传入函数参数" class="headerlink" title="thread传入函数参数"></a>thread传入函数参数</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;thread&gt;
#include&lt;string&gt;
#include&lt;Windows.h&gt;

class A {
public:
	//构造
	A() { std::cout &lt;&lt; "CREATE\n"; }
	//拷贝构造
	A(const A&amp; a) { name = a.name; std::cout &lt;&lt; "COPY\n"; }
	//析构
	~A() { std::cout &lt;&lt; "DELETE\n"; }
	std::string name;
};

void ThreadMain(A a) {
	Sleep(100);
	std::cout &lt;&lt; a.name &lt;&lt; std::endl;
}

int main() {
	std::thread th;
	{
		A a;
		a.name = "test";
		th = std::thread(ThreadMain, a);
	}
	th.join();
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202303022218967.png" alt="image-20230302221754883"></p>
<p>可以发现发生了一次构造函数，两次拷贝构造函数，三次析构函数，总共生成了3次对象</p>
<p>第一次是在25行，第二次是将对象传入thread中时，第三次则是在子线程中传入ThreadMain函数时</p>
<h2 id="使用指针-引用来进行参数传递"><a href="#使用指针-引用来进行参数传递" class="headerlink" title="使用指针/引用来进行参数传递"></a>使用指针/引用来进行参数传递</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;thread&gt;
#include&lt;string&gt;
#include&lt;Windows.h&gt;

class A {
public:
	//构造
	A() { std::cout &lt;&lt; "CREATE\n"; }
	//拷贝构造
	A(const A&amp; a) { name = a.name; std::cout &lt;&lt; "COPY\n"; }
	//析构
	~A() { std::cout &lt;&lt; "DELETE\n"; }
	std::string name;
};

void ThreadMain(A *a) {
	Sleep(100);
	std::cout &lt;&lt; a-&gt;name &lt;&lt; std::endl;
}

int main() {
	std::thread th;
	{
		A a;
		a.name = "test";
		th = std::thread(ThreadMain, &amp;a);
		th.join();
	}
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202303032034746.png" alt="image-20230303203407693"></p>
<p>当使用指针来进行参数传递时，可以发现只进行了一次对象的构造以及析构，说明使用指针传递参数时，在子线程内访问的对象<strong><em>仍为外部主线程里构造的对象</em></strong></p>
<p>因此，使用指针传递参数时，应该注意让指针的生命周期<strong><em>大于</em></strong>子线程的生命周期，不然当指针过早被析构时，子线程访问不到指针所指向的空间</p>
<hr>
<p>使用<strong><em>引用</em></strong>的情况下，与使用指针的情况一样，如果引用的空间被过早释放，程序同样会出错</p>
<p>thread()函数是一个模板函数，因此在使用引用时，应该使用<strong><em>std::ref()</em></strong>特别注明该参数是一个引用</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Class A{...};

void ThreadMain(A &amp;a){...}

int main(){
    A a;
    thread th(ThreadMain,std::ref(a));
    th.join();
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="使用类来创建线程"><a href="#使用类来创建线程" class="headerlink" title="使用类来创建线程"></a>使用类来创建线程</h2><p>类需要重载()运算符，且重载函数不能包含参数</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">
class T{
public:
	void opeartor()(){
		std::cout&lt;&lt;"Hello, World!"&lt;&lt;std::endl;
	}
}

int main(){
	T tt;
	std::thread mythread(tt);
	mythread.join();
	std::cout&lt;&lt;"111"&lt;&lt;std::endl;
	return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote id="fn_注">
<sup>注</sup>. 类内不要引用外部的值，当使用detach时，主线程结束会回收变量。而引用外部的值也会出现错误，而在上面代码中，tt对象在主线程结束后也会被销毁，但由于拷贝函数的默默付出，所以并不会发生错误<a href="#reffn_注" title="Jump back to footnote [注] in the text."> ↩</a>
</blockquote>
<h2 id="使用成员函数作为线程入口函数"><a href="#使用成员函数作为线程入口函数" class="headerlink" title="使用成员函数作为线程入口函数"></a>使用成员函数作为线程入口函数</h2><p>当我们使用的函数参数过多，需要传过多的参数时，不如将参数都封装在一个类中，使用成员函数来作为线程的入口函数，当实例对象的生命周期在时，线程的生命周期就在</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;thread&gt;
#include&lt;string&gt;

class MyThread{
public:
    // 参数
    std::string str;
    // 入口函数
    void Main(){
        std::cout&lt;&lt;str&lt;&lt;std::endl;
    }
};

int main(){
    MyThread test;
    test.str="Hello World!";
    // 需要传入对象的地址
    std::thread th(&amp;MyThread::Main,&amp;test);
    th.join();
    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="封装一个简易线程类"><a href="#封装一个简易线程类" class="headerlink" title="封装一个简易线程类"></a>封装一个简易线程类</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class MyThread{
public:
	virtual void start(){
		th_=std::thread(&amp;MyThread::Main,this);
	}
private:
	std::thread th_;
	// 纯虚函数，子类必须重写该函数
	virtual void Main()=0;
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过自己封装一个简易的线程类，以后只需写一个类继承该类，重写Main方法，调用start方法就可以启动一个子线程</p>
<p>有需要的话，也可以在该类中添加<strong><em>等待</em></strong>、<strong><em>停止</em></strong>函数等</p>
<h2 id="使用lambda表达式"><a href="#使用lambda表达式" class="headerlink" title="使用lambda表达式"></a>使用lambda表达式</h2><p><strong><em>示例</em></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::thread th([](int i){
    std::cout&lt;&lt;i&lt;&lt;std::endl;},
    123
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="三、多线程通信和同步"><a href="#三、多线程通信和同步" class="headerlink" title="三、多线程通信和同步"></a>三、多线程通信和同步</h1><h2 id="1-多线程状态"><a href="#1-多线程状态" class="headerlink" title="1 多线程状态"></a>1 多线程状态</h2><h3 id="1-1-线程状态说明"><a href="#1-1-线程状态说明" class="headerlink" title="1.1 线程状态说明"></a>1.1 线程状态说明</h3><ul>
<li>初始化(Init)：该线程正在被创建</li>
<li>就绪(Ready)：该线程在就绪列表中，等待CPU调度</li>
<li>运行(Running)：该线程正在运行</li>
<li>阻塞(Blocked)：该线程被阻塞挂起；Blocked状态包括：pend(锁、事件、信号量等阻塞)、suspend(主动pend)、delay(延时阻塞)、pendtime(因为锁、事件、信号量时间等超时等待)</li>
<li>退出(Exit)：该线程运行结束，等待父线程回收其控制块资源</li>
</ul>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202303062233589.png" alt="image-20230306223321511"></p>
<h3 id="1-2-竞争状态和临界区"><a href="#1-2-竞争状态和临界区" class="headerlink" title="1.2 竞争状态和临界区"></a>1.2 竞争状态和临界区</h3><p><strong>竞争状态</strong></p>
<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">线程是非独立的，同一个进程里线程是数据共享的，当各个线程访问同一个数据资源是会出现竞争状态<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>临界区</strong></p>
<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">读写共享数据的代码片段<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong><em>避免竞争状态策略，对临界区进行保护，同时只能由一个线程进去临界区</em></strong></p>
<h2 id="2-互斥体和锁mutex"><a href="#2-互斥体和锁mutex" class="headerlink" title="2 互斥体和锁mutex"></a>2 互斥体和锁mutex</h2><h3 id="2-1-互斥锁-mutex"><a href="#2-1-互斥锁-mutex" class="headerlink" title="2.1 互斥锁 mutex"></a>2.1 互斥锁 mutex</h3><ul>
<li>lock 和 try_lock</li>
<li>unlock</li>
</ul>
<p>在各线程访问共享数据时，使用mutex.lock，这时只有先lock的线程能够访问共享数据，其他线程处于等待状态，直到该线程访问完共享数据使用mutex.unlock</p>
<h4 id="不使用锁的情况"><a href="#不使用锁的情况" class="headerlink" title="不使用锁的情况"></a>不使用锁的情况</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;thread&gt;
#include&lt;string&gt;

void ThreadMain(){
    std::cout&lt;&lt;"======================="&lt;&lt;std::endl;
    std::cout&lt;&lt;"test 001"&lt;&lt;std::endl;
    std::cout&lt;&lt;"test 002"&lt;&lt;std::endl;
    std::cout&lt;&lt;"test 003"&lt;&lt;std::endl;
    std::cout&lt;&lt;"======================="&lt;&lt;std::endl;
}

int main(){
    for(int i=0;i&lt;10;++i){
        std::thread th(ThreadMain);
        th.detach();
    }
    getchar();
    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202303072132660.png" alt="image-20230307213248578"></p>
<p>会出现不规则输出的情况</p>
<h4 id="使用锁"><a href="#使用锁" class="headerlink" title="使用锁"></a>使用锁</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">static std::mutex mux;

void ThreadMain(){
    mux.lock();
    std::cout&lt;&lt;"======================="&lt;&lt;std::endl;
    std::cout&lt;&lt;"test 001"&lt;&lt;std::endl;
    std::cout&lt;&lt;"test 002"&lt;&lt;std::endl;
    std::cout&lt;&lt;"test 003"&lt;&lt;std::endl;
    std::cout&lt;&lt;"======================="&lt;&lt;std::endl;
    mux.unlock();
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202303072134323.png" alt="image-20230307213457279"></p>
<h4 id="try-lock"><a href="#try-lock" class="headerlink" title="try_lock"></a>try_lock</h4><ul>
<li>如果互斥锁当前未被任何线程锁定，则调用线程将其锁定并返回true</li>
<li>如果互斥锁当前被另一个线程锁定，则该函数将失败并返回false，<strong><em>而不会阻塞</em></strong></li>
<li>如果互斥锁当前被调用此函数的同一线程锁定，则会产生死锁</li>
<li>在使用try_lock的时候，一定要判断其返回的值是否为true，只有在true的时候才能够执行unlock操作</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void ThreadMain()
{
    for (;;) {
        if (!mux.try_lock())
        {
            std::cout &lt;&lt; "try\n" &lt;&lt; std::flush;
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
            continue;
        }
        std::cout &lt;&lt; "==============================" &lt;&lt; std::endl;
        std::cout &lt;&lt; "test 001" &lt;&lt; std::endl;
        std::cout &lt;&lt; "test 002" &lt;&lt; std::endl;
        std::cout &lt;&lt; "test 003" &lt;&lt; std::endl;
        std::cout &lt;&lt; "==============================" &lt;&lt; std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        mux.unlock();
        std::this_thread::sleep_for(std::chrono::milliseconds(1));
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202303090958114.png" alt="image-20230309095841928"></p>
<h3 id="2-2-互斥锁的坑-线程抢占不到资源"><a href="#2-2-互斥锁的坑-线程抢占不到资源" class="headerlink" title="2.2 互斥锁的坑_线程抢占不到资源"></a>2.2 互斥锁的坑_线程抢占不到资源</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;thread&gt;
#include&lt;string&gt;
#include&lt;mutex&gt;

static std::mutex mux;

void ThreadMain(int i){
    for(;;){
        mux.lock();
        std::cout&lt;&lt;i&lt;&lt;"[in]"&lt;&lt;std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(1000));
        mux.unlock();
    }
}

int main(){
    for(int i=0;i&lt;3;++i){
        std::thread th(ThreadMain,i+1);
        th.detach();
    }
    getchar();
    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202303072336262.png" alt="image-20230307233615152"></p>
<p>有概率会出现一个线程一直抢占着资源，其他线程一直处于等待状态</p>
<p>调用unlock后，系统还来不及释放资源，就被该线程又给lock锁上了</p>
<hr>
<p>解决方法：在线程执行完毕后使其等待一会</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void ThreadMain(int i){
    for(;;){
        mux.lock();
        std::cout&lt;&lt;i&lt;&lt;"[in]"&lt;&lt;std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(1000));
        mux.unlock();
        std::this_thread::sleep_for(std::chrono::milliseconds(1));
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202303072339137.png" alt="image-20230307233916090"></p>
<h3 id="2-3-超时锁-timed-mutex"><a href="#2-3-超时锁-timed-mutex" class="headerlink" title="2.3 超时锁 timed_mutex"></a>2.3 超时锁 timed_mutex</h3><p>可以记录锁获取情况，多次超时，可以记录日志，获取错误情况</p>
<p>timed_mutex增加了带时限的try_lock，即<strong><em>try_lock_for</em></strong>和<strong><em>try_lock_until</em></strong></p>
<h4 id="try-lock-for"><a href="#try-lock-for" class="headerlink" title="try_lock_for"></a>try_lock_for</h4><p>尝试上锁，如果在规定时间内没能够上锁，则返回false，否则返回true</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;

static std::timed_mutex mutex;

void ThreadMain(int i) {
	if (!mutex.try_lock_for(std::chrono::microseconds(100))) {
		std::cout &lt;&lt; "Thread [" &lt;&lt; i &lt;&lt; "] fail to lock!" &lt;&lt; std::endl;
	}
	else {
		std::cout &lt;&lt; "Thread [" &lt;&lt; i &lt;&lt; "] success!" &lt;&lt; std::endl;
		std::this_thread::sleep_for(std::chrono::microseconds(100));
		mutex.unlock();
	}
}

int main() {
	for (int i = 1; i &lt;= 3; ++i) {
		std::thread th(ThreadMain, i);
		th.detach();
	}
	getchar();
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202303101203317.png" alt="image-20230310120307267"></p>
<h4 id="try-lock-until"><a href="#try-lock-until" class="headerlink" title="try_lock_until"></a>try_lock_until</h4><p>提供一个时间点作为参数，在到达该时间点之前如果仍未能上锁，则返回false，否则返回true</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;

static std::timed_mutex mutex;

void ThreadMain(int i) {
	if (!mutex.try_lock_until(std::chrono::steady_clock::now()+std::chrono::microseconds(100))) {
		std::cout &lt;&lt; "Thread [" &lt;&lt; i &lt;&lt; "] fail to lock!" &lt;&lt; std::endl;
	}
	else {
		std::cout &lt;&lt; "Thread [" &lt;&lt; i &lt;&lt; "] success!" &lt;&lt; std::endl;
		std::this_thread::sleep_for(std::chrono::microseconds(100));
		mutex.unlock();
	}
}

int main() {
	for (int i = 1; i &lt;= 3; ++i) {
		std::thread th(ThreadMain, i);
		th.detach();
	}
	getchar();
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="2-4-递归锁-可重入-recursive-mutex-和-recursive-timed-mutex"><a href="#2-4-递归锁-可重入-recursive-mutex-和-recursive-timed-mutex" class="headerlink" title="2.4 递归锁(可重入) recursive_mutex 和 recursive_timed_mutex"></a>2.4 递归锁(可重入) recursive_mutex 和 recursive_timed_mutex</h3><p>和互斥锁一样，递归锁也是一种锁类型，但递归锁允许同一个线程对同一个锁对象多次上锁，获得多层所有权，避免线程函数递归调用自身产生死锁；当解锁时，unlock函数调用的次数需要与lock函数调用的次数相同，即上多少次锁就应该解锁多少次</p>
<h4 id="recursive-mutex"><a href="#recursive-mutex" class="headerlink" title="recursive_mutex"></a>recursive_mutex</h4><p><strong>recursive_mutex::lock</strong></p>
<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">1、若recursive_mutex对象当前处于未上锁状态，则调用线程会对其上锁
2、若recursive_mutex对象会被其他线程上锁，则调用线程将阻塞，直到该对象被解锁
3、若recursive_mutex对象已经被该调用线程上锁，调用线程再次调用该函数，会获得对该recursive_mutex对象新的所有权级。而完全解锁该recursive_mutex对象需要调用相同次数的unlock函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><strong>recursive_mutex::try_lock</strong></p>
<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">bool try_lock() noexcept;
1、若该对象没有被其他线程上锁，则调用线程对其上锁，并返回true
2、若已被其他线程上锁，则返回false，但不阻塞调用线程
3、若锁住该recursive_mutex对象的线程与调用该函数的线程是同一个线程，则该线程会获得新的所有权级。同样地，需要调用相同次数的unlock函数才能完全解锁<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>recursive_mutex::unlock</strong></p>
<pre class="line-numbers language-none"><code class="language-none">1、解锁，并释放一个所有权级
2、若该对象未被调用线程上锁，调用该函数会导致undefine behavior<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong>示例</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;

static std::recursive_mutex mutex;

void Task1() {
    mutex.lock();
    std::cout &lt;&lt; "Task1" &lt;&lt; std::endl;
    mutex.unlock();
}

void Task2() {
    mutex.lock();
    std::cout &lt;&lt; "Task2" &lt;&lt; std::endl;
    mutex.lock();
}

void ThreadMain(int i) {
    for (;;) {
        mutex.lock();
        //如果不是递归锁，此时则会死锁，没法进入Task1函数
        //普通锁需要先解锁再进入，但此时可能被其他线程乘虚而入
        Task1();
        std::cout &lt;&lt; "Thread[" &lt;&lt; i &lt;&lt; "]" &lt;&lt; std::endl;
        std::this_thread::sleep_for(std::chrono::microseconds(1000));
        Task2();
        mutex.unlock();
        std::this_thread::sleep_for(std::chrono::microseconds(1));
    }
}

int main() {
    for (int i = 0; i &lt; 3; ++i) {
        std::thread th(ThreadMain, i + 1);
        th.detach();
    }
    getchar();
    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="recursive-timed-mutex"><a href="#recursive-timed-mutex" class="headerlink" title="recursive_timed_mutex"></a>recursive_timed_mutex</h4><p>递归定时互斥锁，将recursive_mutex和timed_mutex的功能结合到一个类中，它既支持通过单个线程获取多个锁定级别又支持定时的 try_lock 请求</p>
<h3 id="2-5-共享锁-shared-mutex"><a href="#2-5-共享锁-shared-mutex" class="headerlink" title="2.5 共享锁 shared_mutex"></a>2.5 共享锁 shared_mutex</h3><p>C++14提供了shared_mutex来解决读者—写者问题，也就是读写锁（共享锁），和普通锁不一样，读写锁同时能够拥有一个写者或者多个读者，但是不能同时存在读者和写者</p>
<h4 id="写锁-排他性锁定"><a href="#写锁-排他性锁定" class="headerlink" title="写锁(排他性锁定)"></a>写锁(排他性锁定)</h4><pre class="line-numbers language-none"><code class="language-none">1、lock
2、try_lock
3、unlock<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h4 id="读锁（共享锁定）"><a href="#读锁（共享锁定）" class="headerlink" title="读锁（共享锁定）"></a>读锁（共享锁定）</h4><pre class="line-numbers language-none"><code class="language-none">1、lock_shared
2、try_lock_shared
3、unlock_shared<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="2-6-std-call-once"><a href="#2-6-std-call-once" class="headerlink" title="2.6 std::call_once"></a>2.6 std::call_once</h3><p>在多线程编程中，有时某个函数只需要被执行一次，某些变量只需要初始化一次，此时可以考虑添加锁来控制，而在C++11中，提供了<strong><em>std::call_once</em></strong>函数来解决该问题，<strong><em>std::call_once</em></strong>函数需要配合<strong><em>std::once_flag</em></strong>来实现，也可以解决多线程安全的单例模式</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;mutex&gt;
#include&lt;thread&gt;

std::once_flag flag;

void display() {
	std::cout &lt;&lt; "Hello,World!" &lt;&lt; std::endl;
}

void ThreadOnce() {
	std::call_once(flag, display);
}

int main() {
	std::thread th1(ThreadOnce);
	std::thread th2(ThreadOnce);
	std::thread th3(ThreadOnce);
	th1.join();
	th2.join();
	th3.join();
	getchar();
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202303091013309.png" alt="image-20230309101317218"></p>
<p>可以看到使用了三个线程，但是只打印了一遍   “Hello,World!”</p>
<h2 id="3-利用栈特性自动释放锁-RAII"><a href="#3-利用栈特性自动释放锁-RAII" class="headerlink" title="3 利用栈特性自动释放锁 RAII"></a>3 利用栈特性自动释放锁 RAII</h2><h3 id="3-1-RAII"><a href="#3-1-RAII" class="headerlink" title="3.1 RAII"></a>3.1 RAII</h3><pre class="line-numbers language-none"><code class="language-none">RAII(Resource Acquisition Is Initialization)是C++之父Bjarne Stroustrup提出的使用局部对象来管理资源的技术，称为资源获取即初始化；它的生命周期是由操作系统来管理的，无需人工介入；资源的销毁容易忘记，造成死锁或内存泄漏<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class XMutex {
public:
    XMutex(std::mutex&amp; mux) :mux_(mux) {
        std::cout &lt;&lt; "Lock" &lt;&lt; std::endl;
        mux.lock();
    }
    ~XMutex() {
        std::cout &lt;&lt; "Unlock" &lt;&lt; std::endl;
        mux_.unlock();
    }
private:
    std::mutex&amp; mux_;
};

static std::mutex mux;

void ThreadMain() {
    XMutex lock(mux);

    /*
    线程代码实现
    */
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>你可能会发现，这样写不是变得更麻烦了吗？</strong></p>
<p>其实不然，在你这样定义之后，你就不需再去管锁的释放问题，在一些时候，如果我们进行条件判断语句，需要在中途return，这样我们就需要在每个return，即每个可以退出线程的点之前都要进行一遍unlock，而使用RAII之后，只需要进行一遍上锁，就不需再去管后面的解锁的事了</p>
<p>如下面伪代码：</p>
<pre class="line-numbers language-none"><code class="language-none">void ThreadMain(){
	mutex.lock();
	if(条件一){
		......
		mutex.unlock();
		return;
	}else if(条件二){
		......
		mutex.unlock();
		return;
	}else if
	......
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如上面这种情况，如果改成RAII，就不需要去释放锁，更加方便，不会发生return时忘记释放锁的情况</p>
<h3 id="3-2-C-11-lock-guard"><a href="#3-2-C-11-lock-guard" class="headerlink" title="3.2 C++11 lock_guard"></a>3.2 C++11 lock_guard</h3><p><strong><em>lock_guard</em></strong>是C++11提出的新特性，是一个mutex封装者，使用了上述的RAII机制，在创建时加锁，析构时解锁，类似于智能指针，可以有效防止在线程使用mutex加锁后异常退出导致死锁的问题</p>
<p>使用方法跟上一节相差无几</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;mutex&gt;

std::mutex mux;
//创建时上锁
std::lock_guard&lt;std::mutex&gt; lock(mux);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="std-adopt-lock"><a href="#std-adopt-lock" class="headerlink" title="std::adopt_lock"></a>std::adopt_lock</h4><p><strong><em>lock_guard</em></strong>的第二参数只有<strong><em>std::adopt_lock</em></strong>这一种，表示在锁管理器即<strong><em>lock_guard</em></strong>构造的时候不会对锁对象进行上锁操作，有锁对象自己上锁，等锁管理器析构的时候自动化解锁</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::mutex mux;
{
	mux.lock();
	std::lock_guard&lt;std::mutex&gt; lock(mux,std::adopt_lock);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="3-3-C-11-unique-lock"><a href="#3-3-C-11-unique-lock" class="headerlink" title="3.3 C++11 unique_lock"></a>3.3 C++11 unique_lock</h3><p><strong>独占互斥所有权包装器</strong></p>
<p>C++11还提出了<strong><em>unique_lock</em></strong>的概念，<strong><em>unique_lock</em></strong>要比<strong><em>lock_guard</em></strong>灵活很多，可以手动进行解锁和上锁，因此在其内部会维护一个锁的状态，所以效率会差一点，内存占用也会多一点</p>
<h4 id="std-adopt-lock-1"><a href="#std-adopt-lock-1" class="headerlink" title="std::adopt_lock"></a>std::adopt_lock</h4><p>与<strong><em>lock_guard</em></strong>的<strong><em>std::adopt_lock</em></strong>含义相同</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">_NODISCARD_CTOR unique_lock(_Mutex&amp; _Mtx, adopt_lock_t)
       : _Pmtx(_STD addressof(_Mtx)), _Owns(true) {} // construct and assume already locked<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h4 id="std-try-to-lock"><a href="#std-try-to-lock" class="headerlink" title="std::try_to_lock"></a>std::try_to_lock</h4><p>初始化锁管理器，并尝试对锁进行上锁</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">_NODISCARD_CTOR unique_lock(_Mutex&amp; _Mtx, try_to_lock_t)
        : _Pmtx(_STD addressof(_Mtx)), _Owns(_Pmtx-&gt;try_lock()) {} // construct and try to lock<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h5 id="owns-lock"><a href="#owns-lock" class="headerlink" title="owns_lock"></a>owns_lock</h5><p>返回锁的上锁情况</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">_NODISCARD bool owns_lock() const noexcept {
        return _Owns;
    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>可以与<strong><em>try_to_lock</em></strong>配合使用</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::mutex mux;
std::unique_lock&lt;std::mutex&gt; lock(mux,std::try_to_lock);
if(lock.owns_lock){
    ......
}else{
	......
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="std-defer-lock"><a href="#std-defer-lock" class="headerlink" title="std::defer_lock"></a>std::defer_lock</h4><p>不同于<strong><em>std::adopt_lock</em></strong>和<strong><em>std::try_to_lock</em></strong>：</p>
<ul>
<li>std::adopt_lock在初始化时已经将成员 _Owns 置为true，表示处于上锁状态</li>
<li>std::try_to_lock则会在创建时对锁对象进行尝试上锁</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">unique_lock(_Mutex&amp; _Mtx, defer_lock_t) noexcept
        : _Pmtx(_STD addressof(_Mtx)), _Owns(false) {} // construct but don't lock<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong><em>std::defer_lock</em></strong>参数在初始化锁管理器时不会对锁进行上锁，方便与<strong><em>unique_lock</em></strong>的成员函数进行配合使用</p>
<h4 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h4><p>在观看unique_lock的源码时，发现他还提供了另外两种构造函数：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//传入时间数，使用try_lock_for
_NODISCARD_CTOR unique_lock(_Mutex&amp; _Mtx, const chrono::duration&lt;_Rep, _Period&gt;&amp; _Rel_time)
        : _Pmtx(_STD addressof(_Mtx)), _Owns(_Pmtx-&gt;try_lock_for(_Rel_time)) {} // construct and lock with timeout

//传入时间点，使用try_lock_until
_NODISCARD_CTOR unique_lock(_Mutex&amp; _Mtx, const chrono::time_point&lt;_Clock, _Duration&gt;&amp; _Abs_time)
        : _Pmtx(_STD addressof(_Mtx)), _Owns(_Pmtx-&gt;try_lock_until(_Abs_time)) {
        // construct and lock with timeout<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="lock"><a href="#lock" class="headerlink" title="lock()"></a>lock()</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::mutex mux;
std::unique_lock&lt;std::mutex&gt; lock(mux,std::defer_lock);
lock.lock();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>对锁进行上锁</p>
<h4 id="unlock"><a href="#unlock" class="headerlink" title="unlock()"></a>unlock()</h4><p><strong><em>unique_lock</em></strong>可以使用<strong><em>unlock</em></strong>函数来对锁进行解锁，提前解锁来运行一些不需要共享数据的代码，这可以使我们的代码更加效率和灵活</p>
<h4 id="try-lock-1"><a href="#try-lock-1" class="headerlink" title="try_lock()"></a>try_lock()</h4><p>类似于参数<strong><em>std::try_to_lock</em></strong>，在不阻塞的情况下进行<strong><em>lock</em></strong>，如果加锁成功，那么返回<strong><em>true</em></strong>，如果没有加锁成功，那么返回false</p>
<p><strong><em>unique_lock</em></strong>也有<strong><em>try_lock_for</em></strong>和<strong><em>try_lock_until</em></strong>成员函数</p>
<h4 id="release"><a href="#release" class="headerlink" title="release()"></a>release()</h4><p><strong><em>release()</em></strong>会返回它所管理的<strong><em>mutex</em></strong>对象指针，并释放所有权（也就是说，这个<strong><em>unique_lock</em></strong>和<strong><em>mutex</em></strong>不再有关系）</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">_Mutex* release() noexcept {
        _Mutex* _Res = _Pmtx;
        _Pmtx        = nullptr;
        _Owns        = false;
        return _Res;
    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>需要注意的是：==release的时候，并不会对锁的上锁情况进行改变==，所以需要对锁进行手动解锁</p>
<h4 id="所有权的传递"><a href="#所有权的传递" class="headerlink" title="所有权的传递"></a>所有权的传递</h4><p><strong><em>unique_lock</em></strong>和<strong><em>mutex</em></strong>是绑定在一起的，即<strong><em>unique_lock</em></strong>拥有该<strong><em>mutex</em></strong>的所有权，而这个所有权是可以转移的</p>
<p>==一般一个锁管理器对应一个锁，如果出现一对多或者多对一的情况，容易造成死锁==</p>
<h5 id="move"><a href="#move" class="headerlink" title="move"></a>move</h5><p>通过move来转移所有权</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::mutex mux;
std::unique_lock&lt;std::mutex&gt; lock1(mux,std::defer_lock);
std::unique_lock&lt;std::mutex&gt; lock2(std::move(lock1));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h5 id="return"><a href="#return" class="headerlink" title="return"></a>return</h5><p>通过return来转移</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::mutex mux;
std::unique_lock&lt;std::mutex&gt; lock1(){
	std::unique_lock&lt;std::mutex&gt; lock2(mux);
	return lock2;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="粒度"><a href="#粒度" class="headerlink" title="粒度"></a>粒度</h4><p>为什么我们使用了锁管理器后还要有unlock方法</p>
<p>对于一个程序来所，你lock()锁住的代码越少，执行越快，整个程序的效率就会越高，一般把锁住代码的多少称为<strong><em>锁的粒度</em></strong>，用粗细来描述</p>
<ul>
<li>锁住的代码少，这个粒度叫细，执行效率高</li>
<li>锁住的代码多，这个粒度叫粗，执行效率低</li>
</ul>
<p>在使用锁的时候，应该选择合适的粒度</p>
<h3 id="3-4-C-14-shared-lock"><a href="#3-4-C-14-shared-lock" class="headerlink" title="3.4 C++14 shared_lock"></a>3.4 C++14 shared_lock</h3><p><strong>共享互斥所有权包装器</strong></p>
<p><strong>shared_lock需要与shared_mutex配合使用</strong>，被锁后允许其他线程继续对其进行上锁，但不允许同一个线程在已经上锁的情况下继续上锁</p>
<p>同<strong><em>unqiue_lock</em></strong>一样，同样拥有在<strong><em>unique_lock</em></strong>中提到的五个构造函数，并且与<strong><em>unique_lock</em></strong>一样能进行所有权的转移</p>
<h5 id="常用成员函数"><a href="#常用成员函数" class="headerlink" title="常用成员函数"></a>常用成员函数</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void lock();
bool try_lock();
bool try_lock_for(const chrono::duration&lt;_Rep, _Period&gt;&amp; _Rel_time);
bool try_lock_until(const chrono::time_point&lt;_Clock, _Duration&gt;&amp; _Abs_time)
void unlock();
bool owns_lock();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="3-5-C-17-scoped-lock"><a href="#3-5-C-17-scoped-lock" class="headerlink" title="3.5 C++17 scoped_lock"></a>3.5 C++17 scoped_lock</h3><p><strong>区域锁</strong></p>
<p><strong><em>scoped_lock</em></strong>与<strong><em>lock_guard</em></strong>完全等价，只不过<strong><em>scoped_lock</em></strong>是可变参数模板，可以在构造时一次性接受多个锁进行统一上锁</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::mutex mux1, mux2, mux3;
std::scoped_lock lock1(mux1,mux2,mux3);
//或
std::scoped_lock &lt;std::mutex,std::mutex,std::mutex&gt; lock1(mux1,mux2,mux3);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用了<strong><em>std::lock_guard&lt;&gt;</em></strong>模板，C++17具有隐式类模板参数推导，会自动根据参数进行匹配</p>
<p><strong>源码</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#if _HAS_CXX17
template &lt;class... _Mutexes&gt;
class _NODISCARD scoped_lock { // class with destructor that unlocks mutexes
public:
    explicit scoped_lock(_Mutexes&amp;... _Mtxes) : _MyMutexes(_Mtxes...) { // construct and lock
        _STD lock(_Mtxes...);
    }

    explicit scoped_lock(adopt_lock_t, _Mutexes&amp;... _Mtxes) : _MyMutexes(_Mtxes...) {} // construct but don't lock

    ~scoped_lock() noexcept {
        _STD apply([](_Mutexes&amp;... _Mtxes) { (..., (void) _Mtxes.unlock()); }, _MyMutexes);
    }

    scoped_lock(const scoped_lock&amp;) = delete;
    scoped_lock&amp; operator=(const scoped_lock&amp;) = delete;

private:
    tuple&lt;_Mutexes&amp;...&gt; _MyMutexes;
};

template &lt;class _Mutex&gt;
class _NODISCARD scoped_lock&lt;_Mutex&gt; {
public:
    using mutex_type = _Mutex;

    explicit scoped_lock(_Mutex&amp; _Mtx) : _MyMutex(_Mtx) { // construct and lock
        _MyMutex.lock();
    }

    explicit scoped_lock(adopt_lock_t, _Mutex&amp; _Mtx) : _MyMutex(_Mtx) {} // construct but don't lock

    ~scoped_lock() noexcept {
        _MyMutex.unlock();
    }

    scoped_lock(const scoped_lock&amp;) = delete;
    scoped_lock&amp; operator=(const scoped_lock&amp;) = delete;

private:
    _Mutex&amp; _MyMutex;
};

template &lt;&gt;
class scoped_lock&lt;&gt; {
public:
    explicit scoped_lock() {}
    explicit scoped_lock(adopt_lock_t) {}
    ~scoped_lock() noexcept {}

    scoped_lock(const scoped_lock&amp;) = delete;
    scoped_lock&amp; operator=(const scoped_lock&amp;) = delete;
};
#endif // _HAS_CXX17<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="3-6-condition-variable-条件变量"><a href="#3-6-condition-variable-条件变量" class="headerlink" title="3.6 condition_variable 条件变量"></a>3.6 condition_variable 条件变量</h3><p>互斥量是多线程间同时访问某一个共享变量时候，保证变量可以被<strong><em>安全访问</em></strong>的手段，但是，单靠互斥量是无法保证多个线程间的同步</p>
<p>在生产者消费者模型中，生产者线程将 “消息” 写入到公共队列中，消费者线程则从公共队列中取出 “消息” ，如果只使用互斥量mutex， 我们最容易想到的就是设置一个时间间隔，让消费者线程每过一段时间就去判断公共队列中是否有 “消息” ，如果有就读取，没有就sleep一个时间间隔</p>
<p>而上述方法有一个很大的缺点，你无法来设置一个合适的时间间隔，如果时间间隔太短，就会进行多次无效的查询，减低程序的性能；如果时间间隔太长，就会使用户无法及时收到消息，降低用户的体验</p>
<p>C++11提供了条件变量来解决这种情况，条件变量位于头文件 condition_variable 下</p>
<hr>
<h4 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h4><p>函数原型</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void wait(unique_lock&lt;mutex&gt;&amp; _Lck) { // wait for signal
    // Nothing to do to comply with LWG-2135 because std::mutex lock/unlock are nothrow
    _Cnd_wait(_Mycnd(), _Lck.mutex()-&gt;_Mymtx());
}
template &lt;class _Predicate&gt;
void wait(unique_lock&lt;mutex&gt;&amp; _Lck, _Predicate _Pred) { // wait for signal and test predicate
    while (!_Pred()) {
        wait(_Lck);
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong><em>condition_variable</em></strong>提供了两种wait函数，当前线程调用了<strong><em>wait</em></strong>函数后会被阻塞（<strong>在此之前当前线程应该已经获得锁</strong>），直到另一个线程调用<strong><em>notify</em></strong>函数来唤醒该线程</p>
<p>值得注意的是，在调用完wait函数后，当前线程会先释放锁，使得其他线程得以执行，再将该线程挂起，而在该线程被唤醒时，会尝试重新去获得锁</p>
<p>第二个<strong><em>wait</em></strong>函数，多了一个条件<strong>_pred</strong>（lambda表达式），只有当<strong>_pred</strong>条件为false时，调用<strong>wait</strong>才会挂起当前线程，在被通知唤醒时，只有<strong>_pred</strong>条件为<strong>true</strong>时才会解除阻塞，可以用来解决一些 <strong><em>虚假唤醒</em></strong> 的问题</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//以下两种表达等价

wait(lck,_pred);
//==============
while(_pred){wait(lck);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>另外，<strong><em>condition_variable</em></strong>还提供了 <strong>wait_for</strong> 和 <strong>wait_until</strong> 函数</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class _Rep, class _Period&gt;
    cv_status wait_for(unique_lock&lt;mutex&gt;&amp; _Lck, const chrono::duration&lt;_Rep, _Period&gt;&amp; _Rel_time);

template &lt;class _Rep, class _Period, class _Predicate&gt;
    bool wait_for(unique_lock&lt;mutex&gt;&amp; _Lck, const chrono::duration&lt;_Rep, _Period&gt;&amp; _Rel_time, _Predicate _Pred);
    
template &lt;class _Clock, class _Duration&gt;
    cv_status wait_until(unique_lock&lt;mutex&gt;&amp; _Lck, const chrono::time_point&lt;_Clock, _Duration&gt;&amp; _Abs_time);

template &lt;class _Clock, class _Duration, class _Predicate&gt;
bool wait_until(unique_lock&lt;mutex&gt;&amp; _Lck, const chrono::time_point&lt;_Clock, _Duration&gt;&amp; _Abs_time, _Predicate _Pred);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="notify"><a href="#notify" class="headerlink" title="notify"></a>notify</h4><h5 id="notify-one"><a href="#notify-one" class="headerlink" title="notify_one"></a>notify_one</h5><p>唤醒当前正在等待的某一个线程，如果当前没有线程在等待，则该函数什么都不做</p>
<p><strong>而如果同时存在多个等待线程，则唤醒某一个线程是不确定的</strong></p>
<h5 id="notify-all"><a href="#notify-all" class="headerlink" title="notify_all"></a>notify_all</h5><p>唤醒正在等待的<strong>所有</strong>线程</p>
<h4 id="示例-生产者消费者"><a href="#示例-生产者消费者" class="headerlink" title="示例-生产者消费者"></a>示例-生产者消费者</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;condition_variable&gt;
#include&lt;mutex&gt;
#include&lt;iostream&gt;
#include&lt;thread&gt;
#include&lt;deque&gt;
#include&lt;string&gt;

std::condition_variable cv; //条件变量
std::mutex mux; //全局互斥锁
std::deque&lt;int&gt; dq; //消息队列

//生产者
void producer() {
	int i = 0;
	while (true) {
		std::unique_lock&lt;std::mutex&gt;lock(mux); 
		dq.push_back(i);
		cv.notify_one();//唤醒消费者线程
		++i;
	}
}

//消费者
void consumer() {
	int data;
	while (true) {
		std::unique_lock&lt;std::mutex&gt;lock(mux);
		if (dq.empty()) cv.wait(lock); //进入等待
		data = dq.front();
		dq.pop_front();
		//打印消息
		std::cout &lt;&lt; "Get Value: " &lt;&lt; data &lt;&lt; std::endl;
	}
}

int main() {
	std::thread th1(consumer);
	std::thread th2(producer);

	th1.join();
	th2.join();

	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/image-20230402220515173.png" alt="image-20230402220515173"></p>
<h4 id="虚假唤醒"><a href="#虚假唤醒" class="headerlink" title="虚假唤醒"></a>虚假唤醒</h4><p>对于生产者-消费者模型来说，如果我们有两个消费者来接收生产者的消息，如下程序所示</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;condition_variable&gt;
#include&lt;mutex&gt;
#include&lt;iostream&gt;
#include&lt;thread&gt;
#include&lt;deque&gt;
#include&lt;string&gt;

std::condition_variable cv; //条件变量
std::mutex mux; //全局互斥锁
std::deque&lt;int&gt; dq; //消息队列

//生产者
void producer() {
	int i = 0;
	while (true) {
		std::unique_lock&lt;std::mutex&gt;lock(mux); 
		dq.push_back(i);
		cv.notify_one();//唤醒消费者线程
		++i;
	}
}

//消费者
void consumer(int index) {
	int data;
	while (true) {
		std::unique_lock&lt;std::mutex&gt;lock(mux);
		if (dq.empty()) cv.wait(lock); //进入等待
		data = dq.front();
		dq.pop_front();
		//打印消息
		std::cout &lt;&lt; "Consumer " &lt;&lt; index &lt;&lt; " Get Value: " &lt;&lt; data &lt;&lt; std::endl;
	}
}

int main() {
	std::thread th1(consumer,1);//消费者1
	std::thread th2(consumer,2);//消费者2
	std::thread th3(producer);//生产者

	th1.join();
	th2.join();
	th3.join();

	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="C:\Users\lvxr\AppData\Roaming\Typora\typora-user-images\image-20230406170429481.png" alt="image-20230406170429481"></p>
<p>为什么会出现这种原因？可以注意到提示是从一个空的deque中去取值</p>
<p>分析可得，</p>
<ul>
<li>生产者生产一条消息</li>
<li>生产者唤醒消费者1</li>
<li>消费者1尝试获得锁失败，生产者再次获得锁</li>
<li>生产者再提供一条消息</li>
<li>生产者唤醒消费者2</li>
<li>消费者1连续获得两次锁，打印两条消息</li>
<li>消费者2获得锁，此时队列中没有消息，程序错误</li>
</ul>
<p>这就是利用<strong>if包裹的wait函数</strong>产生的虚假唤醒问题，改用<strong>while包裹或者使用第二种wait函数</strong>可以有效解决该问题</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;condition_variable&gt;
#include&lt;mutex&gt;
#include&lt;iostream&gt;
#include&lt;thread&gt;
#include&lt;deque&gt;
#include&lt;string&gt;

std::condition_variable cv; //条件变量
std::mutex mux; //全局互斥锁
std::deque&lt;int&gt; dq; //消息队列

//生产者
void producer() {
	int i = 0;
	while (true) {
		std::unique_lock&lt;std::mutex&gt;lock(mux); 
		dq.push_back(i);
		cv.notify_all();//唤醒消费者线程
		++i;
	}
}

//消费者
void consumer(int index) {
	int data;
	while (true) {
		std::unique_lock&lt;std::mutex&gt;lock(mux);
		cv.wait(lock, [=]() {return !dq.empty(); });//进入等待
		data = dq.front();
		dq.pop_front();
		//打印消息
		std::cout &lt;&lt; "Consumer " &lt;&lt; index &lt;&lt; " Get Value: " &lt;&lt; data &lt;&lt; std::endl;
	}
}

int main() {
	std::thread th1(consumer,1);//消费者1
	std::thread th2(consumer,2);//消费者2
	std::thread th3(producer);//生产者

	th1.join();
	th2.join();
	th3.join();

	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/image-20230406171909775.png" alt="image-20230406171909775"></p>
<p>如果是一次性的生产，即生产者只通知一次，需保证消费者先执行，否则可能生产者通知了，消费者还未执行到wait语句</p>
<h2 id="4-线程的异步和通信"><a href="#4-线程的异步和通信" class="headerlink" title="4 线程的异步和通信"></a>4 线程的异步和通信</h2><h3 id="4-1-promise-和-future"><a href="#4-1-promise-和-future" class="headerlink" title="4.1 promise 和 future"></a>4.1 promise 和 future</h3><p><strong><em>promise</em></strong>和<strong><em>future</em></strong>的作用是在不同线程之间传递数据，使用指针也可以完成数据的传递，但是指针非常危险，因为斥量不能阻止指针的访问，而且指针的方式传递的数据是固定的，如果更改数据类型，那么还需要更改有关的接口，比较麻烦；promise支持泛型的操作，更加方便编程处理</p>
<hr>
<p><strong><em>promise</em></strong>和<strong><em>future</em></strong>是一种单向的数据传递，promise是数据的输入端，future是数据的输入端</p>
<hr>
<p>在使用时，先创建一个promise对象，从promise对象调用get_future得到future对象，将promise对象或future对像作为线程参数传给另一个线程，这样future对象可以通过get函数来获得promise对象设定得值，如果使用get时promise对象还未设定值，则future会阻塞该线程直到获得值</p>
<blockquote id="fn_注">
<sup>注</sup>. future和promise对象不能够拷贝，所以要使用std::move/std::ref<a href="#reffn_注" title="Jump back to footnote [注] in the text."> ↩</a>
</blockquote>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;

void TestThread(std::promise&lt;int&gt;&amp; promiseobj) {
	std::this_thread::sleep_for(std::chrono::milliseconds(1000));
	std::cout &lt;&lt; "IN TestThread" &lt;&lt; std::endl;
	std::this_thread::sleep_for(std::chrono::milliseconds(1000));
	std::cout &lt;&lt; "Set Value" &lt;&lt; std::endl;
	promiseobj.set_value(101);
	std::this_thread::sleep_for(std::chrono::milliseconds(1000));
	std::cout &lt;&lt; "Out TestThread" &lt;&lt; std::endl;
}

int main() {
	std::promise&lt;int&gt; promiseobj;
	std::future&lt;int&gt; futureobj = promiseobj.get_future();
	std::thread th(TestThread, std::ref(promiseobj));
	std::cout &lt;&lt; "Get Value" &lt;&lt; std::endl;
	std::cout &lt;&lt; futureobj.get() &lt;&lt; std::endl;
	th.join();
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/image-20230407141410301.png" alt="image-20230407141410301"></p>
<h3 id="4-2-packaged-task异步调用函数打包"><a href="#4-2-packaged-task异步调用函数打包" class="headerlink" title="4.2 packaged_task异步调用函数打包"></a>4.2 packaged_task异步调用函数打包</h3><p><strong><em>packaged_task</em></strong>和<strong><em>promise</em></strong>十分相似，packaged_task封装了可调用实体（即函数，lambda函数或函数对象）</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">std::packaged_task&lt;F&gt; 
//类似于
std::promise&lt;T= std::function&lt;F&gt;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;future&gt;
#include &lt;thread&gt;

int Test(int a, int b) {
	std::cout &lt;&lt; "START" &lt;&lt; std::endl;
	std::this_thread::sleep_for(std::chrono::milliseconds(1000));
	return a + b;
}

int main() {
	std::packaged_task&lt;int(int, int)&gt; pt(Test);
	std::future&lt;int&gt; futureobj = pt.get_future();
	std::thread th1(std::move(pt), 1, 2);
    //packaged_task也禁用了拷贝函数，所以要使用std::move
	std::this_thread::sleep_for(std::chrono::milliseconds(100));
	std::cout &lt;&lt; "GET VALUE = " &lt;&lt; futureobj.get() &lt;&lt; std::endl;
	th1.join();
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/image-20230407144323255.png" alt="image-20230407144323255"></p>
<h4 id="std-packaged-task-valid"><a href="#std-packaged-task-valid" class="headerlink" title="std::packaged_task::valid"></a>std::packaged_task::valid</h4><p>该函数用于判断std::packaged_task对象是否是有效状态。当通过缺省构造初始化时，由于其未设置任何可调用对象或函数，valid会返回false。只有当std::packaged_task设置了有效的函数或可调用对象，valid才返回true</p>
<h4 id="std-packaged-task-swap"><a href="#std-packaged-task-swap" class="headerlink" title="std::packaged_task::swap"></a>std::packaged_task::swap</h4><p>将两个<code>std::packaged_task</code>对象所关联的共享状态和存储任务的所有权进行交换</p>
<h3 id="4-3-async"><a href="#4-3-async" class="headerlink" title="4.3 async"></a>4.3 async</h3><p><strong><em>std::async</em></strong>是一个接受回调（函数/函数对象）作为参数的函数模板，并且<strong><em>有可能异步</em></strong>执行该函数，返回一个future对象</p>
<h4 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class _Fty, class... _ArgTypes&gt;
_NODISCARD future&lt;_Invoke_result_t&lt;decay_t&lt;_Fty&gt;, decay_t&lt;_ArgTypes&gt;...&gt;&gt; async(
    launch _Policy, _Fty&amp;&amp; _Fnarg, _ArgTypes&amp;&amp;... _Args) {
    // manages a callable object launched with supplied policy
    using _Ret   = _Invoke_result_t&lt;decay_t&lt;_Fty&gt;, decay_t&lt;_ArgTypes&gt;...&gt;;
    using _Ptype = typename _P_arg_type&lt;_Ret&gt;::type;
    _Promise&lt;_Ptype&gt; _Pr(
        _Get_associated_state&lt;_Ret&gt;(_Policy, _Fake_no_copy_callable_adapter&lt;_Fty, _ArgTypes...&gt;(
                                                 _STD forward&lt;_Fty&gt;(_Fnarg), _STD forward&lt;_ArgTypes&gt;(_Args)...)));

    return future&lt;_Ret&gt;(_Pr._Get_state_for_future(), _Nil());
}

template &lt;class _Fty, class... _ArgTypes&gt;
_NODISCARD future&lt;_Invoke_result_t&lt;decay_t&lt;_Fty&gt;, decay_t&lt;_ArgTypes&gt;...&gt;&gt; async(_Fty&amp;&amp; _Fnarg, _ArgTypes&amp;&amp;... _Args) {
    // manages a callable object launched with default policy
    return _STD async(launch::async | launch::deferred, _STD forward&lt;_Fty&gt;(_Fnarg), _STD forward&lt;_ArgTypes&gt;(_Args)...);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到第一个提供三个参数，第一个为std::launch中的两个标志位：</p>
<ul>
<li>launch::async：创建异步线程并绑定future对象，一定会创建线程</li>
<li>launch::deferred：延时绑定，等待future对象调用get函数时才开始同步执行，不创建线程，属于同步任务</li>
<li>launch::async|launch::deferred：默认值，可以异步执行或者不异步，取决于系统的负载，即系统资源不够创建一个新线程时，那么就创建一个同步任务（deferred）</li>
</ul>
<h4 id="示例-async"><a href="#示例-async" class="headerlink" title="示例-async"></a>示例-async</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;thread&gt;
#include &lt;iostream&gt;
#include &lt;future&gt;


int Test()
{
	std::cout &lt;&lt; "START,THREAD ID IS " &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
	return 1;
}

int main()
{
	std::cout &lt;&lt; "MAIN THREAD ID IS " &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
	std::this_thread::sleep_for(std::chrono::microseconds(1000));
	std::future&lt;int&gt; result = std::async(std::launch::async, Test);
	//异步执行，一定会创建线程
	int res = result.get();
	std::cout &lt;&lt; res &lt;&lt; std::endl;
	return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/image-20230407152252132.png" alt="image-20230407152252132"></p>
<h4 id="示例-deferred"><a href="#示例-deferred" class="headerlink" title="示例-deferred"></a>示例-deferred</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;thread&gt;
#include &lt;iostream&gt;
#include &lt;future&gt;


int Test()
{
	std::cout &lt;&lt; "START,THREAD ID IS " &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
	return 1;
}

int main()
{
	std::future&lt;int&gt; result = std::async(std::launch::deferred, Test);
	//延时调用，不创建线程
	std::this_thread::sleep_for(std::chrono::microseconds(1000));
	//可以看到改行将先输出
	std::cout &lt;&lt; "MAIN THREAD ID IS " &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
	int res = result.get();
	std::cout &lt;&lt; res &lt;&lt; std::endl;
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/image-20230407152502311.png" alt="image-20230407152502311"></p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统—第四章—文件系统基础</title>
    <url>/2023/09/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E7%AC%AC%E5%9B%9B%E7%AB%A0%E2%80%94%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1 id="4-1-文件系统基础"><a href="#4-1-文件系统基础" class="headerlink" title="4.1 文件系统基础"></a>4.1 文件系统基础</h1><h3 id="4-1-1文件的基本概念"><a href="#4-1-1文件的基本概念" class="headerlink" title="4.1.1文件的基本概念"></a>4.1.1文件的基本概念</h3><ul>
<li>文件是以硬盘为载体的存储再计算机上的信息集合</li>
<li>文件的结构（自底向上）<ul>
<li>数据项——文件系统中最低级的数据组织形式<ul>
<li>基本数据项——用于描述一个对象的某种属性的一个值，是数据中的最小逻辑单位</li>
<li>组合数据项——由多个基本数据项组成</li>
</ul>
</li>
<li>记录——用一组相关的数据项的集合，用于描述一个对象在某方面的属性</li>
<li>文件——是指由创建者所定义的、具有文件名的一组相关元素的集合<ul>
<li>有结构文件——文件由若干个相似的记录组成</li>
<li>无结构文件——被视为一个字符流</li>
</ul>
</li>
</ul>
</li>
</ul>
<span id="more"></span>
<h3 id="4-1-2文件控制块和索引节点"><a href="#4-1-2文件控制块和索引节点" class="headerlink" title="4.1.2文件控制块和索引节点"></a>4.1.2文件控制块和索引节点</h3><p><strong>文件的属性</strong></p>
<ul>
<li>名称——文件名称唯一，以容易读取的形式保存</li>
<li>类型——被支持不同类型的文件系统所使用</li>
<li>创建者——文件创建者的ID</li>
<li>所有者——文件当前所有者的ID</li>
<li>位置——指向设备和设备上文件的指针</li>
<li>大小——文件当前大小（用字节、字或块表示），也可包含文件允许的最大值</li>
<li>保护——对文件进行保护的访问控制信息。</li>
<li>创建时间、最后一次修改时间和最后一次存取时间——文件创建、上次修改和上次访问的相关信息，用户保护和追踪文件的使用</li>
</ul>
<p><strong>文件控制块FCB</strong></p>
<ul>
<li>包含<ul>
<li>基本信息，如文件名、文件的物理位置、文件的逻辑结构、文件的物理结构等</li>
<li>存取控制信息，包括文件主的存取权限、核准用户的存取权限以及一般用户的存取权限</li>
<li>使用信息，如文件建立时间、上次修改时间等</li>
</ul>
</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309072118880.png" alt="image-20230907211855809"></li>
</ul>
<p><strong>索引节点</strong></p>
<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309072122718.png" alt="image-20230907212252695"></li>
<li>在检索目录的过程中，只用到了文件名，仅当找到一个目录项（其中的文件名与要查找的文件名匹配）时，才需从该目录项中读出该文件的物理地址。也就是说，在检索目录时，文件的其他描述信息不会用到，也不需要调入内存</li>
<li>采用文件名和文件描述信息分开的方法，使文件描述信息单独形成一个称为索引结点的数据结构，简称 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewBox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container> 结点（inode)在文件目录中的每个目录项仅由文件名和指向该文件所对应的i结点的指针构成</li>
<li>有何用处<ul>
<li>假设一个FCB为64 B，盘块大小是1 KB</li>
<li>则每个盘块中可以存放16个FCB（FCB必须连续存放），若一个文件目录共有640个FCB，则查找文件平均需要启动磁盘20次</li>
<li>而在UNIX系统中，一个目录项仅占16 B，其中14 B是文件名，2 B是i结点指针。在1 KB的盘块中可存放64个目录项。这样，可使查找文件的平均启动磁盘次数减少到原来的1/4，大大节省了系统开销</li>
</ul>
</li>
<li>磁盘索引节点——存放在磁盘<ul>
<li>文件主标识符——拥有该文件的小人/小组的标识符</li>
<li>文件类型——包括普通文件、目录文件或特别文件</li>
<li>文件存取权限——各类用户对该文件的存取权限</li>
<li>文件物理地址——每个索引结点中含有13个地址项，即i.addr(0)～i.addr(12)，它们以直接或间接方式给出数据文件所在盘块的编号</li>
<li>文件长度——指以字节为单位的文件长度</li>
<li>文件链接计数——在本文件系统中所有指向该文件的文件名的指针计数</li>
<li>文件存取时间——本文件最近被进程存取的时间、最近被修改的时间及索引结点最近被修改的时间</li>
</ul>
</li>
<li>内存索引节点——文件打开后要将磁盘索引节点复制到内存中——新增内容<ul>
<li>索引结点编号——用于标识内存索引结点</li>
<li>状态——指示i结点是否上锁或被修改</li>
<li>访问计数——每当有一进程要访问此i结点时，计数加1；访问结束减1</li>
<li>逻辑设备号——文件所属文件系统的逻辑设备号</li>
<li>链接指针——设置分别指向空闲链表和散列队列的指针</li>
</ul>
</li>
</ul>
<h3 id="4-1-3文件的操作"><a href="#4-1-3文件的操作" class="headerlink" title="4.1.3文件的操作"></a>4.1.3文件的操作</h3><p><strong>文件的基本操作</strong></p>
<ul>
<li>创建文件（Create）<ol>
<li>为新文件分配必要的外存空间</li>
<li>在目录中为之创建一个目录项，目录项记录了新文件名、在外存中的地址及其他可能的信息</li>
</ol>
</li>
<li>写文件（Write）<ul>
<li>维护一个写位置的指针，每当发生写操作时就更新指针</li>
</ul>
</li>
<li>读文件（Read）<ul>
<li>维护一个读位置的指针，每当发生读操作时就更新指针</li>
<li>读和写使用同一个指针</li>
</ul>
</li>
<li>重新定位文件<ul>
<li>也称文件定位</li>
<li>搜索目录以找到适合的条目，并将当前文件位置指针重新定位到给定值</li>
<li>不涉及读、写文件</li>
</ul>
</li>
<li>删除文件（Delete)<ol>
<li>从目录中检索指定文件名的目录项</li>
<li>释放该文件所占的存储空间</li>
<li>删除目录条目</li>
</ol>
</li>
<li>截断文件<ul>
<li>允许文件所有属性不变，并删除文件内容，将其长度置为0并释放空间</li>
</ul>
</li>
</ul>
<p><strong>文件的打开与关闭</strong></p>
<ul>
<li>打开文件（Open）<ul>
<li>过程<ol>
<li>从目录中找到文件名对应的目录项，并检查该用户是否有指定的操作权限</li>
<li>将目录项复制到内存中的“打开文件表”中，并将对应表目的编号返回给用户，之后用户使用打开文件表的编号来指明要操作的文件</li>
</ol>
</li>
</ul>
</li>
<li>关闭文件<ul>
<li>过程<ol>
<li>将进程的打开文件表相应表项删除</li>
<li>回收分配给该文件的内存空间等资源</li>
<li>系统打开文件表的打开计数器count 减1，若 count = 0，则删除对应表项</li>
</ol>
</li>
</ul>
</li>
<li>打开文件表<ul>
<li>系统表<ul>
<li>包含FCB的副本和其他信息</li>
<li>系统打开文件表为每个文件关联一个打开计数器(Open Count），以记录多少进程打开了该文件。每个关闭操作close使count递减，当打开计数器为0时，表示该文件不再被使用，并且可从系统打开文件表中删除相应条目</li>
</ul>
</li>
<li>进程表<ul>
<li>根据它打开的所有文件，包含指向系统表中适当条目的指针</li>
<li>一旦有进程打开了一个文件，系统表就包含该文件的条目。当另一个进程执行调用open时，只不过是在其文件打开表中增加一个条目，并指向系统表的相应条目</li>
</ul>
</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309072005290.png" alt="image-20230907200540327"></li>
</ul>
</li>
</ul>
<h3 id="4-1-4文件保护"><a href="#4-1-4文件保护" class="headerlink" title="4.1.4文件保护"></a>4.1.4文件保护</h3><ul>
<li>文件保护通过口令保护、加密保护和访问控制等方式实现。其中，口令和加密是为了防止用户文件被他人存取或窃取，而访问控制则用于控制用户对文件的访问方式</li>
<li>口令保护<ul>
<li>为文件设置一个“口令”（如：abc112233），用户请求访问该文件时必须提供“口令”</li>
<li>优点：保存口令的空间开销不多，验证口令的时间开销也很小</li>
<li>缺点：正确的“口令”存放在系统内部，不够安全</li>
</ul>
</li>
<li>加密保护<ul>
<li>使用某个“密码”对文件进行加密，在访问文件时需要提供正确的“密码”才能对文件进行正确的解密</li>
<li>异或加密<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309072102374.png" alt="image-20230907210231486"></li>
<li>优点：保密性强，不需要在系统内部存储”密码“</li>
<li>缺点：编码/译码（加密/解密）需要一定时间</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>访问类型</strong></p>
<ul>
<li>读——从文件中读</li>
<li>写——向文件中写</li>
<li>执行——将文件装入内存并执行</li>
<li>添加——将新信息添加到文件结尾部分</li>
<li>删除——删除文件，释放空间</li>
<li>列表清单——列出文件名和文件属性</li>
</ul>
<p><strong>访问控制</strong></p>
<ul>
<li>访问控制列表ACL（每个文件一个）<ul>
<li>根据用户身份进行控制</li>
<li>用户类型（精简版）<ul>
<li>拥有者——创建文件的用户</li>
<li>组——一组需要共享文件且具有类似访问的用户</li>
<li>其他——其他所有用户</li>
</ul>
</li>
</ul>
</li>
<li>用户访问该文件时，若用户是文件主，按照文件主所拥有的权限访问文件；若用户和文件主在同一个用户组，则按照同组权限访问，否则只能按其他用户权限访问。</li>
</ul>
<h3 id="4-1-5文件的逻辑结构"><a href="#4-1-5文件的逻辑结构" class="headerlink" title="4.1.5文件的逻辑结构"></a>4.1.5文件的逻辑结构</h3><ul>
<li>按逻辑结构，文件可划分为无结构文件和有结构文件</li>
</ul>
<p><strong>无结构文件（流式文件）</strong></p>
<ul>
<li>无结构文件是最简单的文件组织形式</li>
<li>以字节为单位</li>
<li>管理简单，用户可以方便地对其进行操作</li>
</ul>
<p><strong>有结构文件</strong></p>
<ul>
<li>由一组相似的记录组成，又称“记录式文件”。每条记录又若干个数据项组成。如：数据库表文件。一般来说，每条记录有一个数据项可作为关键字</li>
<li>顺序文件<ul>
<li>文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的（通常）或可变长的。各个记录在物理上可以顺序存储或链式存储</li>
<li>串结构<ul>
<li>记录之间的顺序与关键字无关</li>
<li>必须从头开始顺序一次查找</li>
</ul>
</li>
<li>顺序结构<ul>
<li>文件中的所有记录按关键字顺序排列</li>
<li>可采用折半查找，提高检索效率</li>
</ul>
</li>
<li>每次要读或写一大批记录时，顺序文件的效率是所有逻辑文件中最高的</li>
<li>在经常需要查找、修改、增加或删除单个记录的场合，顺序文件的性能比较差</li>
<li>总结<ul>
<li>链式存储<ul>
<li>无法实现随机存取</li>
</ul>
</li>
<li>顺序存储<ul>
<li>可变长记录<ul>
<li>无法实现随机存取</li>
</ul>
</li>
<li>定长记录<ul>
<li>可实现随机存取</li>
<li>若采用串结构，无法快速找到某关键字对应的记录</li>
<li>采用顺序结构，可以快速找到某关键字对应的记录</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>索引文件<ul>
<li>可以建立一张索引表，为主文件的每个记录在索引表中分别设置一个表项，包含指向变长记录的指针（即逻辑起始地址）和记录长度，索引表按关键字排序，因此其本身也是一个定长记录的顺序文件。这样就把对变长记录顺序文件的检索转变为对定长记录索引文件的随机检索，从而加快了记录的检索速度</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309071923970.png" alt="image-20230907192350869"></li>
</ul>
</li>
<li>索引顺序文件<ul>
<li>索引顺序文件是顺序文件和索引文件的结合</li>
<li>索引顺序文件将顺序文件中的所有记录分为若干组，为顺序文件建立一张索引表，在索引表中为每组中的第一条记录建立一个索引项，其中包含该记录的关键字值和指向该记录的指针</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309071928068.png" alt="image-20230907192840027"></li>
<li>效率<ul>
<li>对于N个记录的文件的平均查找次数<ul>
<li>顺序文件——<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.271ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 1888 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(888,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path></g></g><g data-mml-node="mn" transform="translate(1388,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></svg></mjx-container>次</li>
<li>索引顺序<ul>
<li>一级——<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="4.719ex" height="2.021ex" role="img" focusable="false" viewBox="0 -893.3 2085.9 893.3"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="TeXAtom" transform="translate(975.3,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(500,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path></g></g><g data-mml-node="mn" transform="translate(1000,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></g></g></svg></mjx-container>次</li>
<li>二级——<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="4.719ex" height="2.021ex" role="img" focusable="false" viewBox="0 -893.3 2085.9 893.3"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="TeXAtom" transform="translate(975.3,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(500,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path></g></g><g data-mml-node="mn" transform="translate(1000,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g></g></g></g></g></svg></mjx-container>次</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>索引文件和索引顺序文件都提高了存取的速度，但因为配置索引表而增加了存储空间</li>
</ul>
</li>
<li>直接文件或散列文件<ul>
<li>给定记录的键值或通过散列函数转换的键值直接决定记录的物理地址</li>
<li>散列文件有很高的存取速度，但是会引起冲突</li>
</ul>
</li>
</ul>
<h3 id="4-1-6文件的物理结构"><a href="#4-1-6文件的物理结构" class="headerlink" title="4.1.6文件的物理结构"></a>4.1.6文件的物理结构</h3><ul>
<li>很多操作系统中，磁盘块的大小与内存块、页面的大小相同</li>
</ul>
<p><strong>连续分配</strong></p>
<ul>
<li>连续分配方法要求每个文件在磁盘上占有一组连续的块</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309072012731.png" alt="image-20230907201210731"></li>
<li>优点<ul>
<li>支持顺序访问和直接访问</li>
<li>实现简单、存取速度快</li>
</ul>
</li>
<li>缺点<ul>
<li>文件长度不宜动态增加，因为一个文件末尾后的盘块可能已分配给其他文件，一旦需要增加，就需要大量移动盘块</li>
<li>为保持文件的有序性，删除和插入记录时，需要对相邻的记录做物理上的移动，还会动态改变文件的长度</li>
<li>反复增删文件后会产生外部碎片</li>
<li>很难确定一个文件需要的空间大小，因而只适用于长度固定的文件</li>
</ul>
</li>
</ul>
<p><strong>链接分配</strong></p>
<ul>
<li>链接分配是采用离散分配的方式</li>
<li>隐式链接<ul>
<li>目录项中含有文件第一块的指针和最后一块的指针</li>
<li>每个文件对应一个磁盘块的链表</li>
<li>除最后一个盘块外，每个盘块都含有指向文件下一个盘块的指针，这些指针对用户透明</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309072019910.png" alt="image-20230907201932754"></li>
<li>优点<ul>
<li>很方便文件拓展，不会有碎片问题，外存利用率高</li>
</ul>
</li>
<li>缺点<ul>
<li>只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间</li>
<li>稳定性——系统在运行过程中由于软件或硬件错误导致链表中的指针丢失或损坏，会导致文件数据的丢失</li>
</ul>
</li>
<li>解决方案——簇（cluster）<ul>
<li>将几个盘块组成簇，按簇而不按块来分配</li>
<li>增加了内部碎片</li>
<li>改善了许多算法的磁盘访问时间</li>
<li>应用于大多数系统</li>
</ul>
</li>
</ul>
</li>
<li>显示连接<ul>
<li>把用于链接文件各物理块的指针，从每个物理块的末尾中提取出来，显示地存放在内存的一张链接表中，该表在整个磁盘中仅设置一张，称为文件分配表（FAT）</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309072031928.png" alt="image-20230907203124986"></li>
<li>优点<ul>
<li>FAT表常驻内存，因此显著提高了检索速度（查找记录在内存中进行），减少了访问磁盘的次数</li>
<li>支持顺序访问和随机访问</li>
<li>不会产生外部碎片，文件拓展方便</li>
</ul>
</li>
<li>缺点<ul>
<li>文件分配表占用一定的存储空间</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>索引分配</strong></p>
<ul>
<li>索引分配允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表中记录了文件的各个逻辑块对应的物理块。索引表存放的磁盘块称为索引块。文件数据存放的磁盘块称为数据块。</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309072038470.png" alt="image-20230907203846597"></li>
<li>优点——支持直接（随机）访问，没有外部碎片问题</li>
<li>缺点——由于索引块的分配，增加了存储空间的开销</li>
<li>解决方法——索引块应尽可能小，但太小无法支持大文件——索引表太大，一块索引块装不下<ul>
<li>链接方案<ul>
<li>将多个索引表连接起来</li>
<li>低效</li>
</ul>
</li>
<li>多层索引<ul>
<li>建立多层索引（原理类似于多级页表）。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块</li>
<li>各层索引表大小不能超过一个磁盘块</li>
</ul>
</li>
<li>混合索引<ul>
<li>将多种索引分配方式相结合的分配方式</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>混合索引分配</strong></p>
<ul>
<li>全面照顾到小型、中型、大型文件<ul>
<li>其他方案如果是小型文件也需要占用多块物理块，且访问慢，需要多次寻址</li>
</ul>
</li>
<li>小文件——直接获得盘块地址（直接寻址）——提高访问速度</li>
<li>中型文件——单级索引</li>
<li>大型文件——多级索引</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309072048217.png" alt="image-20230907204811129"><ul>
<li>假设每个盘块4KB </li>
<li>直接块——4KB*10——i.addr(0)→i.addr(9)</li>
<li>一级间址——4MB——i.addr(10)</li>
<li>二级间址——4GB——i.addr(11)</li>
<li>三级间址——4TB——i.addr(12)</li>
</ul>
</li>
</ul>
<h1 id="4-2目录"><a href="#4-2目录" class="headerlink" title="4.2目录"></a>4.2目录</h1><h3 id="4-2-1-目录的基本概念"><a href="#4-2-1-目录的基本概念" class="headerlink" title="4.2.1 目录的基本概念"></a>4.2.1 目录的基本概念</h3><ul>
<li>FCB的有序集合称为文件目录</li>
</ul>
<h3 id="4-2-2-目录结构"><a href="#4-2-2-目录结构" class="headerlink" title="4.2.2 目录结构"></a>4.2.2 目录结构</h3><p><strong>单级目录结构</strong></p>
<ul>
<li>整个文件系统中只建立一张目录表，每个文件占一个目录项</li>
<li>建立一个新文件时，必须先检索所有目录项，以确保没有“重名”的情况，然后在该目录中增设一项，把新文件的属性信息填入到该项中</li>
<li>单级目录结构实现了“按名存取”，但是存在查找速度慢、文件不允许重名、不便于文件共享等缺点，而且对于多用户的操作系统显然是不适用的</li>
</ul>
<p><strong>两级目录结构</strong></p>
<ul>
<li>将文件目录分为主文件目录和用户文件目录</li>
<li>主文件目录项记录用户名及相应用户文件目录所在的存储位置</li>
<li>用户文件目录项记录该用户文件的不同FCB信息</li>
<li>提高了检索的速度，解决了多用户之间的文件重名问题，文件系统可以在目录上实现访问限制，但是缺乏灵活性，不能对文件分类</li>
</ul>
<p><strong>树形目录结构</strong></p>
<ul>
<li>绝对路径——从根目录出发的路径</li>
<li>相对路径——从当前目录出发</li>
<li>当前目录——解决了每次都从根目录开始查找的低效问题</li>
<li>优点——可以很方便地对文件进行分类，层次结构清晰，也能有效地进行文件的管理和保护</li>
<li>缺点——访问需要逐级访问中间节点，增加了磁盘访问次数；不便于实现文件共享</li>
<li>Windows、UNIX、Linux</li>
</ul>
<p><strong>无环图目录结构</strong></p>
<ul>
<li>可以用不同的文件名指向同一个文件</li>
<li>为每一个共享节点设置一个共享计数器<ul>
<li>增加对该节点的共享链时，计数器加一，删除节点时，计数器减一</li>
<li>计数器为0时才真正删除节点</li>
</ul>
</li>
<li>在共享文件中，各用户指向的是同一个文件，只要有一个用户修改了文件，所有用户都可以看到数据的变化</li>
<li>方便地实现了文件的共享，但使得系统的管理变得复杂</li>
</ul>
<h3 id="4-2-3目录的操作"><a href="#4-2-3目录的操作" class="headerlink" title="4.2.3目录的操作"></a>4.2.3目录的操作</h3><ul>
<li>搜索——当用户使用一个文件时，需要搜索目录，以找到该文件的对应目录项</li>
<li>创建文件——当创建一个新文件时，需要在目录中增加一个目录项</li>
<li>删除文件——当删除一个文件时，需要在目录中删除相应的目录项</li>
<li>创建目录——在树形目录结构中，用户可创建自己的用户文件目录，并可再创建子目录</li>
<li>删除目录——有两种方式<ul>
<li>不删除非空目录，删除时要先删除目录中的所有文件，并递归地删除子目录</li>
<li>可删除非空目录，目录中的文件和子目录同时被删除</li>
</ul>
</li>
<li>移动目录——将文件或子目录在不同的父目录之间移动，文件的路径名也会随之改变</li>
<li>显示目录——用户可以请求显示目录的内容，如显示该用户目录中的所有文件及属性</li>
<li>修改目录——某些文件属性保存在目录中，因而这些属性的变化需要改变相应的目录项</li>
</ul>
<h3 id="4-2-4目录的实现"><a href="#4-2-4目录的实现" class="headerlink" title="*4.2.4目录的实现"></a>*4.2.4目录的实现</h3><ul>
<li>线性列表</li>
<li>散列表</li>
</ul>
<h3 id="4-2-5文件共享"><a href="#4-2-5文件共享" class="headerlink" title="4.2.5文件共享"></a>4.2.5文件共享</h3><p><strong>基于索引节点的共享方式（硬链接）</strong></p>
<ul>
<li>文件的物理地址及其他的文件属性等信息，不再放在目录项中，而放在索引节点中，文件目录中只设置文件名及指向相应索引节点的指针</li>
<li>索引节点中还应该有一个链接技术count，用于表示链接到本索引节点上的用户目录项的数目</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309081556868.png" alt="image-20230908155627860"></li>
</ul>
<p><strong>利用符号链实现文件共享（软链接）</strong></p>
<ul>
<li>在一个Link型的文件中记录共享文件的存放路径（Windows快捷方式）</li>
<li>操作系统如果判断该文件是Link文件，则根据存放的路径去找到共享文件</li>
<li>Link文件被删除，共享文件仍存在，可以正常访问</li>
<li>共享文件被删除，Link文件仍存在，但会访问失败</li>
</ul>
<h1 id="4-3文件系统"><a href="#4-3文件系统" class="headerlink" title="4.3文件系统"></a>4.3文件系统</h1><h3 id="4-3-1文件系统结构"><a href="#4-3-1文件系统结构" class="headerlink" title="4.3.1文件系统结构"></a>4.3.1文件系统结构</h3><ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309081604391.png" alt="image-20230908160407336"></li>
<li>I/O控制<ul>
<li>包括设备驱动程序和中断处理程序，在内存和磁盘系统之间传输信息</li>
</ul>
</li>
<li>基本文件系统<ul>
<li>向对应的设备驱动程序发送通用命令，以读取和写入磁盘的物理块</li>
<li>管理内存缓冲区，并保存各种文件系统、目录和数据块的缓存</li>
</ul>
</li>
<li>文件组织模块<ul>
<li>组织文件及其逻辑块和物理块，可以将逻辑块地址转换为物理地址</li>
<li>包括空闲空间管理器，以跟踪未分配的块，根据需求提供给文件组织模块</li>
</ul>
</li>
<li>逻辑文件系统<ul>
<li>管理元数据信息，元数据包括文件系统的所有结构，而不包括实际数据</li>
<li>管理目录结构</li>
<li>通过文件控制块来维护文件系统</li>
<li>负责文件保护</li>
</ul>
</li>
</ul>
<h3 id="4-3-2文件系统布局"><a href="#4-3-2文件系统布局" class="headerlink" title="4.3.2文件系统布局"></a>4.3.2文件系统布局</h3><p><strong>文件系统在磁盘中的结构</strong></p>
<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309091359047.png" alt="image-20230909135923327"></li>
<li>主引导记录（MBR）<ul>
<li>位于磁盘的0号扇区，用来引导计算机，MBR后面是分区表，该表给出每个分区的起始和结束地址</li>
<li>计算机启动时候，BIOS读入并执行MBR，MBR做的第一件事情是确定活动分区，读入它的第一块，即引导块</li>
</ul>
</li>
<li>引导块<ul>
<li>MBR执行引导块中的程序后，该程序负责启动该分区中的操作系统</li>
<li>每个分区都从一个引导快开始，即使该分区中不含可启动的操作系统</li>
<li>引导块之后的布局随着文件系统的不同而不同</li>
</ul>
</li>
<li>超级块<ul>
<li>包含文件系统的所有关键信息</li>
<li>计算机启动时/该文件系统首次使用时，超级块会被读入内存</li>
<li>典型信息<ul>
<li>分区的块的数量</li>
<li>块的大小</li>
<li>空闲块的数量和指针</li>
<li>空闲的FCB数量</li>
<li>FCB指针</li>
</ul>
</li>
<li>文件系统中空闲块的信息——用位视图或指针链接的形式给出</li>
<li>i结点——说明文件的方方面面</li>
<li>根目录——存放文件系统目录树的根部</li>
<li>其他部分——存放其他所有的目录和文件</li>
</ul>
</li>
</ul>
<p><strong>文件系统在内存中的结构</strong></p>
<ul>
<li>包含<ul>
<li>内存中的安装表——包含每个已安装文件系统分区的有关信息</li>
<li>内存中的目录结构的缓存——包含最近访问目录的信息，对安装分区的目录，可以包括一个指向分区表的指针</li>
<li>整个系统的打开文件表——包含每个打开文件的FCB副本及其他信息</li>
<li>每个进程的打开文件表——包含一个指向整个系统的打开文件表中的适当条目的指针，以及其他信息</li>
</ul>
</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309091424136.png" alt="image-20230909142413251"></li>
</ul>
<h3 id="4-3-3外存空闲空间管理"><a href="#4-3-3外存空闲空间管理" class="headerlink" title="4.3.3外存空闲空间管理"></a>4.3.3外存空闲空间管理</h3><ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309091427027.png" alt="image-20230909142757060"></li>
</ul>
<p><strong>空闲表法</strong></p>
<ul>
<li>属于连续分配方式，为每一个文件分配一块连续的存储空间</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309091437247.png" alt="image-20230909143728382"></li>
<li>可采用首次适应、最佳适应、最坏适应等算法来决定要为文件分配哪个空闲区</li>
<li>回收时需要注意表项的合并问题</li>
</ul>
<p><strong>空闲链表法</strong></p>
<ul>
<li>空闲盘块链<ul>
<li>将磁盘上所有的空闲空间以盘块为单位拉成一条链</li>
<li>分配空间时，系统从链首开始，依次摘下适当数目的空闲盘块分配给用户</li>
<li>回收时，将回收的盘块一次插入到链尾</li>
<li>优点——分配和回收一个盘块的过程非常简单</li>
<li>缺点——分配时可能要重复操作多次，效率低，以盘块为单位会导致空闲盘块链很长</li>
</ul>
</li>
<li>空闲盘区链<ul>
<li>将磁盘上的所有空闲盘区（一个盘区可能包含多个盘块）拉成一条链，每个盘区除含有指向下一个盘区的指针还有本盘区大小的信息</li>
<li>通常采用首次适应算法</li>
<li>回收时要注意与临近的盘块合并</li>
<li>分配和回收的过程较复杂，效率通常较高，且链表较短</li>
</ul>
</li>
</ul>
<p><strong>位示图法</strong></p>
<ul>
<li>利用二进制的一位来表示一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应</li>
<li>0表示空闲，1表示已分配</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309091448204.png" alt="image-20230909144813185"></li>
<li>盘块的分配<ul>
<li>顺序扫描位示图，从中找出一个或一组为0的二进制位</li>
<li>将找到的二进制位转换为对应的盘块号，第i行第j列对应<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="11.493ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 5079.9 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(989,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1556.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(2556.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(3056.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(3667.7,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(4667.9,0)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g></g></g></svg></mjx-container>（n表示每行位数）</li>
<li>修改位示图</li>
</ul>
</li>
<li>盘块的回收<ul>
<li>将回收盘块的盘块号b转换成位示图中的行号和列号<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="36.789ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 16260.9 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(622.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mo" transform="translate(1678.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(2067.6,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(2718.8,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(3719,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(4219,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(4608,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path></g></g><g data-mml-node="mi" transform="translate(5108,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(5930.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(6930.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(7430.4,0)"><g data-mml-node="mo"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">、</text></g></g><g data-mml-node="mi" transform="translate(8430.4,0)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g><g data-mml-node="mo" transform="translate(9120.2,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mo" transform="translate(10176,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(10565,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(11216.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(12216.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(12716.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mi" transform="translate(13105.4,0)"><path data-c="25" d="M465 605Q428 605 394 614T340 632T319 641Q332 608 332 548Q332 458 293 403T202 347Q145 347 101 402T56 548Q56 637 101 693T202 750Q241 750 272 719Q359 642 464 642Q580 642 650 732Q662 748 668 749Q670 750 673 750Q682 750 688 743T693 726Q178 -47 170 -52Q166 -56 160 -56Q147 -56 142 -45Q137 -36 142 -27Q143 -24 363 304Q469 462 525 546T581 630Q528 605 465 605ZM207 385Q235 385 263 427T292 548Q292 617 267 664T200 712Q193 712 186 709T167 698T147 668T134 615Q132 595 132 548V527Q132 436 165 403Q183 385 203 385H207ZM500 146Q500 234 544 290T647 347Q699 347 737 292T776 146T737 0T646 -56Q590 -56 545 0T500 146ZM651 -18Q679 -18 707 24T736 146Q736 215 711 262T644 309Q637 309 630 306T611 295T591 265T578 212Q577 200 577 146V124Q577 -18 647 -18H651Z"></path></g><g data-mml-node="mi" transform="translate(13938.4,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(14760.7,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(15760.9,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container></li>
<li>修改位示图</li>
</ul>
</li>
</ul>
<p><strong>成组链接法</strong></p>
<ul>
<li><p>空闲表法、空闲链表法不适用于大型文件系统，因为空闲表或空闲链表可能过大</p>
</li>
<li><p>结合了空闲表和空闲链表两种方法</p>
</li>
<li>用来存放一组空闲盘块号的盘块称为成组链块</li>
<li>思想<ul>
<li>把顺序的n个空闲盘块保存在第一个成组链块中，其最后一个空闲盘块（作为成组链块）用于保存另一组空闲盘块号</li>
</ul>
</li>
<li>假设所有盘块都是空闲盘块<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309091503489.png" alt="image-20230909150338332"></li>
</ul>
</li>
<li>盘块的分配<ul>
<li>根据第一个成组链块的指针，将其对应的盘块分配给用户，然后将指针下移一格。若该指针指向的是最后一个盘块（即成组链块），由于该盘块记录的是下一组空闲盘块号，因此要将该盘块读入内存，并将指针指向新的成组链块的第一条记录，然后执行上述分配操作</li>
</ul>
</li>
<li>盘块的回收<ul>
<li>成组链块的指针上移一格，再记入回收盘块号。当成组链块的链接数达到n时，表示已满便将现有已记录n个空闲盘块号的成组链块号记入新回收的盘块（作为新的成组链块）</li>
</ul>
</li>
<li>表示空闲空间的位向量表或第一个成组链块，以及卷中的目录区、文件区划分信息都要存放在磁盘中，一般放在卷头位置，在UNIX系统中称为超级块</li>
</ul>
<h3 id="4-3-4虚拟文件系统（VFS）"><a href="#4-3-4虚拟文件系统（VFS）" class="headerlink" title="4.3.4虚拟文件系统（VFS）"></a>4.3.4虚拟文件系统（VFS）</h3><ul>
<li>VFS为用户程序提供了文件系统操作的统一接口，屏蔽了不同文件系统的差异和操作细节，用户程序可以通过VFS提供的同一调用函数来操作不同文件系统</li>
<li>采用面向对象思想，定义了通用文件系统都支持的接口，新的文件系统只要支持并实现这些接口，即可安装和使用</li>
<li>Linux抽象了四种对象类型，将不同文件系统的文件用同一种数据结构来表示<ul>
<li>超级块对象<ul>
<li>对应磁盘上特定扇区的文件系统超级块，用于存储已安装文件系统的元信息</li>
</ul>
</li>
<li>索引节点对象<ul>
<li>文件系统处理文件所需要的所有信息，对文件是唯一的</li>
<li>文件被访问时才创建</li>
<li>该表中设有一个状态字段表示文件是否被修改</li>
</ul>
</li>
<li>目录项对象<ul>
<li>提高VFS切换目录的效率</li>
</ul>
</li>
<li>文件对象<ul>
<li>代表进程打开的一个文件</li>
<li>同一文件在内存中可能存在多个对应的文件对象——多个进程打开和操作同一文件</li>
</ul>
</li>
</ul>
</li>
<li>文件系统挂载<ul>
<li>在VFS中注册新挂载的文件系统。内存中的挂载表（mount table）包含每个文件系统的相关信息，包括文件系统类型、容量大小等</li>
<li>新挂载的文件系统，要向VFS提供一个函数地址列表</li>
<li>将新文件系统加到挂载点（mountpoint），也就是将新文件系统挂载在某个父目录下</li>
</ul>
</li>
</ul>
<h3 id="4-3-5分区与安装"><a href="#4-3-5分区与安装" class="headerlink" title="4.3.5分区与安装"></a>4.3.5分区与安装</h3><ul>
<li>一个磁盘可以划分为多个分区，每个分区都可以用于创建单独的文件系统，每个分区还可以包含不同的操作系统</li>
</ul>
]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>计网-第一章-计算机网络体系结构</title>
    <url>/2023/09/16/%E8%AE%A1%E7%BD%91-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="1-1-计算机网络概述"><a href="#1-1-计算机网络概述" class="headerlink" title="1.1 计算机网络概述"></a>1.1 计算机网络概述</h1><h3 id="1-1-1-计算机网络的概念"><a href="#1-1-1-计算机网络的概念" class="headerlink" title="1.1.1 计算机网络的概念"></a>1.1.1 计算机网络的概念</h3><ul>
<li>计算机网络是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统</li>
<li>简而言之，计算机网络就是一些互连的、自治的计算机系统的集合</li>
</ul>
<span id="more"></span>
<h3 id="1-1-2-计算机网络的组成"><a href="#1-1-2-计算机网络的组成" class="headerlink" title="1.1.2 计算机网络的组成"></a>1.1.2 计算机网络的组成</h3><h4 id="从组成部分"><a href="#从组成部分" class="headerlink" title="从组成部分"></a><strong>从组成部分</strong></h4><ul>
<li>硬件<ul>
<li>主机（端系统）</li>
<li>通信链路（如双绞线、光纤）</li>
<li>交换设备（如路由器、交换机）</li>
<li>通信处理机（如网卡）</li>
</ul>
</li>
<li>软件<ul>
<li>包括各种实现资源共享的软件和方便用户使用的各种工具软件</li>
<li>多属于应用层</li>
</ul>
</li>
<li>协议<ul>
<li>计算机网络的核心</li>
<li>规定了网络传输数据时所遵循的规范</li>
</ul>
</li>
</ul>
<h4 id="从工作方式上看"><a href="#从工作方式上看" class="headerlink" title="从工作方式上看"></a>从工作方式上看</h4><ul>
<li>边缘部分<ul>
<li>由所有连接到因特网上、供用户直接使用的主机组成，用来进行通信和资源共享</li>
<li>用户直接使用<ul>
<li>C/S</li>
<li>P2P</li>
</ul>
</li>
</ul>
</li>
<li>核心部分<ul>
<li>由大量的网络和连接这些网络的路由器组成</li>
<li>为边缘部分提供连通性和交换服务</li>
</ul>
</li>
</ul>
<h4 id="从功能组成上看"><a href="#从功能组成上看" class="headerlink" title="从功能组成上看"></a>从功能组成上看</h4><ul>
<li>通信子网<ul>
<li>由各种传输介质、通信设备和相应的网络协议组成、</li>
<li>使网络具有数据传输、交换、控制和存储的能力，实现联网计算机之间的数据通信</li>
</ul>
</li>
<li>资源子网<ul>
<li>实现资源共享功能的设备机器软件的集合</li>
<li>向网络用户提供共享其他计算机上的硬件资源、软件资源和数据资源的服务</li>
</ul>
</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309162023168.png" alt="image-20230916202047984"></li>
</ul>
<h3 id="1-1-3-计算机网络的功能"><a href="#1-1-3-计算机网络的功能" class="headerlink" title="1.1.3 计算机网络的功能"></a>1.1.3 计算机网络的功能</h3><ul>
<li>数据通信<ul>
<li>计算机网络最基本和最重要的功能</li>
</ul>
</li>
<li>资源共享<ul>
<li>软件共享、数据共享、硬件共享</li>
</ul>
</li>
<li>分布式处理</li>
<li>提高可靠性</li>
<li>负载均衡</li>
</ul>
<h3 id="1-1-4-计算机网络的分类"><a href="#1-1-4-计算机网络的分类" class="headerlink" title="1.1.4 计算机网络的分类"></a>1.1.4 计算机网络的分类</h3><h4 id="按分布范围分类"><a href="#按分布范围分类" class="headerlink" title="按分布范围分类"></a>按分布范围分类</h4><ul>
<li>广域网（WAN）<ul>
<li>有时也称远程网</li>
<li>因特网的核心部分</li>
<li>使用交换技术</li>
</ul>
</li>
<li>城域网（MAN）<ul>
<li>大多采用以太网技术</li>
</ul>
</li>
<li>局域网（LAN）<ul>
<li>使用广播技术</li>
</ul>
</li>
<li>个人区域网（PAN）<ul>
<li>也称无线个人区域网（WPAN）</li>
</ul>
</li>
</ul>
<h4 id="按传输技术分类"><a href="#按传输技术分类" class="headerlink" title="按传输技术分类"></a>按传输技术分类</h4><ul>
<li>广播式网络<ul>
<li>不需要网络层</li>
</ul>
</li>
<li>点对点网络</li>
</ul>
<h4 id="按拓扑结构分类-通信子网"><a href="#按拓扑结构分类-通信子网" class="headerlink" title="按拓扑结构分类-通信子网"></a>按拓扑结构分类-通信子网</h4><ul>
<li>总线型</li>
<li>星型网络</li>
<li>环形网络</li>
<li>网状网络</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309162031578.png" alt="image-20230916203126558"></li>
</ul>
<h4 id="按使用者分类"><a href="#按使用者分类" class="headerlink" title="按使用者分类"></a>按使用者分类</h4><ul>
<li>公用网（公共网）</li>
<li>专用网</li>
</ul>
<h4 id="按交换技术分类"><a href="#按交换技术分类" class="headerlink" title="按交换技术分类"></a>按交换技术分类</h4><ul>
<li>电路交换网络</li>
<li>报文交换网络</li>
<li>分组交换网络</li>
</ul>
<h4 id="按传输介质分类"><a href="#按传输介质分类" class="headerlink" title="按传输介质分类"></a>按传输介质分类</h4><ul>
<li>有线网络</li>
<li>无线网络</li>
</ul>
<h3 id="1-1-5-计算机网络的标准化工作"><a href="#1-1-5-计算机网络的标准化工作" class="headerlink" title="*1.1.5 计算机网络的标准化工作"></a>*1.1.5 计算机网络的标准化工作</h3><h3 id="1-1-6-计算机网络的性能指标"><a href="#1-1-6-计算机网络的性能指标" class="headerlink" title="1.1.6 计算机网络的性能指标"></a>1.1.6 计算机网络的性能指标</h3><h4 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h4><ul>
<li>用来表示网络的通信线路传送数据的能力，通常指单位时间内从网络的某一点到另一点所能通过的”最高数据率“</li>
</ul>
<h4 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h4><ul>
<li>指数据（报文/分组/比特流）从网络（或链路）的一端传送到另一端所需的时间</li>
<li>发送时延<ul>
<li>从发送分组的第一个比特算起，到该分组的最后一个比特发送完毕所需的时间</li>
<li>发送时延=分组长度/信道宽度</li>
</ul>
</li>
<li>传播时延<ul>
<li>一个比特从链路的一段传播到另一端所需的时间</li>
<li>传播时延=信道长度/电磁波在信道上的传播速率</li>
</ul>
</li>
<li>处理时延<ul>
<li>数据在交换节点为存储转发而进行的一些必要的处理所花费的时间</li>
</ul>
</li>
<li>派对时延<ul>
<li>分组在进入路由器后要先在输入队列中排队等待处理</li>
</ul>
</li>
<li>总时延=发送时延+传播时延+处理时延+排队时延</li>
</ul>
<h4 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h4><ul>
<li>指发送端发送的第一个比特即将到达终点时，发送端已经发出了多少个比特</li>
<li>又称以比特位单位的链路长度</li>
<li>时延带宽积=传播时延*信道宽度</li>
</ul>
<h4 id="往返时延（RRT）"><a href="#往返时延（RRT）" class="headerlink" title="往返时延（RRT）"></a>往返时延（RRT）</h4><ul>
<li>从发送端发出一个短分组，到发送端收到来自接收端的确认（接收端收到数据后立即发送确认）总共经历的时延</li>
</ul>
<h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><ul>
<li>单位时间内通过某个网络（或信道、接口）的数据量</li>
<li>受网络带宽或网络额定速率的限制</li>
</ul>
<h4 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h4><ul>
<li>即数据率或称数据传输率或比特率</li>
<li>通常把最高数据传输率称为带宽</li>
<li>b/s、kb/s…</li>
</ul>
<h4 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h4><ul>
<li>某一信道由百分之多少的时间是由数据通过的</li>
<li>信道利用率=有数据通过时间/（有+无）数据通过时间</li>
</ul>
<h1 id="1-2-计算机网络体系结构与参考模型"><a href="#1-2-计算机网络体系结构与参考模型" class="headerlink" title="1.2 计算机网络体系结构与参考模型"></a>1.2 计算机网络体系结构与参考模型</h1><h3 id="1-2-1-计算机网络分层结构"><a href="#1-2-1-计算机网络分层结构" class="headerlink" title="1.2.1 计算机网络分层结构"></a>1.2.1 计算机网络分层结构</h3><ul>
<li>计算机网络的各层及其协议的集合称为体系结构</li>
<li>分层的基本原则<ul>
<li>各层都实现一种相对独立的功能，降低大系统的复杂度</li>
<li>各层之间界面自然清晰，易于理解，相互交流尽可能少</li>
<li>各层功能的精确定义独立于具体的实现方法，可以采用最适合的技术来实现</li>
<li>保持下次对上层的独立性，上层单向使用下层提供的服务</li>
<li>整个分层结构应能促进标准化工作</li>
</ul>
</li>
<li>优点：各层之间相对独立，灵活性好，分层的体系结构易于更新（替换单个模块），易于调试，易于交流，易于抽象，易于标准化</li>
<li>层次过多：有些功能在不同层之间难免重复出现，产生额外的开销，导致整体效率变低</li>
<li>层次过少：每层的协议太过复杂</li>
</ul>
<hr>
<ul>
<li>实体<ul>
<li>第n层中的活动元素通常称为第n层实体</li>
<li>实体指任何可发送或接受信息的硬件或软件进程，通常是一个特定的软件模块</li>
</ul>
</li>
<li>对等层<ul>
<li>不同机器上的同一层称为对等层</li>
</ul>
</li>
<li>对等实体<ul>
<li>不同机器同一层的实体</li>
</ul>
</li>
<li>服务提供者<ul>
<li>第n层是第n+1层的服务提供者</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>服务数据单元 SDU<ul>
<li>为完成用户所要求的功能而应该传送的数据</li>
<li>第n层的服务数据单元记为n-SDU</li>
</ul>
</li>
<li>协议控制信息 PCI<ul>
<li>控制协议操作的信息</li>
<li>第n层的协议提控制信息记为n-PCI</li>
</ul>
</li>
<li>协议数据单元 PDU<ul>
<li>对等层次之间的传送数据单位称为该层的PDU</li>
<li>第n层的协议数据单元记为n-PDU</li>
<li>别名<ul>
<li>物理层——比特</li>
<li>数据链路层——帧</li>
<li>网络层——分组</li>
<li>传输层——报文段</li>
</ul>
</li>
<li>PDU=SDU+PCI</li>
</ul>
</li>
<li>(n+1)-PDU=n-SDU~第n+1层的PDU=第n层的SDU~</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309171616443.png" alt="image-20230917161633996"></li>
</ul>
<hr>
<ul>
<li>层次结构的含义<ul>
<li>第n层的实体不仅仅要使用第n-1层的服务来实现自身定义的功能，还要向第n+1层提供本层的服务，该服务是第n层及其下面各层提供的服务总和</li>
<li>最低层指提供服务，是整个层次结构的基础；中间各层即是下一层的服务使用者，又是上一层的服务提供者；最高层面向用户提供服务</li>
<li>上一层只能通过相邻层间的接口使用下一层的服务，而不能调用其他层的服务；下一层所提供的服务的实现细节对上一层透明</li>
<li>两台主机通信时，对等层在逻辑上有一条直接信道，表现为不经过下层就把信息传送到对方</li>
</ul>
</li>
</ul>
<h3 id="1-2-2-计算机网络协议、接口、服务的概念"><a href="#1-2-2-计算机网络协议、接口、服务的概念" class="headerlink" title="1.2.2 计算机网络协议、接口、服务的概念"></a>1.2.2 计算机网络协议、接口、服务的概念</h3><h5 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h5><ul>
<li>为进行网络中数据交换而建立的规则、标准或约定称为网络协议</li>
<li>不对等实体之间时没有协议的</li>
<li>组成<ul>
<li>语法<ul>
<li>规定了传输数据的格式</li>
</ul>
</li>
<li>语义<ul>
<li>规定了所要完成的功能，即所需要发出何种控制信息、完成何种动作及做出何种应答</li>
</ul>
</li>
<li>同步<ul>
<li>规定了执行各种操作的条件、时序关系等，即事件实现顺序的详细说明</li>
</ul>
</li>
</ul>
</li>
<li>一个完整的协议通常应具有线路管理（建立、释放连接）、差错控制、数据转换等功能</li>
</ul>
<h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><ul>
<li>接口是同一节点内相邻两层交换信息的连接点，是一个系统内部的规定</li>
<li>每层只能为紧邻的层次之间定义接口</li>
<li><p>在典型的接口上,同一结点相邻两层的实体通过服务访问点(Service Access Point, SAP)进行交互</p>
<ul>
<li>物理层——网卡接口</li>
<li>数据链路层——MAC地址</li>
<li>网络层——IP地址</li>
<li>传输层——端口号</li>
<li>应用层——用户界面</li>
</ul>
</li>
<li><p>服务是通过SAP提供给上层使用的,第n层的SAP就是第n+1层可以访问第n层服务的地方</p>
</li>
<li>每个SAP都有一个能够标识它的地址</li>
<li>SAP是一个抽象的概念,它实际上是一个逻辑接口(类似于邮政信箱),但和通常所说的两个设备之间的硬件接口是很不一样的。</li>
</ul>
<h5 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h5><ul>
<li>服务是指下层为紧邻的上层提供的功能调用，他是垂直的</li>
<li><p>服务原语——上层使用下层所提供服务的命令</p>
<ul>
<li><p>请求——有服务用户发往服务提供者，请求完成某项工作</p>
</li>
<li><p>指示——由服务提供者发往服务用户，指示用户做某件事情</p>
</li>
<li><p>响应——由服务用户发往服务提供者，作为对指示的响应</p>
</li>
<li><p>证实——由服务提供者发往服务用户，作为对请求的证实</p>
</li>
</ul>
</li>
<li><p><img src="https://gitee.com/renmale-sztu/image/raw/master/202309171640817.png" alt="image-20230917164058820"></p>
</li>
</ul>
<hr>
<ul>
<li>只有本层协议的实现才能保证向上层提供服务</li>
<li>本层的服务用户只能看见服务而无法看见下面的协议，即下层协议对上层的服务用户透明</li>
<li>协议是水平的，控制对等实体之间通信的规则</li>
<li>服务是垂直的，由下层通过层间接口向上层提供</li>
<li>并非一层内完成的全部功能都称为服务，只有能被高一层实体看见的功能才称为服务</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309171644916.png" alt="image-20230917164417073"></li>
</ul>
<hr>
<ul>
<li>面向连接服务和无连接服务<ul>
<li>面向连接服务<ul>
<li>通信前双方必须先建立连接，分配相应的资源</li>
<li>连接建立——数据传输——连接释放</li>
<li>如TCP</li>
</ul>
</li>
<li>无连接服务<ul>
<li>通信前双方不需要先建立连接，直接发送数据</li>
<li>不保证通信的可靠性</li>
<li>如IP、UDP</li>
</ul>
</li>
</ul>
</li>
<li>可靠服务和不可靠服务<ul>
<li>可靠服务<ul>
<li>可靠服务是指网络具有纠错、检错、应答机制，能保证数据正确、可靠地传送到目的地</li>
</ul>
</li>
<li>不可靠服务<ul>
<li>不可靠服务是指网络只是尽量正确、可靠地传送，而不能保证数据正确、可靠地传送到目的地，是一种尽力而为的服务</li>
<li>网络的正确性、可靠性要由应用或用户来保障</li>
</ul>
</li>
</ul>
</li>
<li>有应答服务和无应答服务<ul>
<li>有应答服务、<ul>
<li>有应答服务是指接收方在收到数据后向发送方给出相应的应答</li>
<li>该应答有传输系统内部自动实现</li>
<li>肯定应答、否定应答</li>
<li>如文件传输服务</li>
</ul>
</li>
<li>无应答服务<ul>
<li>指接收方收到数据后不自动给出应答</li>
<li>需要应答由高层实现</li>
<li>如WWW服务</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1-2-3-ISO-OSI参考模型和TCP-IP模型"><a href="#1-2-3-ISO-OSI参考模型和TCP-IP模型" class="headerlink" title="1.2.3 ISO/OSI参考模型和TCP/IP模型"></a>1.2.3 ISO/OSI参考模型和TCP/IP模型</h3><h4 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h4><ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309171652849.png" alt="image-20230917165215947"></li>
<li>通信子网<ul>
<li>网络层</li>
<li>数据链路层</li>
<li>物理层</li>
</ul>
</li>
<li>资源子网<ul>
<li>应用层</li>
<li>表示层</li>
<li>会话层</li>
</ul>
</li>
<li>传输层承上启下</li>
</ul>
<hr>
<h5 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h5><ul>
<li>传输单位是比特</li>
<li>主要任务：在物理媒体上为数据短设备<strong>透明</strong>（不管什么数据是什么样的比特组合，都应当能够在链路上传送）地传输原始比特流</li>
<li>物理层协议也称物理层接口标准</li>
<li>功能<ul>
<li>定义接口特性</li>
<li>定义传输模式——单工、半双工、双工</li>
<li>定义传输速率</li>
<li>比特同步</li>
<li>比特编码</li>
</ul>
</li>
<li>主要协议——Rj45、802.3</li>
</ul>
<h5 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h5><ul>
<li>传输单位是帧</li>
<li>主要任务：将网络层传来的IP数据报组装成帧</li>
<li>点到点</li>
<li>功能<ul>
<li>成帧</li>
<li>差错控制——帧错+位错</li>
<li>流量控制——协调两个结点的速率，A发送速率=B接受速率</li>
<li>传输管理</li>
</ul>
</li>
<li>介质访问子层<ul>
<li>特殊的子层</li>
<li>控制对共享信道的访问</li>
</ul>
</li>
<li>协议——SDLC、HDLC、PPP、STP和帧中断</li>
</ul>
<h5 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h5><ul>
<li>传输单位是数据报</li>
<li>主要任务：把网络层的协议数据单元（分组）从源端传送到目的端，为分组交换网上的不同主机提供通信服务</li>
<li>功能<ul>
<li>路由选择</li>
<li>流量控制<ul>
<li>协调A的发送速率和B的接收速率</li>
</ul>
</li>
<li>拥塞控制<ul>
<li>拥塞状态：网络节点都处于来不及接收分组而要丢弃大量分组的情况</li>
</ul>
</li>
<li>差错控制<ul>
<li>两结点之间约定的特定检错规则——奇偶校验码</li>
<li>能纠错就纠错，不能就丢弃</li>
</ul>
</li>
</ul>
</li>
<li>协议——IP、IPX、ICMP、IGMP、ARP、RARP、OSPF等</li>
</ul>
<h5 id="传输层（运输层）"><a href="#传输层（运输层）" class="headerlink" title="传输层（运输层）"></a>传输层（运输层）</h5><ul>
<li>传输单位是报文段（TCP）/用户数据报（UDP）</li>
<li>主要任务：负责主机中两个进程之间的通信，为<strong>端到端</strong>连接提供可靠的传输服务</li>
<li>功能<ul>
<li>可靠/不可靠传输</li>
<li>差错控制</li>
<li>流量控制</li>
<li>复用分用</li>
</ul>
</li>
<li>协议——TCP、UDP</li>
</ul>
<h5 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h5><ul>
<li><p>允许不同主机上地各个进程进行会话</p>
</li>
<li><p>为表示层实体或用户进程建立连接并在连接上有序地传输数据，这就是会话，也是建立同步（SYN）</p>
</li>
<li>功能<ul>
<li>建立、管理、终止绘画</li>
<li>使用校验点可使会话在通信失效时从校验点/同步点继续恢复通信，实现数据同步</li>
</ul>
</li>
</ul>
<h5 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h5><ul>
<li>主要处理在两个通信系统中交换信息的表示方式（语法和语义）</li>
<li>功能<ul>
<li>数据格式变换</li>
<li>数据加密解密</li>
<li>数据压缩和恢复</li>
</ul>
</li>
</ul>
<h5 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h5><ul>
<li>最高、最复杂、协议最多</li>
<li>为特定类型的网络应用（所有能和用户交互产生流量的程序）提供访问OSI参考模型环境的手段</li>
<li>协议<ul>
<li>文件传送 FTP</li>
<li>电子邮件 SMTP</li>
<li>万维网 HTTP</li>
<li>…</li>
</ul>
</li>
</ul>
<h4 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h4><ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309181411696.png" alt="image-20230918141104472"></li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309181411210.png" alt="image-20230918141138410"></li>
</ul>
<h5 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h5><ul>
<li>功能类似于OSI参考模型的物理层和数据链路层</li>
<li>表示物理网络的接口，实际上TCP/IP本身并未真正描述这一部分，只是指出主机必须使用某种协议和网络连接，以便在上传递IP分组</li>
</ul>
<h5 id="网际层"><a href="#网际层" class="headerlink" title="网际层"></a>网际层</h5><ul>
<li>TCP/IP体系结构的关键部分</li>
<li>将分组发往任何网络，并为之独立地选择合适的路由，但不保证各个分组有序地到达，各个分组地有序交付由高层负责</li>
</ul>
<h5 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h5><ul>
<li>使发送端和目的端主机上的对等实体进行会话</li>
<li>传输控制协议<ul>
<li>面向连接，传输报文段</li>
</ul>
</li>
<li>用户数据报协议<ul>
<li>无连接，传输用户数据报</li>
</ul>
</li>
</ul>
<h5 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h5><ul>
<li>包含所有的高层协议</li>
</ul>
<h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><h5 id="相同"><a href="#相同" class="headerlink" title="相同"></a>相同</h5><ul>
<li>都采用分层的体系结构</li>
<li>都基于独立的协议栈的概念</li>
<li>都可以解决异构网络的互连</li>
</ul>
<h5 id="不同"><a href="#不同" class="headerlink" title="不同"></a>不同</h5><ul>
<li>OSI参考模型的最大贡献就是精确地定义了三个主要概念：服务、协议和接口，这与现代的面向对象程序设计思想非常吻合。而TCP/IP模型在这三个概念上却没有明确区分，不符合软件工程的思想</li>
<li>OSI参考模型产生在协议发明之前，没有偏向于任何特定的协议，通用性良好。但设计者在协议方面没有太多经验，不知道把哪些功能放到哪一层更好。TCP/IP模型正好相反，首先出现的是协议，模型实际上是对已有协议的描述，因此不会出现协议不能匹配模型的情况，但该模型不适合于任何其他非TCP/IP的协议栈。</li>
<li>TCP/IP模型在设计之初就考虑到了多种异构网的互连问题，并将网际协议（IP）作为一个单独的重要层次。OSI参考模型最初只考虑到用一种标准的公用数据网将各种不同的系统互连。OSI参考模型认识到IP的重要性后，只好在网络层中划分出一个子层来完成类似于TCP/IP模型中的IP的功能。</li>
</ul>
<h4 id="五层参考模型"><a href="#五层参考模型" class="headerlink" title="五层参考模型"></a>五层参考模型</h4><ul>
<li>综合OSII参考模型和TCP/IP模型的优点</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309181423168.png" alt="image-20230918142326312"></li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309181423356.png" alt="image-20230918142351479"></li>
</ul>
]]></content>
      <tags>
        <tag>计算计网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计组—第一章—计算机系统概述</title>
    <url>/2023/09/03/%E8%AE%A1%E7%BB%84%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h2 id="1-1-计算机发展历程（不考察）"><a href="#1-1-计算机发展历程（不考察）" class="headerlink" title="1.1 计算机发展历程（不考察）"></a>1.1 计算机发展历程（不考察）</h2><ul>
<li>计算机硬件的发展<ul>
<li>第一代计算机——电子管时代</li>
<li>第二代计算机——晶体管时代</li>
<li>第三代计算机——中小规模集成电路时代</li>
<li>第四代计算机——超大规模集成电路时代</li>
</ul>
</li>
<li>摩尔定律——价格不变时，集成电路上可容纳的晶体管数目，约每隔18个月增长一倍</li>
</ul>
<span id="more"></span>
<h2 id="1-2-计算机系统层次结构"><a href="#1-2-计算机系统层次结构" class="headerlink" title="1.2 计算机系统层次结构"></a>1.2 计算机系统层次结构</h2><p><strong>计算机系统的组成</strong></p>
<ul>
<li>硬件系统</li>
<li>软件系统</li>
</ul>
<p><strong>计算机硬件的基本组成</strong></p>
<ul>
<li>冯诺依曼机 <ul>
<li>采用 “存储程序” 的工作方式 —— 将指令以代码的形式事先输入计算机主存储器，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的的规定顺序执行其他指令，直至程序结束</li>
<li>运算器 + 存储器 + 控制器 + 输入设备 + 输出设备</li>
<li>指令和数据以同等地位存储在存储器中，但计算机能够区分它们（指令周期的不同阶段）</li>
<li>指令和数据君用二进制代码表示</li>
<li>控制流驱动方式</li>
<li>五大功能<ul>
<li>数据传送功能</li>
<li>数据存储功能</li>
<li>数据处理功能</li>
<li>操作控制功能</li>
<li>操作判断功能</li>
</ul>
</li>
</ul>
</li>
<li>计算机的功能部件<ul>
<li>输入设备 —— 将程序和数据以机器能够识别和接受的信息形式输入计算机</li>
<li>输出设备</li>
<li>存储器<ul>
<li>主存储器（内存储器）<ul>
<li>CPU能够直接访问</li>
<li>组成<ul>
<li>地址寄存器（MAR）~存放访存地址~<ul>
<li>~MAR的位数对应着存储单元的个数~</li>
<li>~MAR的长度与PC的长度相等~</li>
</ul>
</li>
<li>数据寄存器（MDR）~用于暂存要从存储器中读或写的信息~<ul>
<li>~MDR的长度和存储字长相等~</li>
</ul>
</li>
<li>时序控制逻辑 ~产生存储器操作所需的各种时序信号~</li>
<li>存储体 ~包含若干存储单元，每个存储单元包含若干存储元件，每个存储元件存储一位二进制代码~</li>
</ul>
</li>
</ul>
</li>
<li>辅助存储器（外存储器）</li>
</ul>
</li>
<li>运算器<ul>
<li>组成<ul>
<li>算术逻辑单元 ALU（核心）</li>
<li>累加寄存器 ACC</li>
<li>乘商寄存器 MQ</li>
<li>操作数寄存器 X</li>
<li>变址寄存器 IX</li>
<li>基址寄存器 BR</li>
<li>程序状态字寄存器 PSW ~结果是否溢出，有无产生进位或错位，结果是否为负~</li>
</ul>
</li>
</ul>
</li>
<li>控制器<ul>
<li>控制器是计算机的指挥中心</li>
<li>组成<ul>
<li>程序计数器 PC ~存放当前欲执行指令的地址，有自动加1的功能~</li>
<li>指令寄存器  IR ~存放当前的指令，其内容来自MDR，指令中操作码OP(IP)送至CU，地址码Ad(IR)送完MAR~</li>
<li>控制单元 CU</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>冯诺依曼模型机<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202308232302523.png" alt="image-20230823230159565"> </li>
<li>CPU包括ALU、通用寄存器组GRPs、标志寄存器、控制器、指令寄存器IR、程序计数器PC、存储器地址寄存器MAR和存储器数据寄存器MAR</li>
<li>虚线是控制信号<ul>
<li>控制如何修改PC得到下一条指令的地址</li>
<li>控制ALU执行什么运算</li>
<li>控制主存进行读操作还是写操作</li>
</ul>
</li>
<li>CPU和主存之间通过一组总线相连，总线中有地址、控制、数据3组信号线</li>
</ul>
</li>
</ul>
<p><strong>计算机软件</strong></p>
<ul>
<li><p>软件分类</p>
<ul>
<li>系统软件<ul>
<li>操作系统 Operating System</li>
<li>数据库管理系统 DBMS</li>
<li>语言处理程序</li>
<li>分布式软件系统</li>
<li>网络软件系统</li>
<li>标准库系统</li>
<li>服务性程序</li>
</ul>
</li>
<li>应用软件</li>
</ul>
</li>
<li>数据库管理系统（DBMS）和数据库系统（DBS）不一样<ul>
<li>DBMS是位于用户和操作系统之间的一层数据管理软件，是系统软件</li>
<li>DBS是指计算机系统引入数据库后的系统，一般由数据库、数据库管理系统、数据库管理员（DBA）和应用系统构成</li>
</ul>
</li>
<li>三个级别的语言<ul>
<li>机器语言——计算机唯一可以直接识别和执行的语言</li>
<li>汇编语言</li>
<li>高级语言</li>
</ul>
</li>
<li>翻译程序<ul>
<li>汇编程序（汇编器）——汇编语言 —&gt; 机器语言</li>
<li>解释程序（解释器）——将源程序中的语句逐条翻译成机器指令并立即执行——速度较慢</li>
<li>编译程序（编译器）——高级语言 —&gt; 汇编语言/机器语言——编译时间较长，运行速度较快</li>
</ul>
</li>
<li>软件和硬件的逻辑等价性<ul>
<li>硬件实现的往往是最基本的算术和逻辑运算功能</li>
</ul>
</li>
</ul>
<p><strong>计算机系统的层次结构</strong></p>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/202308232315086.png" alt="image-20230823231515391"></p>
<ul>
<li><p>计算机系统的多级层次结构 ↓ </p>
<ul>
<li><p>第1级：微程序机器层——硬件层，由机器硬件直接执行微程序</p>
</li>
<li><p>第2级：传统机器语言层——机器层，由微程序解释机器指令系统</p>
</li>
<li><p>第3级：操作系统层</p>
</li>
<li><p>第4级：汇编语言层</p>
</li>
<li><p>第5级：高级语言层</p>
</li>
<li>~应用程序层~</li>
</ul>
</li>
<li><p>裸机——没有配备软件的纯硬件系统</p>
</li>
<li><p>指令集体系结构（ISA）——软件和硬件之间的界面</p>
</li>
</ul>
<p><strong>计算机系统的工作原理</strong></p>
<ul>
<li>“存储程序”工作方式<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202308232320099.png" alt="image-20230823232031745"></li>
<li>执行前，需要将程序所含的指令和数据送入主存</li>
<li>指令执行过程：<ul>
<li>从主存取地址</li>
<li>对指令进行译码</li>
<li>计算下条指令地址</li>
<li>取操作数并执行</li>
<li>将结果送回存储器</li>
</ul>
</li>
</ul>
</li>
<li>从源程序到可执行文件<ul>
<li>预处理阶段</li>
<li>编译阶段</li>
<li>汇编阶段</li>
<li>链接阶段</li>
</ul>
</li>
<li>指令执行过程的描述（以取数指令为例）<ul>
<li>取指令：PC→MAR→M→MDR→IR</li>
<li>分析指令：OP(IR)→CU</li>
<li>执行指令：Ad(IR)→MAR→M→MDR→ACC</li>
</ul>
</li>
<li>注意：(PC)指程序计数器PC中存放的内容<code>PC -&gt; MAR</code> 应该理解为<code>(PC)-&gt;MAR</code></li>
<li>（PC）指PC寄存器存放的地址指向的数据</li>
</ul>
<h2 id="1-3-计算机的性能指标"><a href="#1-3-计算机的性能指标" class="headerlink" title="1.3 计算机的性能指标"></a>1.3 计算机的性能指标</h2><ul>
<li>计算机的主要性能指标<ul>
<li>机器字长:——一般等于内部寄存器的大小，越长数据表示范围越大，计算精度越高</li>
<li>数据通路带宽——数据总线一次所能并行传送信息的位数</li>
<li>主存容量</li>
<li>运算速度<ul>
<li>吞吐量——系统在单位事件内处理请求的数量<ul>
<li>评价计算机性能的综合参数</li>
</ul>
</li>
<li>响应时间</li>
<li>CPU时钟周期 = 1 / 主频</li>
<li>CPI ——执行一条指令所需的时钟周期数</li>
<li>CPU执行时间 = CPU时钟周期数 / 主频 = （指令条数 × CPI）/ 主频<ul>
<li>上式表明，CPU的性能取决于：主频（时钟频率）、CPI、指令条数</li>
</ul>
</li>
<li>MIPS  每秒执行多少百万条命令</li>
<li>MFLOPS 每秒执行多少百万次浮点运算<ul>
<li>GFLOPS 每秒执行多少十亿次浮点运算</li>
<li>TFLOPS 每秒执行多少万亿次浮点运算</li>
<li>PFLOPS  10e15</li>
<li>EFLOPS  10e18</li>
<li>ZFLOPS  10e21</li>
</ul>
</li>
</ul>
</li>
<li>基准程序（Benchmarks）<ul>
<li>专门用来进行性能评价的一组程序，能够很好地反映机器在运行实际负载时的性能</li>
</ul>
</li>
</ul>
</li>
<li>几个专业术语<ul>
<li>系列机<ul>
<li>具有相同的体系结构，使用相同基本指令系统的多个不同型号的计算机组成的一个产品系列</li>
</ul>
</li>
<li>兼容<ul>
<li>软件或硬件的通用性</li>
</ul>
</li>
<li>软件可移植性</li>
<li>固件<ul>
<li>将程序固定在ROM中组成的部件称为固件</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计网-第三章-数据链路层</title>
    <url>/2023/09/21/%E8%AE%A1%E7%BD%91-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    <content><![CDATA[<h1 id="3-1-数据链路层的功能"><a href="#3-1-数据链路层的功能" class="headerlink" title="3.1 数据链路层的功能"></a>3.1 数据链路层的功能</h1><ul>
<li>数据链路层在物理层提供服务的基础上<strong><em>向网络层提供服务</em></strong>，其主要作用是<strong><em>加强物理层传输原始比特流</em></strong>，将物理层提供的可能出错的物理连接改造为<strong><em>逻辑上无差错的数据链路</em></strong>，使之对网络层表现为一条无差错的链路</li>
</ul>
<span id="more"></span>
<ul>
<li><p>为网络层提供服务</p>
<ul>
<li><p>无确认的无连接服务</p>
<ul>
<li>源机器发送数据帧时不需先建立链路连接，目的机器收到数据帧时不需发回确认</li>
<li>对丢失的帧，数据链路层不负责重发而交给上层处理</li>
<li><p>适用于实时通信或误码率较低的通信信道，如以太网</p>
</li>
<li><p>有确认的无连接服务</p>
<ul>
<li>源机器发送数据帧时不需先建立链路连接，但目的机器收到数据帧时必须发回确认</li>
<li>源机器在所规定的时间内未收到确定信号时，就重传丢失的帧，以提高传输的可靠性</li>
<li>适用于误码率较高的通信信道，如无线通信</li>
</ul>
</li>
</ul>
</li>
<li><p>有确认的面向连接服务</p>
<ul>
<li>帧传输过程分为三个阶段：建立数据链路、传输帧、释放数据链路<ul>
<li>目的机器对收到的每一帧都要给出确认，源机器收到确认后才能发送下一帧，因而该服务的可靠性最高</li>
<li>适用于通信要求（可靠性、实时性）较高的场合</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>链路管理</p>
<ul>
<li><p>数据链路层的建立、维持和释放过程</p>
</li>
<li><p>主要用于面向连接的服务</p>
</li>
</ul>
</li>
<li><p>帧定界、帧同步与透明传输</p>
<ul>
<li>将网络层的分组封装成帧，以帧的格式进行传送，将一段数据的前后分别添加首部和尾部，就构成了帧，帧长等于数据部分的长度加上首部和尾部的长度</li>
<li>首部和尾部中含有很多控制信息。它们的一个重要作用是确定帧的界限，即帧定界</li>
<li>帧同步指接收方应能从接收到的二进制比特流中区分出帧的起始和终止</li>
<li>为了提高帧的传输效率，应当使帧的数据部分的长度尽可能地大于首部和尾部的长度，但每种数据协议都规定了帧的数据部分的长度上限——最大传送单元（MTU）</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309222132045.png" alt="image-20230922213203136"></li>
<li>透明传输就是不管所传数据是什么样的比特组合，都应当能在链路上传送</li>
</ul>
</li>
<li><p>流量传输</p>
<ul>
<li>流量控制就是限制发送方的数据流量，使其发送速率不超过接收方的接收能力</li>
<li>对于数据链路层来说，控制的是相邻两结点之间数据链路上的流量</li>
<li>对于传输层，控制的则是源端到目的端之间的流量</li>
</ul>
</li>
<li><p>差错控制</p>
<ul>
<li>使发送方确定接收方是否正确收到由其发送的数据的方法</li>
<li>位错<ul>
<li>指帧中的某些位出现了差错</li>
<li>ARQ法<ul>
<li>使用循环冗余校验（CRC）发现位错</li>
<li>通过自动重传请求（ARQ）来重传出错的帧</li>
<li>让发送方将要发送的数据帧附加一定的CRC冗余检错码一并发送，接收方则根据检错码对数据帧进行错误检测，若发现错误则丢弃，发送方超时重传该数据帧</li>
</ul>
</li>
</ul>
</li>
<li>帧错<ul>
<li>指帧的丢失、重复或失序等错误</li>
<li>在数据链路层引入定时器和编号机制——保证每一帧最终都能有且仅有一次正确地交付给目的结点</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="3-2-组帧"><a href="#3-2-组帧" class="headerlink" title="3.2 组帧"></a>3.2 组帧</h1><h3 id="3-2-1-字符计数法"><a href="#3-2-1-字符计数法" class="headerlink" title="3.2.1 字符计数法"></a>3.2.1 字符计数法</h3><ul>
<li>在帧头部使用一个计数字段来标明内帧内字符数</li>
<li>目的结点的数据链路层收到字节计数值时，就知道后面跟随的字节数，从而可以确定帧结束的位置</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309222209597.png" alt="image-20230922220908571"></li>
<li>如果计数字段出错，即失去了帧边界划分的依据，那么接收方就无法判断所传输帧的结束未和下一帧的开始位，收发双方将失去同步</li>
</ul>
<h3 id="3-2-2-字符填充的首尾定界符法"><a href="#3-2-2-字符填充的首尾定界符法" class="headerlink" title="3.2.2 字符填充的首尾定界符法"></a>3.2.2 字符填充的首尾定界符法</h3><ul>
<li>使用特殊字符来定界一帧的开始和结束</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309222214822.png" alt="image-20230922221440844"><ul>
<li>控制字符SOH放在帧的最前面，表示真的首部开始</li>
<li>控制字符EOT表示帧的结束</li>
<li>在特殊字符前面填充转义字符（ESC）来加以区分</li>
</ul>
</li>
</ul>
<h3 id="3-2-3-零比特填充的首尾标志法"><a href="#3-2-3-零比特填充的首尾标志法" class="headerlink" title="3.2.3 零比特填充的首尾标志法"></a>3.2.3 零比特填充的首尾标志法</h3><ul>
<li>允许数据帧包含任意个数的比特，也允许每个字符的编码包含任意个数的比特</li>
<li>使用一个特定的比特模式，即01111110来标志一帧的开始和结束</li>
<li>发送方的数据链路层在信息位中遇到五个连续的“1”时，将自动在其后面插入一个“0”，而接收方做该过程的逆操作</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309222218806.png" alt="image-20230922221827014"></li>
<li>很容易由硬件来实现，性能优于字符填充法</li>
</ul>
<h3 id="3-2-4-违规编码法"><a href="#3-2-4-违规编码法" class="headerlink" title="3.2.4 违规编码法"></a>3.2.4 违规编码法</h3><ul>
<li>在物理层进行比特编码时，通常采用违规编码法</li>
<li>例如，曼彻斯特编码方法将数据比特“1”编码成“高-低”电平对，将数据比特“0”编码成“低-高”电平对，而“高-高”电平对和“低-低”电平对在数据比特中是违规的（即没有采用）；可以借用这些违规编码序列来定界帧的起始和终止；局域网 IEEE 802标准就采用了这种方法</li>
<li>违规编码法不需要采用任何填充技术，便能实现数据传输的透明性，但它只适用于采用冗余编码的特殊编码环境</li>
<li>由于字符计数法中计数字段的脆弱性和字符填充法实现上的复杂性与不兼容性，目前较常用的组帧方法是零比特填充法和违规编码法</li>
</ul>
<h1 id="3-3-差错控制"><a href="#3-3-差错控制" class="headerlink" title="3.3 差错控制"></a>3.3 差错控制</h1><ul>
<li>概括来说，传输中的差错都是由于噪声引起的<ul>
<li>全局性<ul>
<li>由于线路本身电器特性所产生的随机噪声（热噪声），是信道固有的，随机存在的</li>
<li>解决——提高信噪比</li>
</ul>
</li>
<li>局部性<ul>
<li>外界特定的短暂原因所造成的冲击噪声，是产生差错的主要原因</li>
<li>解决——利用编码技术</li>
</ul>
</li>
</ul>
</li>
<li>差错<ul>
<li>位错</li>
<li>帧错</li>
</ul>
</li>
</ul>
<h3 id="3-3-1-检错编码"><a href="#3-3-1-检错编码" class="headerlink" title="3.3.1 检错编码"></a>3.3.1 检错编码</h3><h4 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h4><ul>
<li>是计校验码和偶校验码的统称，是一种最基本的检错码</li>
<li>由n-1位信息元和1位校验元组成<ul>
<li>奇校验码<ul>
<li>添加一个校验元后，码长位n的码字中“1”的个数为奇数</li>
</ul>
</li>
<li>偶校验码<ul>
<li>添加一个校验元后，码长位n的码字中“1”的个数为偶数</li>
</ul>
</li>
</ul>
</li>
<li>只能检查出一个/奇数个错误</li>
</ul>
<h4 id="循环冗余码（CRC）"><a href="#循环冗余码（CRC）" class="headerlink" title="循环冗余码（CRC）"></a>循环冗余码（CRC）</h4><ul>
<li>又称多项式码</li>
<li>原理<ul>
<li>给定一个<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.986ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 878 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container>bit的帧或报文，发送器生成一个rbit的序列，称为帧检验序列（FCS）</li>
<li>这样所形成的帧将有m+r比特组成</li>
<li>发送方和接收方事先商定一个多项式<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.833ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2136 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path></g><g data-mml-node="mo" transform="translate(786,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1175,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(1747,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>（最高位和最低为必须为1），使这个带检验码的帧刚好能被预先确定的多项式<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.833ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2136 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path></g><g data-mml-node="mo" transform="translate(786,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1175,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(1747,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>整除</li>
<li>接收方用相同的多项式去除收到的帧，如果无余数，那么认为无差错</li>
</ul>
</li>
<li>假设一个帧有m位，其对应的多项式位<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.833ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2136 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path></g><g data-mml-node="mo" transform="translate(786,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1175,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(1747,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>，计算冗余码的步骤<ul>
<li>加0<ul>
<li>假设<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.833ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2136 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path></g><g data-mml-node="mo" transform="translate(786,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1175,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(1747,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>的阶为r（位数减1），在帧的低位端上加上r个0</li>
</ul>
</li>
<li>模2除<ul>
<li>利用模2除法，用<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.833ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2136 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path></g><g data-mml-node="mo" transform="translate(786,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1175,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(1747,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>对应的数据串去除（1）中计算出的数据串，得到的余数即为冗余码（共r位，前面的0不可省略）</li>
<li>模2除法——加法不进位，减法不错位，刚好是异或操作</li>
</ul>
</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309231535869.png" alt="image-20230923153455699"></li>
</ul>
</li>
<li>通过循环冗余码的检错技术，数据链路层做到了对帧的无差错接收，也就是说，凡是接收端数据链路层接受的帧，我们都认为这些帧在传输过程中没有产生差错</li>
</ul>
<h3 id="3-3-2-纠错编码"><a href="#3-3-2-纠错编码" class="headerlink" title="3.3.2 纠错编码"></a>3.3.2 纠错编码</h3><ul>
<li>最常见的纠错编码是海明码</li>
<li>原理<ul>
<li>在有效的信息位中加入几个校验位形成海明码，并把海明码的每个二进制位分配到几个奇偶校验组中</li>
<li>当某一位出错后，就会引起有关的几个校验位的值发生变化，这不但可以发现错误，而且能指出错位的位置</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>确定海明码的位数<ul>
<li>设n为有效信息的位数，k为检验位的位数，则</li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.312ex;" xmlns="http://www.w3.org/2000/svg" width="14.368ex" height="2.244ex" role="img" focusable="false" viewBox="0 -853.7 6350.8 991.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(822.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1822.4,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mo" transform="translate(2621.2,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="msup" transform="translate(3677,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g><g data-mml-node="mo" transform="translate(4850.6,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(5850.8,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container></li>
<li>若要检测两位错，则需再增加1位校验位，即k+1位</li>
</ul>
</li>
<li>确定校验位的分布<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309231545790.png" alt="image-20230923154529865"></li>
</ul>
</li>
<li>分组以形成校验关系<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309231546757.png" alt="image-20230923154606823"></li>
</ul>
</li>
<li>校验位取值<ul>
<li>校验位<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.192ex" height="1.902ex" role="img" focusable="false" viewBox="0 -683 969 840.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mi" transform="translate(675,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container>的值为第i组（由该校验位校验的数据位）所有位求异或</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309231547686.png" alt="image-20230923154735838"></li>
</ul>
</li>
<li>海明码的校验原理<ul>
<li>每个校验组分别利用校验位和参与形成该校验位的信息位进行奇偶校验检查，构成k个校验方程</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309231549503.png" alt="image-20230923154929746"></li>
<li>若<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="7.124ex" height="1.97ex" role="img" focusable="false" viewBox="0 -705 3148.7 870.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path></g><g data-mml-node="mn" transform="translate(646,-150) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g></g><g data-mml-node="msub" transform="translate(1049.6,0)"><g data-mml-node="mi"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path></g><g data-mml-node="mn" transform="translate(646,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="msub" transform="translate(2099.1,0)"><g data-mml-node="mi"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path></g><g data-mml-node="mn" transform="translate(646,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></svg></mjx-container>的值为“000”，则说明无错</li>
<li>否则出错，且这个数就是错误位的位号</li>
</ul>
</li>
</ul>
<h1 id="3-4-流量控制与可靠传输机制"><a href="#3-4-流量控制与可靠传输机制" class="headerlink" title="3.4 流量控制与可靠传输机制"></a>3.4 流量控制与可靠传输机制</h1><h3 id="3-4-1-流量控制、可靠传输与滑动窗口机制"><a href="#3-4-1-流量控制、可靠传输与滑动窗口机制" class="headerlink" title="3.4.1 流量控制、可靠传输与滑动窗口机制"></a>3.4.1 流量控制、可靠传输与滑动窗口机制</h3><ul>
<li>流量控制的方法<ul>
<li>停止—等待协议</li>
<li>滑动窗口协议<ul>
<li>GBN协议</li>
<li>SR协议</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="停止—等待流量控制基本原理"><a href="#停止—等待流量控制基本原理" class="headerlink" title="停止—等待流量控制基本原理"></a>停止—等待流量控制基本原理</h4><ul>
<li>发送方每发送一帧，都要等待接收方的应答信号，之后才能发送下一帧，接收方每接收一阵，都要反馈一个应答信号，表示可以接收下一帧，如果接收方不反馈应答信号，那么发送方必须一直等待</li>
<li>每次只允许发送一帧，然后就陷入等待接收方确认信息的过程中，因而传输效率很低</li>
</ul>
<h4 id="滑动窗口流量控制基本原理"><a href="#滑动窗口流量控制基本原理" class="headerlink" title="滑动窗口流量控制基本原理"></a>滑动窗口流量控制基本原理</h4><ul>
<li>发送窗口<ul>
<li>发送方维持的一组连续的允许发送的序号</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309231604925.png" alt="image-20230923160442134"></li>
</ul>
</li>
<li>接收窗口<ul>
<li>接收方维持的一组允许接收帧的序号</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309231604052.png" alt="image-20230923160452837"></li>
</ul>
</li>
<li>特性<ul>
<li>只有接收窗口向前滑动（同时接收方发送了确认帧）时，发送窗口才有可能（只有发送方收到确认帧后才一定）向前滑动</li>
<li>从滑动窗口的概念看，停止-等待协议、后退 N 帧协议和选择重传协议只在发送窗口大小与接收窗口大小上有所差别：<ul>
<li>停止-等待协议：发送窗口大小=1，接收窗口大小=1</li>
<li>后退 N 帧协议：发送窗口大小&gt;1，接收窗口大小=1</li>
<li>选择重传协议：发送窗口大小&gt;1，接收窗口大小&gt;1</li>
</ul>
</li>
<li>接收窗口的大小位1时，可保证帧的有序接收</li>
<li>数据链路层的滑动窗口协议中，窗口的大小在传输过程中是固定的（注意与第5章传输层的滑动窗口协议的区别）</li>
</ul>
</li>
</ul>
<h4 id="可靠传输机制"><a href="#可靠传输机制" class="headerlink" title="可靠传输机制"></a>可靠传输机制</h4><ul>
<li>数据链路层的可靠传输通常使用确认和超时重传两种机制来完成</li>
</ul>
<hr>
<ul>
<li>确认<ul>
<li>一种无数据的控制帧，这种控制帧使得接收方可以让发送方知道哪些内容被正确接收</li>
<li>有些情况下为了提高传输效率，将确认捎带在一个回复帧中，称为捎带确认</li>
</ul>
</li>
<li>超时重传<ul>
<li>指发送方在发送某个数据帧后就开启一个计时器，在一定时间内如果没有得到发送的数据帧的确认帧，那么就重新发送该数据帧，知道发送成功为之</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>自动重传请求（ARQ）<ul>
<li>通过接收方请求发送方重传出错的数据帧来恢复出错的帧，是通信中用于处理信道所带来差错的方法之一</li>
<li>分为三种<ul>
<li>停止—等待 ARQ</li>
<li>后退N帧 ARQ</li>
<li>选择性重传 ARQ</li>
</ul>
</li>
<li>后两种协议是滑动窗口技术与请求重发技术的结合，由于窗口尺寸开到足够大时，帧在线路上可以连续地流动，因此又称其为连续ARQ协议</li>
</ul>
</li>
</ul>
<h3 id="3-4-2-单帧滑动窗口与停止—等待协议"><a href="#3-4-2-单帧滑动窗口与停止—等待协议" class="headerlink" title="3.4.2 单帧滑动窗口与停止—等待协议"></a>3.4.2 单帧滑动窗口与停止—等待协议</h3><ul>
<li>在停止-等待协议中，源站发送单个帧后必须等待确认，在目的站的回答到达源站之前，源站不能发送其他的数据帧</li>
<li>从滑动窗口机制的角度看，停止-等待协议相当于发送窗口和接收窗口大小均为1的滑动窗口协议</li>
</ul>
<hr>
<ul>
<li><p>在停止-等待协议中，除数据帧丢失外，还可能出现以下两种差错</p>
<ul>
<li>到达目的站的帧可能已遭破坏，接收站利用前面讨论的差错检测技术检出后，简单地将该帧丢弃。为了对付这种可能发生的情况，源站装备了计时器。在一个帧发送后，源站等待确认，若在计时器计满时仍未收到确认，就再次发送相同的帧。如此重复，直到该数据帧无错误地到达为止</li>
<li>数据帧正确而确认帧被破坏，此时接收方已收到正确地数据帧，但发送方收不到确认帧，因此发送方会重传已被接收的数据帧，接收方收到同样的数据帧时会丢弃该帧，并重传一个该帧对应的确认帧。发送的帧交替地用 0 和 1 来标识，确认帧分别用ACKO和ACK1来表示，收到的确认帧有误时，重传已发送的帧。对于停止-等待协议，由于每发送一个数据帧就停止并等待，因此用1bit来编号就已足够。在停止-等待协议中，若连续出现相同发送序号的数据帧，表明发送端进行了超时重传。连续出现相同序号的确认帧时，表明接收端收到了重复帧。</li>
</ul>
</li>
<li><p>设置一个帧缓冲区</p>
<ul>
<li>发送端在发送完数据帧时，必须在其发送缓存中保留此数据帧的副本，这样才能在出差错时进行重传。只有在收到对方发来的确认帧ACK时，方可清除此副本</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309231622105.png" alt="image-20230923162209366"></li>
</ul>
<h4 id="3-4-3-多帧滑动窗口与后退N帧协议（GBN）"><a href="#3-4-3-多帧滑动窗口与后退N帧协议（GBN）" class="headerlink" title="3.4.3 多帧滑动窗口与后退N帧协议（GBN）"></a>3.4.3 多帧滑动窗口与后退N帧协议（GBN）</h4><ul>
<li>在后退 N 帧式 ARQ 中，发送方无须在收到上一个帧的 ACK 后才能开始发送下一帧，而是可以连续发送帧</li>
<li>当接收方检测出失序的信息帧后，要求发送方重发最后一个正确接收的信息帧之后的所有未被确认的帧，或者当发送方发送了N个帧后，若发现该N个帧的前一个帧在计时器超时后仍未返回其确认信息，则该帧被判为出错或丢失，此时发送方就不得不重传该出错帧及随后的 N 个帧</li>
<li>换句话说，接收方只允许按顺序接收帧</li>
</ul>
<hr>
<ul>
<li>后退N帧协议的接收窗口为1，可以保证按序接收数据帧</li>
<li>若采用n比特对帧编号，发送窗口地尺寸<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="3.45ex" height="1.885ex" role="img" focusable="false" viewBox="0 -683 1524.8 833"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"></path></g><g data-mml-node="mi" transform="translate(977,-150) scale(0.707)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g></g></g></g></svg></mjx-container>应满足<ul>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="16.791ex" height="1.885ex" role="img" focusable="false" viewBox="0 -683 7421.6 833"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(777.8,0)"><path data-c="3C" d="M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z"></path></g><g data-mml-node="msub" transform="translate(1833.6,0)"><g data-mml-node="mi"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"></path></g><g data-mml-node="mi" transform="translate(977,-150) scale(0.707)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g></g><g data-mml-node="mo" transform="translate(3636.1,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="msup" transform="translate(4691.9,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="mo" transform="translate(5921.4,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(6921.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container></li>
<li>若过大，会造成接收方无法分辨新帧和旧帧</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>连续发送数据帧，提高了信道的利用率</li>
<li>在重传时又必须把原来已传送正确的数据帧进行重传（仅因为这些数据帧的前面有一个数据帧出了错），这种做法又使传送效率降低</li>
<li>因此，信道的传输质量很差导致误码率较大时，后退N帧协议不一定优于停止—等待协议</li>
</ul>
<hr>
<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309231630156.png" alt="image-20230923163020218"></li>
</ul>
<h4 id="3-4-4-多帧滑动窗口与选择重传协议（SR）"><a href="#3-4-4-多帧滑动窗口与选择重传协议（SR）" class="headerlink" title="3.4.4 多帧滑动窗口与选择重传协议（SR）"></a>3.4.4 多帧滑动窗口与选择重传协议（SR）</h4><ul>
<li>每个发送缓冲区对应一个计时器，当计时器超时时，缓冲区的帧就会重传</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309231642704.png" alt="image-20230923164242867"></li>
<li>使用了比上述其他协议更有效的差错处理策略，即一旦接收方怀疑帧出错，就会发一个否定帧NAK给发送方，要求发送方对NAK中指定的帧进行重传</li>
</ul>
<hr>
<ul>
<li>接收窗口和发送窗口尺寸都大于1</li>
<li>一般来说，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.373ex;" xmlns="http://www.w3.org/2000/svg" width="26.3ex" height="2.26ex" role="img" focusable="false" viewBox="0 -833.9 11624.6 998.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"></path></g><g data-mml-node="mi" transform="translate(977,-150) scale(0.707)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g></g><g data-mml-node="mi" transform="translate(1524.8,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(2402.8,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(2931.8,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(3781.6,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="msub" transform="translate(4837.4,0)"><g data-mml-node="mi"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"></path></g><g data-mml-node="mi" transform="translate(977,-150) scale(0.707)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g></g><g data-mml-node="mi" transform="translate(6401.1,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(7279.1,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(7808.1,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(8657.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="msup" transform="translate(9713.6,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1378,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></g></svg></mjx-container></li>
<li>过大接收方无法分辨时新的数据帧还是重传的数据帧</li>
<li>接收端要设置具有相当容量的缓冲区来暂存那些未按序正确收到的帧，缓冲区的数目等于窗口的大小</li>
</ul>
<hr>
<ul>
<li>信道的利用率=<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.876ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3923 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1070,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path></g></g><g data-mml-node="mi" transform="translate(1570,0)"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mo" transform="translate(2330,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2719,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path></g></g><g data-mml-node="mi" transform="translate(3219,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g></g></g></svg></mjx-container><ul>
<li>T，发送方从开始发送数据到收到第一个确认帧为之所需要的时间，称为一个发送周期</li>
<li>L，发送方在一个发送周期内共发送的比特量</li>
<li>C，发送方的数据传输速率</li>
</ul>
</li>
</ul>
<h1 id="3-5-介质访问控制"><a href="#3-5-介质访问控制" class="headerlink" title="3.5 介质访问控制"></a>3.5 介质访问控制</h1><ul>
<li>传输数据使用的两种链路<ul>
<li>点对点链路<ul>
<li>两个结点通过一个链路相连，没有第三者</li>
<li>常用于广域网</li>
</ul>
</li>
<li>广播式链路<ul>
<li>所有主机共享通信介质</li>
<li>常用于局域网</li>
</ul>
</li>
</ul>
</li>
<li>介质访问控制主要任务<ul>
<li>未使用介质的每个结点隔离来自同一信道上其他结点所传送的信号，以协调活动结点的传输</li>
</ul>
</li>
<li>介质访问控制子层<ul>
<li>用来决定广播信道中信道分配的协议</li>
</ul>
</li>
<li>常见的介质访问控制方法<ul>
<li>静态划分信道<ul>
<li>信道划分介质访问控制</li>
</ul>
</li>
<li>动态分配信道<ul>
<li>随机访问介质访问控制</li>
<li>轮询介质访问控制</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-5-1-信道划分介质访问控制"><a href="#3-5-1-信道划分介质访问控制" class="headerlink" title="3.5.1 信道划分介质访问控制"></a>3.5.1 信道划分介质访问控制</h3><ul>
<li><p>原理：将使用介质的每个设备与来自同一通信信道上的其他设备的通信隔离开来，把时域和频域资源合理地分配给网络上地其他设备</p>
</li>
<li><p>多路复用技术</p>
<ul>
<li>把多个信号组合在一条物理信道上进行传输，使得多个计算机或终端设备共享信道资源，提高信道利用率</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309241139220.png" alt="image-20230924113909353"></li>
</ul>
</li>
</ul>
<h4 id="频分多路复用-FDM"><a href="#频分多路复用-FDM" class="headerlink" title="频分多路复用 FDM"></a>频分多路复用 FDM</h4><ul>
<li>将多种基带信号调制到不同频率载波上，再叠加形成一个复合信号的多路复用技术</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309241208802.png" alt="image-20230924120841503"></li>
<li><p>每个子信道分配的带宽可不相同，但它们的总和必须不超过信道的总带宽，在实际应用中，为了防止子信道之间的干扰，相邻信道之间需要加入“保护频带”</p>
</li>
<li><p>优点</p>
<ul>
<li>充分利用了传输介质的带宽，系统效率较高</li>
<li>技术比较乘数，实现也比较容易</li>
</ul>
</li>
</ul>
<h4 id="时分多路复用-TDM"><a href="#时分多路复用-TDM" class="headerlink" title="时分多路复用 TDM"></a>时分多路复用 TDM</h4><ul>
<li>将一条物理信道时间分成若干时间片，轮流地分配给多个信号使用</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309241210594.png" alt="image-20230924121018816"></li>
<li>TDM帧实在物理层传送的比特流所划分的帧，标志一个周期</li>
<li>由于计算机数据的突发性，一个用户对已经分配到的子信道的利用率一般不高（分配给你，但你不一定用）</li>
<li>改进——统计时分多路复用（STDM）<ul>
<li>又称异步时分多路复用</li>
<li>采用STDM帧，STDM帧并不固定分配时隙，而按需动态地分配时隙，当终端有数据要传送时，才会分配到时间片，因此可以提高线路地利用率</li>
<li>个用户有了数据就随时发往集中器的输入缓存，然后集中器按顺序依次扫描输入缓存，把缓存中德数据放入STDM帧中，一个STDM帧满了就发出</li>
</ul>
</li>
</ul>
<h4 id="波分多路复用-WDM"><a href="#波分多路复用-WDM" class="headerlink" title="波分多路复用 WDM"></a>波分多路复用 WDM</h4><ul>
<li>即光的频分多路复用</li>
<li>在一根光纤中传输多种不同波长（频率）的光信号，由于波长不同，各路光信号互不干扰，最后在用波长分解复用器将各路波长分解出来</li>
<li>光波处于频谱的高频短，有很高的带宽，因而可以实现多路的波分复用</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309241947799.png" alt="image-20230924194754456"></li>
</ul>
<h4 id="码分多路复用-CDM"><a href="#码分多路复用-CDM" class="headerlink" title="码分多路复用 CDM"></a>码分多路复用 CDM</h4><ul>
<li>采用不同的编码来区分各路原始信号的一种复用方式</li>
<li>与FDM和TDM不同，即共享信道的频率，又共享时间</li>
</ul>
<hr>
<ul>
<li>码分多址 CDMA<ul>
<li>原理：每个比特时间再划分成m个短的时间槽，称为码片，通常m的值是64/128</li>
<li>每个站点被指派一个唯一的m位码片序列，发送1时发送它的码片序列，发送0时，发送该码片序列的反码</li>
<li>不同站点的码片序列要求相互正交</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>假设站点A的码片序列被指派为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="9.05ex" height="1.557ex" role="img" focusable="false" viewBox="0 -666 4000 688"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(1000,0)"></path><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(1500,0)"></path><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(2000,0)"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(2500,0)"></path><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(3000,0)"></path><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(3500,0)"></path></g></g></g></svg></mjx-container>，则A站发送<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="9.05ex" height="1.557ex" role="img" focusable="false" viewBox="0 -666 4000 688"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(1000,0)"></path><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(1500,0)"></path><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(2000,0)"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(2500,0)"></path><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(3000,0)"></path><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(3500,0)"></path></g></g></g></svg></mjx-container>就表示比特1，发送<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="9.05ex" height="1.557ex" role="img" focusable="false" viewBox="0 -666 4000 688"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(500,0)"></path><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(1000,0)"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(1500,0)"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(2000,0)"></path><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(2500,0)"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(3000,0)"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(3500,0)"></path></g></g></g></svg></mjx-container>就表示发送比特0</li>
<li>为了方便，将码片中的0写为-1，将1写为+1，因此A的码片序列为<ul>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="30.17ex" height="1.692ex" role="img" focusable="false" viewBox="0 -666 13335.1 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(778,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1500.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(2500.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(3222.7,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(4222.9,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(4945.1,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(5945.3,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(6667.6,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(7667.8,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(8390,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(9390.2,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(10112.4,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(11112.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(11834.9,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(12835.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container></li>
</ul>
</li>
<li>令向量S表示A站的码片向量，令T表示B站的码片向量，两个不同站的码片序列需正交，即<ul>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.798ex;" xmlns="http://www.w3.org/2000/svg" width="24.367ex" height="2.755ex" role="img" focusable="false" viewBox="0 -864.9 10770.3 1217.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path></g><g data-mml-node="mo" transform="translate(867.2,0)"><path data-c="22C5" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250Z"></path></g><g data-mml-node="mi" transform="translate(1367.4,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mo" transform="translate(2349.2,0)"><path data-c="2261" d="M56 444Q56 457 70 464H707Q722 456 722 444Q722 430 706 424H72Q56 429 56 444ZM56 237T56 250T70 270H707Q722 262 722 250T707 230H70Q56 237 56 250ZM56 56Q56 71 72 76H706Q722 70 722 56Q722 44 707 36H70Q56 43 56 56Z"></path></g><g data-mml-node="mfrac" transform="translate(3405,0)"><g data-mml-node="mn" transform="translate(353.6,394) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mi" transform="translate(220,-345) scale(0.707)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><rect width="820.8" height="60" x="120" y="220"></rect></g><g data-mml-node="munderover" transform="translate(4632.5,0)"><g data-mml-node="mo"><path data-c="2211" d="M61 748Q64 750 489 750H913L954 640Q965 609 976 579T993 533T999 516H979L959 517Q936 579 886 621T777 682Q724 700 655 705T436 710H319Q183 710 183 709Q186 706 348 484T511 259Q517 250 513 244L490 216Q466 188 420 134T330 27L149 -187Q149 -188 362 -188Q388 -188 436 -188T506 -189Q679 -189 778 -162T936 -43Q946 -27 959 6H999L913 -249L489 -250Q65 -250 62 -248Q56 -246 56 -239Q56 -234 118 -161Q186 -81 245 -11L428 206Q428 207 242 462L57 717L56 728Q56 744 61 748Z"></path></g><g data-mml-node="TeXAtom" transform="translate(1089,477.1) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="TeXAtom" transform="translate(1089,-285.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(345,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(1123,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g><g data-mml-node="msub" transform="translate(7085.8,0)"><g data-mml-node="mi"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path></g><g data-mml-node="mi" transform="translate(646,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="msub" transform="translate(8025.8,0)"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mi" transform="translate(617,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="mo" transform="translate(9214.5,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(10270.3,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></svg></mjx-container></li>
</ul>
</li>
<li>令向量T为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="31.93ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 14113.1 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mo" transform="translate(389,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1167,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1889.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(2889.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(3611.7,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(4611.9,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(5334.1,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(6334.3,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(7056.6,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(8056.8,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(8779,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(9779.2,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(10501.4,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(11501.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(12223.9,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(13224.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(13724.1,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container><ul>
<li>A向C发送数据1时，就发送向量<ul>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="31.93ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 14113.1 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mo" transform="translate(389,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1167,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1889.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(2889.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(3611.7,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(4611.9,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(5334.1,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(6334.3,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(7056.6,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(8056.8,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(8779,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(9779.2,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(10501.4,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(11501.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(12223.9,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(13224.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(13724.1,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></li>
</ul>
</li>
<li>B向C发送数据0时，就发送向量<ul>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="31.93ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 14113.1 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mo" transform="translate(389,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(1167,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1889.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(2889.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(3611.7,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(4611.9,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(5334.1,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(6334.3,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(7056.6,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(8056.8,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(8779,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(9779.2,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(10501.4,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(11501.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(12223.9,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(13224.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(13724.1,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></li>
</ul>
</li>
</ul>
</li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="29.135ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 12877.9 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path></g><g data-mml-node="mo" transform="translate(867.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1867.4,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mo" transform="translate(2849.2,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mo" transform="translate(3905,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(4294,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mtext" transform="translate(4794,0)"><path data-c="A0" d=""></path></g><g data-mml-node="mn" transform="translate(5044,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mtext" transform="translate(5544,0)"><path data-c="A0" d=""></path></g><g data-mml-node="mo" transform="translate(6016.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(7016.4,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mtext" transform="translate(7516.4,0)"><path data-c="A0" d=""></path></g><g data-mml-node="mn" transform="translate(7766.4,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mtext" transform="translate(8266.4,0)"><path data-c="A0" d=""></path></g><g data-mml-node="mn" transform="translate(8516.4,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mtext" transform="translate(9016.4,0)"><path data-c="A0" d=""></path></g><g data-mml-node="mo" transform="translate(9488.7,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(10488.9,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mtext" transform="translate(10988.9,0)"><path data-c="A0" d=""></path></g><g data-mml-node="mn" transform="translate(11238.9,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mtext" transform="translate(11738.9,0)"><path data-c="A0" d=""></path></g><g data-mml-node="mn" transform="translate(11988.9,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(12488.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container><ul>
<li>C获得A的数据<ul>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="14.82ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 6550.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path></g><g data-mml-node="mo" transform="translate(867.2,0)"><path data-c="22C5" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250Z"></path></g><g data-mml-node="mo" transform="translate(1367.4,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1756.4,0)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path></g><g data-mml-node="mo" transform="translate(2623.7,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(3623.9,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mo" transform="translate(4327.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(4994.7,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(6050.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container></li>
</ul>
</li>
<li>C获得B的数据<ul>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="16.714ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 7387.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mo" transform="translate(926.2,0)"><path data-c="22C5" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250Z"></path></g><g data-mml-node="mo" transform="translate(1426.4,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1815.4,0)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path></g><g data-mml-node="mo" transform="translate(2682.7,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(3682.9,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mo" transform="translate(4386.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(5053.7,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mo" transform="translate(6109.4,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(6887.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container></li>
<li>代表B发送的是一个反码向量，代表0</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>码分多路复用技术具有频谱利用率高、抗干扰能力强、保密性强、语言质量好等优点，还可以减少投资和降低运行成本，主要用于无线通信系统，特别时移动通信系统</li>
</ul>
<h3 id="3-5-2-随机访问介质访问控制"><a href="#3-5-2-随机访问介质访问控制" class="headerlink" title="3.5.2 随机访问介质访问控制"></a>3.5.2 随机访问介质访问控制</h3><ul>
<li>核心思想：胜利者通过争用获得信道，从而获得信息的发送权<ul>
<li>又称争用型协议</li>
</ul>
</li>
<li>所有用户能根据自己的意愿随机地发送信息，占用信道全部速率</li>
<li>实质上是一种将广播信道转化为点到点信道的行为<ul>
<li>信道划分机制——结点之间的通信要么共享空间，要么共享时间，要么两者都共享</li>
<li>随机访问控制机制——即不共享时间，也不共享空间</li>
</ul>
</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309242014636.png" alt="image-20230924201435823"></li>
</ul>
<h4 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a>ALOHA协议</h4><h5 id="纯ALOHA协议"><a href="#纯ALOHA协议" class="headerlink" title="纯ALOHA协议"></a>纯ALOHA协议</h5><ul>
<li>基本思想：当网络中的任何一个站点需要发送数据时，可以不进行任何检测就发送数据，如果在一段时间内未收到确认，那么该站点就认为传输过程中发生了冲突，发送站点需要等待一段时间后再发送数据，直至发送成功</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309242015085.png" alt="image-20230924201520607"></li>
<li>网络吞吐量很低</li>
<li>想发送数据就发送数据</li>
</ul>
<hr>
<ul>
<li>假设网络负载（<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="2.309ex" height="1.906ex" role="img" focusable="false" viewBox="0 -677 1020.6 842.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mn" transform="translate(617,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g></svg></mjx-container>时间内所有站点发送成功的和未成功而重传的帧数)为G</li>
<li>则纯ALOHA网络的吞吐量（<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="2.309ex" height="1.906ex" role="img" focusable="false" viewBox="0 -677 1020.6 842.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mn" transform="translate(617,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g></svg></mjx-container>时间内成功发送的平均帧数）为<ul>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="10.799ex" height="2.135ex" role="img" focusable="false" viewBox="0 -861.5 4773 943.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path></g><g data-mml-node="mo" transform="translate(922.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(1978.6,0)"><path data-c="1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path></g><g data-mml-node="msup" transform="translate(2764.6,0)"><g data-mml-node="mi"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="TeXAtom" transform="translate(499,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(778,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(1278,0)"><path data-c="1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path></g></g></g></g></g></svg></mjx-container></li>
</ul>
</li>
</ul>
<h5 id="时隙ALOHA协议"><a href="#时隙ALOHA协议" class="headerlink" title="时隙ALOHA协议"></a>时隙ALOHA协议</h5><ul>
<li>时隙ALOHA协议把所有各站在时间上同步起来，并将时间划分为一段段等长的时隙（Slot），规定只能在每个时隙开始时才能发送一个帧</li>
<li>避免了用户发送数据的随意性，减少了数据产生冲突的可能性，提高了信道的利用率</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309242019491.png" alt="image-20230924201919580"></li>
<li>时隙ALOHA网络的吞吐量S与网络负载的关系是<ul>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="9.999ex" height="2.135ex" role="img" focusable="false" viewBox="0 -861.5 4419.5 943.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path></g><g data-mml-node="mo" transform="translate(922.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(1978.6,0)"><path data-c="1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path></g><g data-mml-node="msup" transform="translate(2764.6,0)"><g data-mml-node="mi"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="TeXAtom" transform="translate(499,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(778,0)"><path data-c="1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path></g></g></g></g></g></svg></mjx-container></li>
<li>相比于纯ALOHA，吞吐量大了一倍</li>
</ul>
</li>
</ul>
<h4 id="CSMA协议"><a href="#CSMA协议" class="headerlink" title="CSMA协议"></a>CSMA协议</h4><ul>
<li>载波监听多路访问（CSMA）</li>
<li>思想：每个站点在发送前都先监听一下共用信道，发现信道空闲再发送，大大减低了冲突的可能，从而提高信道的利用率</li>
<li>实在ALOHA协议基础上提出的一种改进协议，主要区别是多了一个载波监听装置</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309242041583.png" alt="image-20230924204133648"></li>
</ul>
<h5 id="1—坚持CSMA"><a href="#1—坚持CSMA" class="headerlink" title="1—坚持CSMA"></a>1—坚持CSMA</h5><ul>
<li>基本思想：一个结点要发送数据时，首先监听信道；如果信道空闲，那么立即发送数据；如果信道忙，那么等待，同时继续监听直至信道空闲；如果发生冲突，那么随机等待一段时间后，再重新监听信道</li>
<li>”1—坚持“的含义<ul>
<li>监听到信道忙后，继续监听信道；监听到信道空闲时，发送帧的概率是1，即立刻发送数据</li>
</ul>
</li>
<li>传播时延对性能的影响<ul>
<li>结点A开始发送数据时，结点B也正好有数据要发送，但这时结点A发出数据的信号还未到达结点B，结点B监听到信道空闲，于是立即发送数据，结果必然导致冲突</li>
<li>即使不考虑延迟，1-坚持CSMA协议也可能产生冲突。例如，结点A正在发送数据时，结点B和C也准备发送数据，监听到信道忙，于是坚持监听，结果当结点A发送完毕，结点B和C就会立即发送数据，同样导致冲突</li>
</ul>
</li>
</ul>
<h5 id="非坚持CSMA"><a href="#非坚持CSMA" class="headerlink" title="非坚持CSMA"></a>非坚持CSMA</h5><ul>
<li>基本思想：一个结点要发送数据时，首先监听信道；如果信道空闲，那么立即发送数据；如果信道忙，那么放弃监听，等待一个随机的时间后再重复上述过程</li>
<li>监听到信道忙后就放弃监听，减低了多个结点等待信道空闲后同时发送数据导致冲突的概率，但也会增加数据再网络中的平均延时<ul>
<li>信道利用率的提高是以增加数据在网络中的延迟时间为代价的</li>
</ul>
</li>
</ul>
<h5 id="p—坚持CSMA"><a href="#p—坚持CSMA" class="headerlink" title="p—坚持CSMA"></a>p—坚持CSMA</h5><ul>
<li>基本思想：一个结点要发送数据时，首先监听信道；如果信道忙，就继续监听，直至信道空闲；如果信道空闲，那么以概率p发送数据，以概率1-p推迟到下一个时隙；如果下一个时隙信道仍然空闲，那么以概率p发送数据，以概率1-p推迟到下一个时隙</li>
<li>采用概率p发送数据<ul>
<li>降低1—坚持CSMA协议中多个结点检测到信道空闲后同时发送数据的冲突概率</li>
</ul>
</li>
<li>采用坚持“监听”<ul>
<li>试图克服非坚持CSMA协议中由于随机等待而造成的延迟时间较长的缺点</li>
</ul>
</li>
<li>是非坚持CSMA协议和1—坚持CSMA协议的折中方案</li>
</ul>
<h4 id="CSMA-CD协议"><a href="#CSMA-CD协议" class="headerlink" title="CSMA/CD协议"></a>CSMA/CD协议</h4><ul>
<li>载波监听多路访问/碰撞（CSMA/CD）协议是CSMA协议的改进方案，使用于总线型网络或半双工网络环境<ul>
<li>CS：载波监听，每个站点在发送前和发送中都必须不停地检测信道，在发送前检测信道是为了获得发送权，在发送中检测信道是为了及时发生先发送的数据是否产生了碰撞</li>
<li>MA：多点接入，表示许多计算机以多点接入的方式连接在一根总线上</li>
<li>CD：碰撞检测，就是边发送边监听，如果监听到了碰撞，就立刻停止数据发送，等待一段随机时间后，重新开始尝试发送数据</li>
</ul>
</li>
<li>“先听后发，边听边发，冲突停发，随机重发”</li>
</ul>
<hr>
<ul>
<li><p><img src="https://gitee.com/renmale-sztu/image/raw/master/202309251121815.png" alt="image-20230925112109533"></p>
</li>
<li><p>争用期</p>
<ul>
<li><p>站A在发送帧后至多经过时间<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.029ex;" xmlns="http://www.w3.org/2000/svg" width="2.301ex" height="1.536ex" role="img" focusable="false" viewBox="0 -666 1017 679"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D70F" d="M39 284Q18 284 18 294Q18 301 45 338T99 398Q134 425 164 429Q170 431 332 431Q492 431 497 429Q517 424 517 402Q517 388 508 376T485 360Q479 358 389 358T299 356Q298 355 283 274T251 109T233 20Q228 5 215 -4T186 -13Q153 -13 153 20V30L203 192Q214 228 227 272T248 336L254 357Q254 358 208 358Q206 358 197 358T183 359Q105 359 61 295Q56 287 53 286T39 284Z"></path></g></g></g></svg></mjx-container>（端到端传播时延的2倍）就能知道发送的帧有没有发生碰撞，因此把以太网端到端往返时间<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.029ex;" xmlns="http://www.w3.org/2000/svg" width="2.301ex" height="1.536ex" role="img" focusable="false" viewBox="0 -666 1017 679"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D70F" d="M39 284Q18 284 18 294Q18 301 45 338T99 398Q134 425 164 429Q170 431 332 431Q492 431 497 429Q517 424 517 402Q517 388 508 376T485 360Q479 358 389 358T299 356Q298 355 283 274T251 109T233 20Q228 5 215 -4T186 -13Q153 -13 153 20V30L203 192Q214 228 227 272T248 336L254 357Q254 358 208 358Q206 358 197 358T183 359Q105 359 61 295Q56 287 53 286T39 284Z"></path></g></g></g></svg></mjx-container>称为争用期</p>
</li>
<li><p>又称冲突窗口和碰撞窗口</p>
</li>
</ul>
</li>
<li><p>最短帧长</p>
<ul>
<li>争用期内可发送的数据长度</li>
<li>在争用期内如果检测到碰撞，站点就会停止发送，此时已发送出去的数据一定小于最短帧长，因此凡长度小于这个最短帧长的帧都是由于冲突而异常中止的无效帧</li>
<li>计算公式<ul>
<li>$最小帧长=总线传播时延<em>数据传输速率</em>2$</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>截断二进制指数退避算法<ul>
<li>确定基本退避时间，一般取两倍的总线端到端传播时延<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.029ex;" xmlns="http://www.w3.org/2000/svg" width="2.301ex" height="1.536ex" role="img" focusable="false" viewBox="0 -666 1017 679"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D70F" d="M39 284Q18 284 18 294Q18 301 45 338T99 398Q134 425 164 429Q170 431 332 431Q492 431 497 429Q517 424 517 402Q517 388 508 376T485 360Q479 358 389 358T299 356Q298 355 283 274T251 109T233 20Q228 5 215 -4T186 -13Q153 -13 153 20V30L203 192Q214 228 227 272T248 336L254 357Q254 358 208 358Q206 358 197 358T183 359Q105 359 61 295Q56 287 53 286T39 284Z"></path></g></g></g></svg></mjx-container>（即争用期）——<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.029ex;" xmlns="http://www.w3.org/2000/svg" width="2.301ex" height="1.561ex" role="img" focusable="false" viewBox="0 -677 1017 690"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D70F" d="M39 284Q18 284 18 294Q18 301 45 338T99 398Q134 425 164 429Q170 431 332 431Q492 431 497 429Q517 424 517 402Q517 388 508 376T485 360Q479 358 389 358T299 356Q298 355 283 274T251 109T233 20Q228 5 215 -4T186 -13Q153 -13 153 20V30L203 192Q214 228 227 272T248 336L254 357Q254 358 208 358Q206 358 197 358T183 359Q105 359 61 295Q56 287 53 286T39 284Z"></path></g></g></g></svg></mjx-container></li>
<li>定义参数k，它等于重传次数，但k不超过10，即<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="21.896ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 9678.2 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mo" transform="translate(798.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(1854.6,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(2732.6,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(3077.6,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(3677.6,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(3955.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">重</text></g><g data-mml-node="mi" transform="translate(4955.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">传</text></g><g data-mml-node="mi" transform="translate(5955.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">次</text></g><g data-mml-node="mi" transform="translate(6955.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">数</text></g><g data-mml-node="mo" transform="translate(7955.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mn" transform="translate(8400.2,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path></g><g data-mml-node="mo" transform="translate(9400.2,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g></g></g></svg></mjx-container></li>
<li>从离散的整数集合<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="19.891ex" height="2.497ex" role="img" focusable="false" viewBox="0 -853.7 8791.8 1103.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mn" transform="translate(278,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mo" transform="translate(778,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mn" transform="translate(1222.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1722.7,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mn" transform="translate(2167.3,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(2667.3,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mn" transform="translate(3112,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g><g data-mml-node="mo" transform="translate(3612,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mo" transform="translate(4056.7,0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"></path></g><g data-mml-node="mo" transform="translate(5395.3,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msup" transform="translate(5840,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g><g data-mml-node="mo" transform="translate(7013.6,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(8013.8,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(8513.8,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g></g></g></svg></mjx-container>中随机取出一个数r，重传所需退避的时间就是r倍的基本退避时间，即<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.029ex;" xmlns="http://www.w3.org/2000/svg" width="3.321ex" height="1.536ex" role="img" focusable="false" viewBox="0 -666 1468 679"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(951,0)"><path data-c="1D70F" d="M39 284Q18 284 18 294Q18 301 45 338T99 398Q134 425 164 429Q170 431 332 431Q492 431 497 429Q517 424 517 402Q517 388 508 376T485 360Q479 358 389 358T299 356Q298 355 283 274T251 109T233 20Q228 5 215 -4T186 -13Q153 -13 153 20V30L203 192Q214 228 227 272T248 336L254 357Q254 358 208 358Q206 358 197 358T183 359Q105 359 61 295Q56 287 53 286T39 284Z"></path></g></g></g></svg></mjx-container></li>
<li>当重传达到16次仍不能成功时，说明网络太拥挤，认为此帧永远无法正确发出，抛弃此帧并向高层报告出错</li>
</ul>
</li>
<li>使用截断二进制退避算法可使重传需要推迟的平均时间随重传次数的增大而增大（这也称动态退避），因而能降低发生碰撞的概率，有利于整个系统的稳定</li>
</ul>
<h4 id="CSMA-CA协议"><a href="#CSMA-CA协议" class="headerlink" title="CSMA/CA协议"></a>CSMA/CA协议</h4><ul>
<li>为什么需要CSMA/CA协议<ul>
<li>CSMA/CD协议无法应用于无线局域网<ul>
<li>接收信号的强度往往会远小于发送信号的强度，且在无线介质上信号强度的动态变化范围很大，因此若要实现碰撞检测，则硬件上的花费会过大</li>
<li>在无线通信中，并非所有的站点都能够听见对方，即存在“隐蔽站”问题</li>
</ul>
</li>
</ul>
</li>
<li>CA——碰撞避免<ul>
<li>并不是指协议可以完全避免碰撞，而是指协议的设计要尽量避免碰撞发生的概率</li>
<li>由于802.11无线局域网不使用碰撞检测，一旦站点开始发送一个帧，就会完全地发送该帧，但碰撞避免存在时仍然发送整个数据帧（尤其是长数据帧）会严重降低网络的效率，因此要采用碰撞避免即使来降低碰撞的可能性</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>802.11使用链路层确认/重传（ARQ）方案，即站点没通过无线局域网发送完一帧，就要在收到对方的确认帧后才能继续发送下一帧</p>
</li>
<li><p>802.11规定，所有的帧完成发送后，必须再等待一段很短的时间（继续监听）才能发送下一帧，这段时间称为帧间间隔（IFS），帧间间隔的长短取决于该站要发送的帧的类型</p>
</li>
<li>三种IFS<ul>
<li>SIFS（短IFS）<ul>
<li>最短的IFS，用来分隔属于依次对话的各帧，使用SIFS的帧类型有ACK帧、CTS帧、分片后的数据帧，以及所有回答AP探寻的帧等</li>
</ul>
</li>
<li>PIFS（点协调IFS）<ul>
<li>中等长度的IFS，在PCF操作中使用</li>
</ul>
</li>
<li>DIFS（分布式协调IFS）<ul>
<li>最长的IFS，用于异步帧竞争访问的时延</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>CSMA/CA退避算法<ul>
<li>信道从忙态变为空闲态时，任何一个帧要发送数据帧，不仅都要等待一个时间间隔，而且要进入争用窗口，计算随机退避时间以便再次试图接入信道，因此降低了碰撞发生的概率</li>
<li>当且仅当检测到信道空闲且这个数据帧是要发送的第一个数据帧时，才不适用退避算法</li>
</ul>
</li>
<li>使用退避算法的情况<ul>
<li>在发送第一个帧前检测到信道忙</li>
<li>每次重传</li>
<li>每次成功发送后要发送下一帧</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>CSMA/CA算法流程<ul>
<li>若站点最初要数据要发送（而不是发送不成功再进行重传），且检测到信道空闲，在等待时间DIFS后，就发送整个数据帧</li>
<li>否则，站点执行CSMA/CA退避算法，选取一个随机回退值，一旦检测到信道忙，退避计时器就保持不变，只要信道空闲，退避即使器就进行倒计时</li>
<li>当退避计时器减到0时（此时信道一定空闲），站点就发送整个帧并等待确认</li>
<li>发送站若收到确认，就知道已发送的帧被目的帧正确接收，这时如果要发送第二帧，就要从步骤2）开始，执行CSMA/CA退避算法，随机选定一段退避时间</li>
<li>若发送站在规定时间（由重传计时器控制）内没有收到确认帧ACK，就必须重传该帧，再次使用CSMA/CA协议争用该信道，直到收到确认，或经过若干次重传失败后放弃发送</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>处理隐蔽站问题：RTS和CTS</li>
<li>隐蔽站问题<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309251642697.png" alt="image-20230925164004553"></li>
<li>站A和B都在AP覆盖范围内，但A和B相距较远，彼此都听不见对方，当A和B检测到信道空闲时，都向AP发送数据，导致碰撞的发生</li>
</ul>
</li>
<li>避免<ul>
<li>802.11允许发送站对信道进行预约，源站要发送数据帧之前先广播一个很短的请求发送RTS控制帧，它包括源地址、目的地址和这次通信（含相应的确认帧）所持续的时间</li>
<li>若信道空闲，则AP广播一个允许发送CTS控制帧，它包括这次通信所需的持续时间（从RTS复制）</li>
</ul>
</li>
<li>CTS的作用<ul>
<li>给源站明确的发送许可</li>
<li>提示其它站点在预约期内不要发送</li>
</ul>
</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309251646488.png" alt="image-20230925164619672"></li>
<li>信道预约不是强制性规定，各站可以自己决定使用或不适用信道预约<ul>
<li>使用RTS和CTS帧会使网络的通信效率有所下降，但这两种帧都很短，与数据帧相比开销不大</li>
<li>若不使用，一旦发生碰撞导致数据帧重发，则浪费的时间更多</li>
<li>只有当数据帧长度超过某一数值时，使用RTS和CTS帧才比较有利</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>CSMA/CD于CSMA/CA的主要区别<ul>
<li>CSMA/CD可以检测冲突，但无法避免；CSMA/CA发送数据的同时不能检测信道上有无冲突，本结点出没有冲突并不意味着在接收结点处没有冲突，只能尽量避免</li>
<li>传输介质不同，CSMA/CD用于总线形以太网，CSMA/CA用于无线局域网</li>
<li>检测方式不同，CSMA/CD通过电缆中的电压变化来检测，而CSMA/CA采用能量检测、载波检测和能量载波混合检测三种检测信道空闲的方式</li>
</ul>
</li>
</ul>
<h3 id="3-5-3-轮询访问：令牌传递协议"><a href="#3-5-3-轮询访问：令牌传递协议" class="headerlink" title="3.5.3 轮询访问：令牌传递协议"></a>3.5.3 轮询访问：令牌传递协议</h3><ul>
<li>轮询访问<ul>
<li>用户不能随机地发送信息，而要通过一个集中控制地监控站，以循环方式轮询每个结点，再决定信道地分配</li>
<li>当某个结点使用信道时，其他结点都不能使用信道</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>令牌传递协议<ul>
<li>一个令牌（Token）沿着环形总线再各结点计算机间依次传递</li>
<li>令牌是一个特殊地MAC控制帧，本身不包含信息，仅控制信道的使用</li>
<li>当环上的一个站点洗完传送帧时，必须等待令牌，一旦收到令牌，站点便可启动发送帧</li>
<li>站点再发送完一帧后，应释放令牌</li>
<li>令牌再网环上是按顺序依次传递的，对入网计算机来说，访问权是公平的</li>
<li>不会发生冲突，令牌只有一个</li>
</ul>
</li>
<li>令牌传递过程<ul>
<li>网络空闲时，环路中只有令牌帧在循环传递</li>
<li>令牌传递到由数据要发送的站点时，该站点就修改令牌中的一个标志位，并在令牌中附加自己需要传输的数据，将令牌变成一个数据帧，然后将这个数据帧发送出去</li>
<li>数据帧沿着环路传输，接收到的站点一边转发数据，一边查看帧的目的地址，如果目的地址和自己的地址相同，那么接收站就复制该数据帧以便进一步处理</li>
<li>数据帧沿着环路传输，直到到达该帧的源站点，源站点收到自己发出去的帧后便不再转发，同时，通过检验返回的帧来查看数据传输过程中是否出错，若有错则重传</li>
<li>源站点传送完数据后，重新生成一个令牌，并传递给下一站点</li>
</ul>
</li>
<li>物理拓扑不必是一个环，令牌传递通路逻辑必须是一个环</li>
<li>适合负载很高的广播信道<ul>
<li>负载很高值多个结点在同一时刻发送数据概率很大</li>
</ul>
</li>
<li>即不共享时间，也不共享空间，实际上是在随机介质访问控制的基础上，限定了有权力发送数据的结点只能有一个</li>
</ul>
<h1 id="3-6-局域网"><a href="#3-6-局域网" class="headerlink" title="3.6 局域网"></a>3.6 局域网</h1><h3 id="3-6-1-局域网的基本概念和体系结构"><a href="#3-6-1-局域网的基本概念和体系结构" class="headerlink" title="3.6.1 局域网的基本概念和体系结构"></a>3.6.1 局域网的基本概念和体系结构</h3><ul>
<li>局域网<ul>
<li>在一个较小的物理范围内，将各种计算机、外部设备和数据库系统等通过双绞线、同轴电缆等连接介质互相连接起来，组成资源和信息共享的计算机互连网络</li>
</ul>
</li>
<li>特点<ul>
<li>为一个单位所拥有，且地理范围和站点数据均有限、</li>
<li>所有站点共享较高的纵带框（较高的数据传输速率）</li>
<li>较低的时延和较低的误码率</li>
<li>各站为平等而非主仆关系</li>
<li>能进行广播和组播</li>
</ul>
</li>
<li>主要有三个要素决定<ul>
<li>拓扑结构</li>
<li>传输介质</li>
<li>介质访问控制方式——最重要——决定局域网的技术特性</li>
</ul>
</li>
<li>常见的局域网拓扑结构<ul>
<li>星型结构</li>
<li>环形结构</li>
<li>总线型结构</li>
<li>星形和总线形结合的复合型结构</li>
</ul>
</li>
<li>使用双绞线、铜缆和光纤等多种传输介质，其中双绞线为主流传输介质</li>
<li>介质访问控制方法主要有CSMA/CD、令牌总线和令牌环，其中前两种方法主要用于总线形局域网，令牌环主要用于环形局域网</li>
<li>三种特殊的局域网拓扑<ul>
<li>以太网<ul>
<li>目前使用范围最广的局域网</li>
<li>逻辑拓扑是总线形结构</li>
<li>物理拓扑是星形或拓展星形结构</li>
</ul>
</li>
<li>令牌环<ul>
<li>IEEE 802.5</li>
<li>逻辑拓扑是环形结构</li>
<li>物理拓扑是星形结构</li>
</ul>
</li>
<li>FDDI<ul>
<li>光纤分布数字接口，IEEE 802.8</li>
<li>逻辑拓扑是环形结构</li>
<li>物理拓扑是双环结构</li>
</ul>
</li>
<li>ATM</li>
<li>无线局域网</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>IEEE 802标准定义的局域网参考模型只对应于OSI参考模型的数据链路层和物理层，并将数据链路层拆分为两个子层</li>
<li>逻辑链路控制（LLC）子层<ul>
<li>向网络层提供无确定无连接、面向连接、带确认无连接、告诉传送4种不同的连接服务类型</li>
</ul>
</li>
<li>媒体接入控制（MAC）子层<ul>
<li>存放与接入媒体有关的内容</li>
<li>向上层屏蔽对物理层访问的各种差异，提供对物理层的统一访问接口</li>
<li>功能<ul>
<li>组帧和拆卸帧</li>
<li>比特传输差错检测</li>
<li>透明传输</li>
</ul>
</li>
</ul>
</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309261144996.png" alt="image-20230926114352996"></li>
</ul>
<h3 id="3-6-2-以太网与IEEE-802-3"><a href="#3-6-2-以太网与IEEE-802-3" class="headerlink" title="3.6.2 以太网与IEEE 802.3"></a>3.6.2 以太网与IEEE 802.3</h3><ul>
<li>IEEE 802.3<ul>
<li>一种基带总线形的局域网标准，描述物理层和数据链路层的MAC子层的实现方法</li>
</ul>
</li>
<li>以太网逻辑上采用总线形拓扑结构，以太网中所有计算机共享同一条总线，信息以广播方式发送</li>
<li>以太网简化了通信流程并使用了CSMA/CD方式对总线进行访问控制，保证数据通信的方便性和可靠性</li>
<li>通常将802.3 局域网简称为以太网<ul>
<li>严格来讲应当是指符合DIX Ethernet V2标准地局域网</li>
</ul>
</li>
<li>以太网采用两项措施以简化通信<ul>
<li>采用无连接的工作方式，不对发送的数据帧编号，也不要求接收方发送确认，即以太网尽最大可能交付数据，提供的是不可靠服务，对于差错的纠正则有高层完成</li>
<li>发送的数据都使用曼彻斯特编码的信号，每个码元的中间出现一次电压转换，接收端利用这种电压转换方便地把位同步信号提取出来</li>
</ul>
</li>
</ul>
<h4 id="以太网的传输介质与网卡"><a href="#以太网的传输介质与网卡" class="headerlink" title="以太网的传输介质与网卡"></a>以太网的传输介质与网卡</h4><ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309261153366.png" alt="image-20230926115327375"><ul>
<li>逻辑上总线，物理上星形</li>
</ul>
</li>
<li><p>网络接口板</p>
<ul>
<li>又称网络适配器，或网络接口卡（NIC）</li>
<li>网卡上装有处理器和存储器，是工作在数据链路层的网络组件</li>
<li>网卡和局域网的通信是通过电缆或双绞线以串行方式进行的，而网卡和计算机的通信则是通过计算机主板上的I/O总线以并行方式进行</li>
<li>重要功能：进行数据的串并转换</li>
</ul>
</li>
<li><p>介质访问控制（MAC）地址（物理地址）</p>
<ul>
<li>每块网卡在出厂时携带的唯一代码</li>
<li>控制主机在网络上的数据通信</li>
</ul>
</li>
<li>网卡也工作在物理层<ul>
<li>只关注比特，不关注任何地址信息和高层协议信息</li>
</ul>
</li>
</ul>
<h4 id="以太网的MAC帧"><a href="#以太网的MAC帧" class="headerlink" title="以太网的MAC帧"></a>以太网的MAC帧</h4><ul>
<li>两种标准<ul>
<li>DIX Ethernet V2标准（即以太网V2标准）——常用</li>
<li>IEEE 802.3标准</li>
</ul>
</li>
<li>以太网V2的MAC帧格式<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309261203266.png" alt="image-20230926120301420"></li>
<li>前导码：使接收端与发送端时钟同步<ul>
<li>在帧前面插入的8字节可再分为两个字段：第一个字段共7字节，是前同步码，用来快速实现MAC帧的比特同步；第二个字节是帧开始定界符，表示后面的信息就是MAC帧</li>
</ul>
</li>
<li>地址：通常使用6字节地址</li>
<li>类型：2字节，指出数据域中携带的数据应交给哪个协议实体处理</li>
<li>数据：46~1500字节，包含高层的协议信息，由于CSMA/CD算法的限制，以太网帧必须满足最小长度要求64字节，数据较少时必须加以填充</li>
<li>填充：0~46字节，当帧太短时填充，使之达到64字节的最小长度</li>
<li>校验码（FCS）：4字节，校验范围从目的地址段到数据段的末尾，采用32位循环冗余码（CRC），不校验前导码</li>
</ul>
</li>
</ul>
<h4 id="高速以太网"><a href="#高速以太网" class="headerlink" title="高速以太网"></a>高速以太网</h4><ul>
<li>速率达到或超过100Mb/s的以太网称为高速以太网</li>
<li>100BASE-T以太网<ul>
<li>在双绞线上传送100Mb/s基带信号的星形拓扑结构以太网</li>
<li>使用CSMA/CD协议</li>
<li>即支持全双工方式，又支持半双工方式，全双工方式下不适用CSMA/CD协议（无冲突）</li>
</ul>
</li>
<li>吉比特以太网<ul>
<li>又称千兆以太网</li>
<li>允许在1Gb/s速率下用全双工和半双工两种方式工作</li>
<li>使用802.3协议规定的帧格式</li>
<li>在半双工方式下使用CSMA/CD协议</li>
<li>与10BASE-T和100BASE-T技术向后兼容</li>
</ul>
</li>
<li>10吉比特以太网<ul>
<li>保留了802.3标准规定的以太网最小和最大帧长，便于升级</li>
<li>使用光纤作为传输媒体</li>
<li>只工作在全双工方式</li>
<li>可扩展的，灵活的，易于安装，稳健性好</li>
</ul>
</li>
</ul>
<h3 id="3-6-3-IEEE-802-11-无线局域网"><a href="#3-6-3-IEEE-802-11-无线局域网" class="headerlink" title="3.6.3 IEEE 802.11 无线局域网"></a>3.6.3 IEEE 802.11 无线局域网</h3><h4 id="无线局域网的组成"><a href="#无线局域网的组成" class="headerlink" title="无线局域网的组成"></a>无线局域网的组成</h4><ul>
<li><p>有固定基础设置的无线局域网</p>
<ul>
<li><p>固定基础设施：预先建立的、能覆盖一定物理范围的固定基站</p>
</li>
<li><p>使用802.11系列标准</p>
<ul>
<li>使用星形拓扑结构</li>
<li>中心称为接入点（AP）</li>
<li>在MAC层使用CSMA/CA协议</li>
<li>使用该系列标准的局域网又称Wi-Fi</li>
</ul>
</li>
<li><p>802.11标准规定无线局域网的最小构件是基本服务集BSS</p>
<ul>
<li><p>一个基本服务集包括一个接入点和若干移动站，各站在本BSS内之间通信，或与本BSS外部站的通信，都必须通过本BSS的AP</p>
</li>
<li><p>AP就是基本服务集中的基站</p>
</li>
<li><p>安装AP时，必须位该AP分配一个不超过32字节的服务集标识符（SSID）和一个信道</p>
</li>
<li><p>SSID是指使用该AP的无线局域网的名字</p>
</li>
<li><p>一个基本服务集覆盖的地理范围称为一个基本服务区（BSA）</p>
</li>
</ul>
<hr>
<ul>
<li><p>基本服务集可通过AP连接到一个分配系统DS，然后再连接到另一个基本服务集，就构成一个扩展的服务集（ESS）</p>
</li>
<li><p>分配系统时扩展的服务集对上层的表现就像一个基本服务集一样</p>
</li>
<li><p>ESS还可以通过一种称为Portal（门户）的设备为无线用户提供到有限连接的以太网的接入</p>
</li>
<li><p><img src="https://gitee.com/renmale-sztu/image/raw/master/202309262043657.png" alt="image-20230926204301855"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>无固定基础设施的移动自组织网络</p>
<ul>
<li><p>又称自组网络</p>
</li>
<li><p>没有上述基本服务集中的AP，而是由一些平等状态的移动站相互通信组成的临时网络</p>
</li>
<li><p>各结点之间地位平等，中间结点都为转发结点，因此都具有路由器的功能</p>
</li>
<li><p><img src="https://gitee.com/renmale-sztu/image/raw/master/202309262046363.png" alt="image-20230926204616588"></p>
</li>
</ul>
<hr>
<ul>
<li><p>构成：一些可移动设备发现在它们附加还有其他的可移动设备，并且要求和其他移动设备进行通信。</p>
</li>
<li><p>自组网络中的每个移动站都要参与网络中其他移动站的路由的发现和维护，同时由移动站构成的网络拓扑可能随时间变化得很快，因此在固定网络中行之有效得一些路由选择协议对移动自组网络不适用</p>
</li>
</ul>
</li>
</ul>
<h4 id="802-11-局域网的MAC帧"><a href="#802-11-局域网的MAC帧" class="headerlink" title="802.11 局域网的MAC帧"></a>802.11 局域网的MAC帧</h4><ul>
<li>802.11帧共有三种类型，即数据帧、控制帧和管理帧</li>
<li>数据帧由三大部分组成<ul>
<li>MAC首部，共30字节（重点）</li>
<li>帧主体，即帧的数据部分</li>
<li>帧检验序列FCS是尾部</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309262058463.png" alt="image-20230926205821558"></li>
<li>MAC首部中最重要的是4各地址字段（都是MAC地址），前三个地址的内容取决于帧控制字段中的“去往AP”和“来自AP”这两个字段的数值，地址4用于自组网络</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309262100164.png" alt="image-20230926210042365"></li>
<li>举例<ul>
<li>现假定在一个 BSS 中的站 A 向站B发送数据帧。在站 A 发往接入点 AP 的数据帧的帧控制字段中“去往AP=1”而“来自AP=0”;地址 1 是AP的MAC地址，地址2 是 A的MAC 地址，地址 3 是 B 的 MAC 地址。注意，“接收地址”与“目的地址”并不等同</li>
<li>AP 接收到数据帧后，转发给站 B，此时在数据帧的帧控制字段中，“去往 AP=0”而“来自 AP=1”;地址 1 是 B 的MAC地址，地址 2 是 AP的MAC 地址，地址 3 是 A 的MAC地址。请注意，“发送地址”与“源地址”也不等同</li>
<li>更复杂的情况 → 课本P110</li>
</ul>
</li>
</ul>
<h4 id="3-6-4-VLAN基本概念与基本原理"><a href="#3-6-4-VLAN基本概念与基本原理" class="headerlink" title="3.6.4 VLAN基本概念与基本原理"></a>3.6.4 VLAN基本概念与基本原理</h4><ul>
<li>一个以太网是一个广播域，当一个以太网包含的计算机太多时，往往会导致<ul>
<li>以太网中出现大量的广播帧，特别是经常使用的ARP和DHCP协议</li>
<li>一个单位的不同部门共享一个局域网，对信息保密和安全不利</li>
</ul>
</li>
<li>VLAN<ul>
<li>一种将局域网内的设备划分成与物理位置无关的逻辑组的技术，这些逻辑组有某些共同的需求，每个VLAN是一个单独的广播域/不同的子网</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>802.3ac标准定义了支持VLAN的以太网帧格式的扩展</p>
</li>
<li><p><img src="https://gitee.com/renmale-sztu/image/raw/master/202309271100732.png" alt="image-20230927110001776"></p>
</li>
<li><p>VLAN标签</p>
<ul>
<li><p>插入在源地址字段和类型字段之间的一个4字节的标识符</p>
</li>
<li><p>用来指明发送该帧的计算机属于哪个虚拟局域网</p>
</li>
<li><p>插入VLAN标签的帧称为802.1Q帧</p>
</li>
<li><p>以太网的最大帧长从1518字节变为1522字节</p>
</li>
<li><p>前两个字节置为0x8100，表示这是一个802.1Q帧</p>
</li>
<li><p>后两个字节中，前四位无用，后12位是该VLAN的标识符VID，唯一标识该802.1Q帧属于哪个VLAN</p>
</li>
</ul>
</li>
<li><p>VID取值范围为0~4095，但0和4095都不用来表示VLAN，因此实际有效VID为1~4094</p>
</li>
<li><p>IEEE 802.1Q帧是由交换机来处理的，而不是由用户主机来处理（主机和交换机之间只交换普通的以太网帧）</p>
</li>
</ul>
<hr>
<ul>
<li>交换机上生成的各VLAN互不相通，需要借助路由器和三层交换机来实现通信</li>
<li>基于接口的VLAN技术<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309272100056.png" alt="image-20230927205601188"></li>
</ul>
</li>
<li>基于MAC地址的VLAN技术<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309272059347.png" alt="image-20230927205612009"></li>
</ul>
</li>
</ul>
<h1 id="3-7-广域网"><a href="#3-7-广域网" class="headerlink" title="3.7 广域网"></a>3.7 广域网</h1><h3 id="3-7-1-广域网的基本概念"><a href="#3-7-1-广域网的基本概念" class="headerlink" title="3.7.1 广域网的基本概念"></a>3.7.1 广域网的基本概念</h3><ul>
<li>广域网通常是指覆盖范围很广的长距离网络</li>
<li>是因特网的核心部分，其任务是长距离运送主机所发送的数据</li>
<li>广域网的通信子网主要使用分组交换技术，通信子网可以利用公共分组交换网、卫星通信网和无线分组交换网，将分布在不同地区的局域网或计算机系统互连起来，达到资源共享的目的</li>
</ul>
<hr>
<ul>
<li>广域网不等于互联网</li>
<li>互联网可以连接不同类型的网络（既可以连接局域网，又可以连接广域网），通常使用路由器来连接</li>
<li>局域网可以通过广域网与另一个相隔很远的局域网通信</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309272109395.png" alt="image-20230927210923413"></li>
<li>广域网由一些结点交换机及连接这些交换机的链路组成</li>
<li>结点交换机的功能是将分组存储并转发</li>
<li>结点交换机在单个网络中转发分组，而路由器在多个网络构成的互联网中转发分组</li>
</ul>
<hr>
<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309272112826.png" alt="image-20230927211216952"></li>
</ul>
<h3 id="3-7-2-PPP协议"><a href="#3-7-2-PPP协议" class="headerlink" title="3.7.2 PPP协议"></a>3.7.2 PPP协议</h3><ul>
<li>点对点协议</li>
<li>用来通过拨号或专线方式建立点对点连接发送数据，是其成为各种主机、网桥和路由器之间简单连接的一种共同的解决方案</li>
<li>只支持全双工通信</li>
<li>组成<ul>
<li>链路控制协议（LCP）<ul>
<li>一种扩展链路控制协议，用于建立、配置、测试和管理数据链路</li>
</ul>
</li>
<li>网络控制协议（NCP）<ul>
<li>PPP协议允许同时采用多种网络层协议，每个不同的网络层协议要用一个相应的NCP来配置，为网络层协议建立和配置逻辑连接</li>
</ul>
</li>
<li>一个将IP数据报封装到串行链路的方法</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>PPP帧</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309272116274.png" alt="image-20230927211604222"></li>
<li>前三个字段和最后一个字段<ul>
<li>标志字段（F）前后各占一个字节，为7E，出现在信息字段中，表示必须做字节填充</li>
<li>地址字段（A）规定为0xFF</li>
<li>控制字段（C）规定为0x03</li>
</ul>
</li>
<li>第四个字段是协议段<ul>
<li>说明信息段中运载的是什么种类的分组</li>
</ul>
</li>
<li>第五段是信息段<ul>
<li>大于等于0B</li>
<li>小于等于1500B</li>
</ul>
</li>
<li>第六个字段是帧检验序列（FCS）<ul>
<li>占2字节</li>
<li>循环冗余码检验中的冗余码</li>
<li>检验区包括地址字段、控制字段、协议字段和信息字段</li>
</ul>
</li>
<li>PPP协议面向字节，因而所有PPP帧的长度都是整数个字节</li>
</ul>
<hr>
<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309272124673.png" alt="image-20230927212404613"></li>
</ul>
<hr>
<ul>
<li>PPP协议的特点<ul>
<li>PPP提供差错检测但不提供纠错功能，只保证无差错接收（通过硬件进行CRC校验），是不可靠的传输协议</li>
<li>仅支持点对点的链路通信，不支持多点线路</li>
<li>只支持全双工通信</li>
<li>PPP的两端可以运行不同的网络层协议，但仍然可以使用同一个PPP进行通信</li>
<li>PPP是面向字节的，当信息字段出现和标志字段一致的比特组合时<ul>
<li>若PPP在异步线路（默认）：采用字符填充法</li>
<li>若在同步线路：采用硬件来完成比特填充</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-7-3-HDLC协议"><a href="#3-7-3-HDLC协议" class="headerlink" title="*3.7.3 HDLC协议"></a>*3.7.3 HDLC协议</h3><h1 id="3-8-数据链路层设备"><a href="#3-8-数据链路层设备" class="headerlink" title="3.8 数据链路层设备"></a>3.8 数据链路层设备</h1><h3 id="3-8-1-网桥的基本概念"><a href="#3-8-1-网桥的基本概念" class="headerlink" title="*3.8.1 网桥的基本概念"></a>*3.8.1 网桥的基本概念</h3><h3 id="3-8-2-局域网交换机"><a href="#3-8-2-局域网交换机" class="headerlink" title="3.8.2 局域网交换机"></a>3.8.2 局域网交换机</h3><h4 id="交换机的原理和特点"><a href="#交换机的原理和特点" class="headerlink" title="交换机的原理和特点"></a>交换机的原理和特点</h4><ul>
<li>又称以太网交换机，实质上就是一个多端口的网桥，工作在数据链路层</li>
<li><p>原理</p>
<ul>
<li>检测从以太网端口来的数据帧的源和目的地址的MAC（介质访问层）地址，然后与系统内部的动态查找表进行比较，若数据帧的源MAC地址不在查找表中，则将该地址加入查找表，并将数据帧转发给相应的目的端口</li>
</ul>
</li>
<li><p>用户通信时独占带宽</p>
</li>
<li>特点<ul>
<li>以太网交换机的每个端口都直接与单台主机相连，并且一般工作在全双工方式</li>
<li>以太网交换机能同时连接多对端口，使没对相互通信的主机都能像独占通信媒体那样，无碰撞地传输数据</li>
<li>是一种即插即用设备，其内部的帧的转发表是通过自学习算法自动地逐渐建立起来的</li>
<li>使用专用地交换结构芯片，交换速率较高</li>
<li>独占传输媒体地带宽</li>
</ul>
</li>
<li>两种交换模式<ul>
<li>直通式交换机<ul>
<li>只检查帧的目的地址，帧在接收后几乎能马上被传出去</li>
<li>速度快，但缺乏智能性和安全性</li>
<li>无法支持具有不同速率的端口的交换</li>
</ul>
</li>
<li>存储转发式交换机<ul>
<li>先将收到的帧缓存到告诉缓存器中，并检查数据是否正确</li>
<li>确认无误后通过查找表转换成输出端口将该帧发送出去</li>
<li>如果发现帧有错，那么就将其丢弃</li>
<li>可靠性高，并能支持不同速率端口间的交换</li>
<li>延迟较大</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="交换机的自学习功能"><a href="#交换机的自学习功能" class="headerlink" title="交换机的自学习功能"></a>交换机的自学习功能</h4><ul>
<li>过滤：决定一个帧是否应该转发到某个端口还是应该将其丢弃</li>
<li>转发：决定一个帧应该移动到哪个接口成为转发</li>
</ul>
<hr>
<ul>
<li>交换表<ul>
<li>帮助交换机实现过滤和转发</li>
<li>至少包含：一个MAC地址，连通该MAC地址的交换机端口</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309272258422.png" alt="image-20230927225849604"></li>
<li>交换表中的没个表项都设有一定的有效时间，过期的表项会自动删除<ul>
<li>交换机所连的主机会随时变化</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
</search>
