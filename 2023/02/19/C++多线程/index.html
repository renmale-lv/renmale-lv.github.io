<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.14.2","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"order":-1}},"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="一、并发、进程、线程1 概念并发：两个或者更多的任务同时发生（实际上是多个任务轮流占有处理器），某一时刻只能执行一个任务：由于操作系统调度，每秒钟进行多次所谓的“任务切换”，这种切换（上下文切换）死有时间开销的。    1234并发是指一个处理器同时处理多个任务并行是指多个处理器或者是多核的处理器同时处理多个不同的任务并发是逻辑上的同时发生，而并行是物理上的同时发生并发是一个人同时吃三个馒头，">
<meta property="og:type" content="article">
<meta property="og:title" content="C++多线程">
<meta property="og:url" content="http://example.com/2023/02/19/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="renmale-lv blog">
<meta property="og:description" content="一、并发、进程、线程1 概念并发：两个或者更多的任务同时发生（实际上是多个任务轮流占有处理器），某一时刻只能执行一个任务：由于操作系统调度，每秒钟进行多次所谓的“任务切换”，这种切换（上下文切换）死有时间开销的。    1234并发是指一个处理器同时处理多个任务并行是指多个处理器或者是多核的处理器同时处理多个不同的任务并发是逻辑上的同时发生，而并行是物理上的同时发生并发是一个人同时吃三个馒头，">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/img/202302272053004.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/img/202302282054227.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/img/202303022218967.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/img/202303032034746.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/img/202303062233589.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/img/202303072132660.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/img/202303072134323.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/img/202303090958114.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/img/202303072336262.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/img/202303072339137.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/img/202303091013309.png">
<meta property="article:published_time" content="2023-02-19T09:57:15.000Z">
<meta property="article:modified_time" content="2023-03-09T02:31:02.000Z">
<meta property="article:author" content="renmale-lv">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/renmale-sztu/image/raw/master/img/202302272053004.png">


<link rel="canonical" href="http://example.com/2023/02/19/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2023/02/19/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B/","path":"2023/02/19/C++多线程/","title":"C++多线程"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>C++多线程 | renmale-lv blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="renmale-lv blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">renmale-lv blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记录学习点滴</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%B9%B6%E5%8F%91%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">一、并发、进程、线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.</span> <span class="nav-text">1 概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%B9%B6%E5%8F%91%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.</span> <span class="nav-text">2 并发的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%91"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1多进程并发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2多线程并发</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E7%BB%93%E6%9D%9F"><span class="nav-number">2.</span> <span class="nav-text">二、线程的启动和结束</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#thread-amp-join"><span class="nav-number">2.1.</span> <span class="nav-text">thread &amp; join</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#detach"><span class="nav-number">2.2.</span> <span class="nav-text">detach</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#joinable"><span class="nav-number">2.3.</span> <span class="nav-text">joinable</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#thread%E4%BC%A0%E5%85%A5%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="nav-number">2.4.</span> <span class="nav-text">thread传入函数参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8%E6%9D%A5%E8%BF%9B%E8%A1%8C%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="nav-number">2.5.</span> <span class="nav-text">使用指针&#x2F;引用来进行参数传递</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%B1%BB%E6%9D%A5%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.6.</span> <span class="nav-text">使用类来创建线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E7%BA%BF%E7%A8%8B%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="nav-number">2.7.</span> <span class="nav-text">使用成员函数作为线程入口函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%BA%BF%E7%A8%8B%E7%B1%BB"><span class="nav-number">2.8.</span> <span class="nav-text">封装一个简易线程类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">2.9.</span> <span class="nav-text">使用lambda表达式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%92%8C%E5%90%8C%E6%AD%A5"><span class="nav-number">3.</span> <span class="nav-text">三、多线程通信和同步</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-number">3.1.</span> <span class="nav-text">1 多线程状态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%AF%B4%E6%98%8E"><span class="nav-number">3.1.1.</span> <span class="nav-text">1.1 线程状态说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E7%AB%9E%E4%BA%89%E7%8A%B6%E6%80%81%E5%92%8C%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="nav-number">3.1.2.</span> <span class="nav-text">1.2 竞争状态和临界区</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%BA%92%E6%96%A5%E4%BD%93%E5%92%8C%E9%94%81mutex"><span class="nav-number">3.2.</span> <span class="nav-text">2 互斥体和锁mutex</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E4%BA%92%E6%96%A5%E9%94%81-mutex"><span class="nav-number">3.2.1.</span> <span class="nav-text">2.1 互斥锁 mutex</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E4%BD%BF%E7%94%A8%E9%94%81%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">不使用锁的情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%94%81"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">使用锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#try-lock"><span class="nav-number">3.2.1.3.</span> <span class="nav-text">try_lock</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E5%9D%91-%E7%BA%BF%E7%A8%8B%E6%8A%A2%E5%8D%A0%E4%B8%8D%E5%88%B0%E8%B5%84%E6%BA%90"><span class="nav-number">3.2.2.</span> <span class="nav-text">2.2 互斥锁的坑_线程抢占不到资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E8%B6%85%E6%97%B6%E9%94%81-timed-mutex"><span class="nav-number">3.2.3.</span> <span class="nav-text">2.3 超时锁 timed_mutex</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E9%80%92%E5%BD%92%E9%94%81-%E5%8F%AF%E9%87%8D%E5%85%A5-recursive-mutex-%E5%92%8C-recursive-timed-mutex"><span class="nav-number">3.2.4.</span> <span class="nav-text">2.4 递归锁(可重入) recursive_mutex 和 recursive_timed_mutex</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E5%85%B1%E4%BA%AB%E9%94%81-shared-mutex"><span class="nav-number">3.2.5.</span> <span class="nav-text">2.5 共享锁 shared_mutex</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-std-call-once"><span class="nav-number">3.2.6.</span> <span class="nav-text">2.6 std::call_once</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="renmale-lv"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">renmale-lv</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/19/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="renmale-lv">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="renmale-lv blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="C++多线程 | renmale-lv blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++多线程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-02-19 17:57:15" itemprop="dateCreated datePublished" datetime="2023-02-19T17:57:15+08:00">2023-02-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-03-09 10:31:02" itemprop="dateModified" datetime="2023-03-09T10:31:02+08:00">2023-03-09</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>9k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>8 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <meta name="referrer" content="no-referrer" />

<h1 id="一、并发、进程、线程"><a href="#一、并发、进程、线程" class="headerlink" title="一、并发、进程、线程"></a>一、并发、进程、线程</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h2><p><strong>并发</strong>：两个或者更多的任务<del>同时发生</del>（实际上是多个任务轮流占有处理器），某一时刻只能执行一个任务：由于操作系统调度，每秒钟进行多次所谓的“任务切换”，这种切换（上下文切换）死有时间开销的。  </p>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202302272053004.png" alt="img"></p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">并发是指一个处理器同时处理多个任务</span><br><span class="line">并行是指多个处理器或者是多核的处理器同时处理多个不同的任务</span><br><span class="line">并发是逻辑上的同时发生，而并行是物理上的同时发生</span><br><span class="line">并发是一个人同时吃三个馒头，而并行的3个人同时吃三个馒头</span><br></pre></td></tr></table></figure>
<hr>
<span id="more"></span>
<p><strong>进程</strong>：正在运行的程序</p>
<p><strong>线程</strong>：线程是执行应用程序种的某个具体任务，比如一段程序、一个函数等</p>
<p><strong>进程和线程的关系</strong></p>
<p>进程和线程之间的关系类似于工厂和工人之间的关系，进程好比是工厂，线程就如同工厂中的工人，一个工厂可以容纳多个工人，工厂负责为所有工人提供必要的资源，所有工人==<strong>共享这些资源</strong>==，每个工人负责完成一项具体的任务，他们相互配合，共同保证整个工厂的平稳运行</p>
<p><strong>一个进程至少包含 1 个线程（主线程），可以包含多个线程，所有线程共享进程的资源，各个线程也可以拥有属于自己的私有资源</strong></p>
<p><strong>进程仅负责为各个线程提供所需的资源，真正执行任务的是线程，而不是进程</strong></p>
<p>线程并不是越多越好，每个线程，都需要一个独立的堆栈空间（1M），线程之间的切换要保存很多中间状态，会耗费本该属于程序运行的时间</p>
<hr>
<h2 id="2-并发的实现"><a href="#2-并发的实现" class="headerlink" title="2 并发的实现"></a>2 并发的实现</h2><p>实现方法：</p>
<ol>
<li>通过多个进程来实现并发</li>
<li>在单独的进程中，通过代码来创建除了主线程之外的其他线程来实现并发</li>
</ol>
<h3 id="2-1多进程并发"><a href="#2-1多进程并发" class="headerlink" title="2.1多进程并发"></a>2.1多进程并发</h3><p><strong>进程之间通信：</strong></p>
<p>同一台电脑上：管道，文件，消息队列，共享内存</p>
<p>不同的电脑上：socket通信技术</p>
<h3 id="2-2多线程并发"><a href="#2-2多线程并发" class="headerlink" title="2.2多线程并发"></a>2.2多线程并发</h3><p>线程：像是轻量级的进程，每个线程都有自己独立的运行路径，但是每一个进程中的所有线程共享地址空间（共享内存）</p>
<p>多线程之间的通信可以使用全局变量，指针，引用等，因此使用多线程的开销远远小于多进程</p>
<p>但是共享内存也带来了两个线程间数据一致性的问题</p>
<h1 id="二、线程的启动和结束"><a href="#二、线程的启动和结束" class="headerlink" title="二、线程的启动和结束"></a>二、线程的启动和结束</h1><p>主线程从main()开始执行，我们自己创建的线程，也需要<strong>从一个函数开始运行</strong>（初始函数），一旦这个函数运行完毕，就代表这个线程也运行结束了</p>
<p>整个进程是否执行完毕的标志是<strong>主线程是否执行完毕</strong>，如果主线程执行完毕了，就代表整个进程执行完毕了，此时，如果其他子线程还没有执行完毕，那么这些子线程会被系统<strong>强行终止</strong>，<strong>一般情况下</strong>，如果要保持子线程的运行状态的话，要让主线程保持运行</p>
<h2 id="thread-amp-join"><a href="#thread-amp-join" class="headerlink" title="thread &amp; join"></a>thread &amp; join</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span> <span class="comment">//C++标准线程库</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myprint</span><span class="params">()</span></span>&#123;</span><br><span class="line">	std::cout&lt;&lt;<span class="string">&quot;Hello &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">mythread</span><span class="params">(myprint)</span></span>; <span class="comment">//初始化一个线程，并开始运行</span></span><br><span class="line">	<span class="comment">//阻塞子线程并等待myprint子线程执行完</span></span><br><span class="line">	<span class="comment">//当子线程执行完毕，join就执行完毕，主线程向下继续运行</span></span><br><span class="line">	mythread.<span class="built_in">join</span>();</span><br><span class="line">	std::cout&lt;&lt;<span class="string">&quot;World!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注：线程初始化即运行，如果不如用join函数使主线程等待子线程，主线程可能比子线程先结束，导致异常</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doit</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;World!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">a</span><span class="params">([]&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout&lt;&lt;<span class="string">&quot;Hello, &quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span>,<span class="title">b</span><span class="params">(doit)</span></span>;</span><br><span class="line">    a.<span class="built_in">join</span>();</span><br><span class="line">    b.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果为</span></span><br><span class="line">Hello, World!</span><br><span class="line">或者</span><br><span class="line">World！</span><br><span class="line">Hello</span><br></pre></td></tr></table></figure>
<h2 id="detach"><a href="#detach" class="headerlink" title="detach"></a>detach</h2><p>在传统的多线程程序中，主线程要等待子线程执行完毕，然后自己再退出，而在C++11新标准下，引入了detach（分离）函数，使得主线程不必再等待子线程结束，此时，子线程与主线程失去关联，子线程会驻留在后台运行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myprint</span><span class="params">()</span></span>&#123;</span><br><span class="line">	std::cout&lt;&lt;<span class="string">&quot;Hello &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">mythread</span><span class="params">(myprint)</span></span>;</span><br><span class="line">	mythread.<span class="built_in">detach</span>();</span><br><span class="line">	std::cout&lt;&lt;<span class="string">&quot;World!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202302282054227.png" alt="image-20230228205410147"></p>
<h2 id="joinable"><a href="#joinable" class="headerlink" title="joinable"></a>joinable</h2><p>joinable()函数：<strong>判断是否可以成功使用join()或detach()函数</strong>，返回<strong><em>true</em></strong>则可以使用join()和detach()函数，返回<strong><em>false</em></strong>则不行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function">std::thread <span class="title">mythread</span><span class="params">(myprint)</span></span>;</span><br><span class="line">	<span class="keyword">if</span>(mythread.<span class="built_in">joinable</span>())&#123;</span><br><span class="line">		mythread.<span class="built_in">detach</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="thread传入函数参数"><a href="#thread传入函数参数" class="headerlink" title="thread传入函数参数"></a>thread传入函数参数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造</span></span><br><span class="line">	<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;CREATE\n&quot;</span>; &#125;</span><br><span class="line">	<span class="comment">//拷贝构造</span></span><br><span class="line">	<span class="built_in">A</span>(<span class="type">const</span> A&amp; a) &#123; name = a.name; std::cout &lt;&lt; <span class="string">&quot;COPY\n&quot;</span>; &#125;</span><br><span class="line">	<span class="comment">//析构</span></span><br><span class="line">	~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;DELETE\n&quot;</span>; &#125;</span><br><span class="line">	std::string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadMain</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">Sleep</span>(<span class="number">100</span>);</span><br><span class="line">	std::cout &lt;&lt; a.name &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::thread th;</span><br><span class="line">	&#123;</span><br><span class="line">		A a;</span><br><span class="line">		a.name = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">		th = std::<span class="built_in">thread</span>(ThreadMain, a);</span><br><span class="line">	&#125;</span><br><span class="line">	th.<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202303022218967.png" alt="image-20230302221754883"></p>
<p>可以发现发生了一次构造函数，两次拷贝构造函数，三次析构函数，总共生成了3次对象</p>
<p>第一次是在25行，第二次是将对象传入thread中时，第三次则是在子线程中传入ThreadMain函数时</p>
<h2 id="使用指针-引用来进行参数传递"><a href="#使用指针-引用来进行参数传递" class="headerlink" title="使用指针/引用来进行参数传递"></a>使用指针/引用来进行参数传递</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造</span></span><br><span class="line">	<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;CREATE\n&quot;</span>; &#125;</span><br><span class="line">	<span class="comment">//拷贝构造</span></span><br><span class="line">	<span class="built_in">A</span>(<span class="type">const</span> A&amp; a) &#123; name = a.name; std::cout &lt;&lt; <span class="string">&quot;COPY\n&quot;</span>; &#125;</span><br><span class="line">	<span class="comment">//析构</span></span><br><span class="line">	~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;DELETE\n&quot;</span>; &#125;</span><br><span class="line">	std::string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadMain</span><span class="params">(A *a)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">Sleep</span>(<span class="number">100</span>);</span><br><span class="line">	std::cout &lt;&lt; a-&gt;name &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::thread th;</span><br><span class="line">	&#123;</span><br><span class="line">		A a;</span><br><span class="line">		a.name = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">		th = std::<span class="built_in">thread</span>(ThreadMain, &amp;a);</span><br><span class="line">		th.<span class="built_in">join</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202303032034746.png" alt="image-20230303203407693"></p>
<p>当使用指针来进行参数传递时，可以发现只进行了一次对象的构造以及析构，说明使用指针传递参数时，在子线程内访问的对象==仍为外部主线程里构造的对象==</p>
<p>因此，使用指针传递参数时，应该注意让指针的生命周期==大于==子线程的生命周期，不然当指针过早被析构时，子线程访问不到指针所指向的空间</p>
<hr>
<p>使用==引用==的情况下，与使用指针的情况一样，如果引用的空间被过早释放，程序同样会出错</p>
<p>thread()函数是一个模板函数，因此在使用引用时，应该使用==std::ref()==特别注明该参数是一个引用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Class A&#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadMain</span><span class="params">(A &amp;a)</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="function">thread <span class="title">th</span><span class="params">(ThreadMain,std::ref(a))</span></span>;</span><br><span class="line">    th.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用类来创建线程"><a href="#使用类来创建线程" class="headerlink" title="使用类来创建线程"></a>使用类来创建线程</h2><p>类需要重载()运算符，且重载函数不能包含参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">opeartor</span><span class="params">()</span><span class="params">()</span></span>&#123;</span><br><span class="line">		std::cout&lt;&lt;<span class="string">&quot;Hello, World!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	T tt;</span><br><span class="line">	<span class="function">std::thread <span class="title">mythread</span><span class="params">(tt)</span></span>;</span><br><span class="line">	mythread.<span class="built_in">join</span>();</span><br><span class="line">	std::cout&lt;&lt;<span class="string">&quot;111&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote id="fn_注">
<sup>注</sup>. 类内不要引用外部的值，当使用detach时，主线程结束会回收变量。而引用外部的值也会出现错误，而在上面代码中，tt对象在主线程结束后也会被销毁，但由于拷贝函数的默默付出，所以并不会发生错误<a href="#reffn_注" title="Jump back to footnote [注] in the text."> &#8617;</a>
</blockquote>
<h2 id="使用成员函数作为线程入口函数"><a href="#使用成员函数作为线程入口函数" class="headerlink" title="使用成员函数作为线程入口函数"></a>使用成员函数作为线程入口函数</h2><p>当我们使用的函数参数过多，需要传过多的参数时，不如将参数都封装在一个类中，使用成员函数来作为线程的入口函数，当实例对象的生命周期在时，线程的生命周期就在</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 参数</span></span><br><span class="line">    std::string str;</span><br><span class="line">    <span class="comment">// 入口函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        std::cout&lt;&lt;str&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MyThread test;</span><br><span class="line">    test.str=<span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="comment">// 需要传入对象的地址</span></span><br><span class="line">    <span class="function">std::thread <span class="title">th</span><span class="params">(&amp;MyThread::Main,&amp;test)</span></span>;</span><br><span class="line">    th.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="封装一个简易线程类"><a href="#封装一个简易线程类" class="headerlink" title="封装一个简易线程类"></a>封装一个简易线程类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">		th_=std::<span class="built_in">thread</span>(&amp;MyThread::Main,<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::thread th_;</span><br><span class="line">	<span class="comment">// 纯虚函数，子类必须重写该函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Main</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过自己封装一个简易的线程类，以后只需写一个类继承该类，重写Main方法，调用start方法就可以启动一个子线程</p>
<p>有需要的话，也可以在该类中添加==等待==、==停止==函数等</p>
<h2 id="使用lambda表达式"><a href="#使用lambda表达式" class="headerlink" title="使用lambda表达式"></a>使用lambda表达式</h2><p><strong><em>示例</em></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">th</span><span class="params">([](<span class="type">int</span> i)&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    std::cout&lt;&lt;i&lt;&lt;std::endl;&#125;,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="number">123</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<h1 id="三、多线程通信和同步"><a href="#三、多线程通信和同步" class="headerlink" title="三、多线程通信和同步"></a>三、多线程通信和同步</h1><h2 id="1-多线程状态"><a href="#1-多线程状态" class="headerlink" title="1 多线程状态"></a>1 多线程状态</h2><h3 id="1-1-线程状态说明"><a href="#1-1-线程状态说明" class="headerlink" title="1.1 线程状态说明"></a>1.1 线程状态说明</h3><ul>
<li>初始化(Init)：该线程正在被创建</li>
<li>就绪(Ready)：该线程在就绪列表中，等待CPU调度</li>
<li>运行(Running)：该线程正在运行</li>
<li>阻塞(Blocked)：该线程被阻塞挂起；Blocked状态包括：pend(锁、事件、信号量等阻塞)、suspend(主动pend)、delay(延时阻塞)、pendtime(因为锁、事件、信号量时间等超时等待)</li>
<li>退出(Exit)：该线程运行结束，等待父线程回收其控制块资源</li>
</ul>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202303062233589.png" alt="image-20230306223321511"></p>
<h3 id="1-2-竞争状态和临界区"><a href="#1-2-竞争状态和临界区" class="headerlink" title="1.2 竞争状态和临界区"></a>1.2 竞争状态和临界区</h3><p><strong>竞争状态</strong></p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线程是非独立的，同一个进程里线程是数据共享的，当各个线程访问同一个数据资源是会出现竞争状态</span><br></pre></td></tr></table></figure>
<p><strong>临界区</strong></p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">读写共享数据的代码片段</span><br></pre></td></tr></table></figure>
<p><strong><em>避免竞争状态策略，对临界区进行保护，同时只能由一个线程进去临界区</em></strong></p>
<h2 id="2-互斥体和锁mutex"><a href="#2-互斥体和锁mutex" class="headerlink" title="2 互斥体和锁mutex"></a>2 互斥体和锁mutex</h2><h3 id="2-1-互斥锁-mutex"><a href="#2-1-互斥锁-mutex" class="headerlink" title="2.1 互斥锁 mutex"></a>2.1 互斥锁 mutex</h3><ul>
<li>lock 和 try_lock</li>
<li>unlock</li>
</ul>
<p>在各线程访问共享数据时，使用mutex.lock，这时只有先lock的线程能够访问共享数据，其他线程处于等待状态，直到该线程访问完共享数据使用mutex.unlock</p>
<h4 id="不使用锁的情况"><a href="#不使用锁的情况" class="headerlink" title="不使用锁的情况"></a>不使用锁的情况</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadMain</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;=======================&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;test 001&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;test 002&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;test 003&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;=======================&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)&#123;</span><br><span class="line">        <span class="function">std::thread <span class="title">th</span><span class="params">(ThreadMain)</span></span>;</span><br><span class="line">        th.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202303072132660.png" alt="image-20230307213248578"></p>
<p>会出现不规则输出的情况</p>
<h4 id="使用锁"><a href="#使用锁" class="headerlink" title="使用锁"></a>使用锁</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> std::mutex mux;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadMain</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mux.<span class="built_in">lock</span>();</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;=======================&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;test 001&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;test 002&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;test 003&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;=======================&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    mux.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202303072134323.png" alt="image-20230307213457279"></p>
<h4 id="try-lock"><a href="#try-lock" class="headerlink" title="try_lock"></a>try_lock</h4><ul>
<li>如果互斥锁当前未被任何线程锁定，则调用线程将其锁定并返回true</li>
<li>如果互斥锁当前被另一个线程锁定，则该函数将失败并返回false，==而不会阻塞==</li>
<li>如果互斥锁当前被调用此函数的同一线程锁定，则会产生死锁</li>
<li>在使用try_lock的时候，一定要判断其返回的值是否为true，只有在true的时候才能够执行unlock操作</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadMain</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mux.<span class="built_in">try_lock</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;try\n&quot;</span> &lt;&lt; std::flush;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;==============================&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;test 001&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;test 002&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;test 003&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;==============================&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">        mux.<span class="built_in">unlock</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202303090958114.png" alt="image-20230309095841928"></p>
<h3 id="2-2-互斥锁的坑-线程抢占不到资源"><a href="#2-2-互斥锁的坑-线程抢占不到资源" class="headerlink" title="2.2 互斥锁的坑_线程抢占不到资源"></a>2.2 互斥锁的坑_线程抢占不到资源</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> std::mutex mux;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadMain</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        mux.<span class="built_in">lock</span>();</span><br><span class="line">        std::cout&lt;&lt;i&lt;&lt;<span class="string">&quot;[in]&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>));</span><br><span class="line">        mux.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i)&#123;</span><br><span class="line">        <span class="function">std::thread <span class="title">th</span><span class="params">(ThreadMain,i+<span class="number">1</span>)</span></span>;</span><br><span class="line">        th.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202303072336262.png" alt="image-20230307233615152"></p>
<p>有概率会出现一个线程一直抢占着资源，其他线程一直处于等待状态</p>
<p>调用unlock后，系统还来不及释放资源，就被该线程又给lock锁上了</p>
<hr>
<p>解决方法：在线程执行完毕后使其等待一会</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadMain</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        mux.<span class="built_in">lock</span>();</span><br><span class="line">        std::cout&lt;&lt;i&lt;&lt;<span class="string">&quot;[in]&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>));</span><br><span class="line">        mux.<span class="built_in">unlock</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202303072339137.png" alt="image-20230307233916090"></p>
<h3 id="2-3-超时锁-timed-mutex"><a href="#2-3-超时锁-timed-mutex" class="headerlink" title="2.3 超时锁 timed_mutex"></a>2.3 超时锁 timed_mutex</h3><p>可以记录锁获取情况，多次超时，可以记录日志，获取错误情况</p>
<p>timed_mutex增加了带时限的try_lock，即==try_lock_for==和==try_lock_until==</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-4-递归锁-可重入-recursive-mutex-和-recursive-timed-mutex"><a href="#2-4-递归锁-可重入-recursive-mutex-和-recursive-timed-mutex" class="headerlink" title="2.4 递归锁(可重入) recursive_mutex 和 recursive_timed_mutex"></a>2.4 递归锁(可重入) recursive_mutex 和 recursive_timed_mutex</h3><h3 id="2-5-共享锁-shared-mutex"><a href="#2-5-共享锁-shared-mutex" class="headerlink" title="2.5 共享锁 shared_mutex"></a>2.5 共享锁 shared_mutex</h3><h3 id="2-6-std-call-once"><a href="#2-6-std-call-once" class="headerlink" title="2.6 std::call_once"></a>2.6 std::call_once</h3><p>在多线程编程中，有时某个函数只需要被执行一次，某些变量只需要初始化一次，此时可以考虑添加锁来控制，而在C++11中，提供了==std::call_once==函数来解决该问题，==std::call_once==函数需要配合==std::once_flag==来实现，也可以解决多线程安全的单例模式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::once_flag flag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Hello,World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::<span class="built_in">call_once</span>(flag, display);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">th1</span><span class="params">(ThreadOnce)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">th2</span><span class="params">(ThreadOnce)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">th3</span><span class="params">(ThreadOnce)</span></span>;</span><br><span class="line">	th1.<span class="built_in">join</span>();</span><br><span class="line">	th2.<span class="built_in">join</span>();</span><br><span class="line">	th3.<span class="built_in">join</span>();</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202303091013309.png" alt="image-20230309101317218"></p>
<p>可以看到使用了三个线程，但是只打印了一遍   “Hello,World!”</p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>Post author:  </strong>renmale-lv
  </li>
  <li class="post-copyright-link">
      <strong>Post link: </strong>
      <a href="http://example.com/2023/02/19/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="C++多线程">http://example.com/2023/02/19/C++多线程/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/12/02/%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA-PAM/" rel="prev" title="回文自动机(PAM)">
                  <i class="fa fa-chevron-left"></i> 回文自动机(PAM)
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/02/19/C++Socket%E7%BC%96%E7%A8%8B/" rel="next" title="C++Socket编程">
                  C++Socket编程 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">renmale-lv</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>Word count total: </span>
    <span title="Word count total">29k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>Reading time total &asymp;</span>
    <span title="Reading time total">26 mins.</span>
  </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>
<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>  Sometimes your whole life boils down to one insame move.
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("11/05/2022 00:00:00");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
}
setInterval("createtime()",250);
</script>
    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"renmale-lv","repo":"renmale-lv.github.io","client_id":"a7032a206391d1242a3c","client_secret":"5beb16ecce13a96a943bce7252eab7ab77218b9d","admin_user":"renmale-lv","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"04067bd0bd9024ed3c9c47c5f53fbc0c"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/clicklove.js"></script>
