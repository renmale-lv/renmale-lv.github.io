<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.14.2","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"order":-1}},"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="记笔记时翻阅了一些其他大佬的资料，如有侵权，联系我删除  一、并发、进程、线程1 概念并发：两个或者更多的任务同时发生（实际上是多个任务轮流占有处理器），某一时刻只能执行一个任务：由于操作系统调度，每秒钟进行多次所谓的“任务切换”，这种切换（上下文切换）死有时间开销的。    并发是指一个处理器同时处理多个任务 并行是指多个处理器或者是多核的处理器同时处理多个不同的任务 并发是逻辑上的同时发生">
<meta property="og:type" content="article">
<meta property="og:title" content="C++多线程基础">
<meta property="og:url" content="http://example.com/2023/02/19/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="renmale-lv blog">
<meta property="og:description" content="记笔记时翻阅了一些其他大佬的资料，如有侵权，联系我删除  一、并发、进程、线程1 概念并发：两个或者更多的任务同时发生（实际上是多个任务轮流占有处理器），某一时刻只能执行一个任务：由于操作系统调度，每秒钟进行多次所谓的“任务切换”，这种切换（上下文切换）死有时间开销的。    并发是指一个处理器同时处理多个任务 并行是指多个处理器或者是多核的处理器同时处理多个不同的任务 并发是逻辑上的同时发生">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/img/202302272053004.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/img/202302282054227.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/img/202303022218967.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/img/202303032034746.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/img/202303062233589.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/img/202303072132660.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/img/202303072134323.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/img/202303090958114.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/img/202303072336262.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/img/202303072339137.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/img/202303101203317.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/img/202303091013309.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/image-20230402220515173.png">
<meta property="og:image" content="c:\Users\lvxr\AppData\Roaming\Typora\typora-user-images\image-20230406170429481.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/image-20230406171909775.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/image-20230407141410301.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/image-20230407144323255.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/image-20230407152252132.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/image-20230407152502311.png">
<meta property="article:published_time" content="2023-02-19T09:57:15.000Z">
<meta property="article:modified_time" content="2023-04-07T07:28:31.650Z">
<meta property="article:author" content="renmale-lv">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/renmale-sztu/image/raw/master/img/202302272053004.png">


<link rel="canonical" href="http://example.com/2023/02/19/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2023/02/19/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/","path":"2023/02/19/C++多线程基础/","title":"C++多线程基础"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>C++多线程基础 | renmale-lv blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="renmale-lv blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">renmale-lv blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记录学习点滴</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%B9%B6%E5%8F%91%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">一、并发、进程、线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.</span> <span class="nav-text">1 概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%B9%B6%E5%8F%91%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.</span> <span class="nav-text">2 并发的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%91"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1多进程并发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2多线程并发</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E7%BB%93%E6%9D%9F"><span class="nav-number">2.</span> <span class="nav-text">二、线程的启动和结束</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#thread-amp-join"><span class="nav-number">2.1.</span> <span class="nav-text">thread &amp; join</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#detach"><span class="nav-number">2.2.</span> <span class="nav-text">detach</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#joinable"><span class="nav-number">2.3.</span> <span class="nav-text">joinable</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#thread%E4%BC%A0%E5%85%A5%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="nav-number">2.4.</span> <span class="nav-text">thread传入函数参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8%E6%9D%A5%E8%BF%9B%E8%A1%8C%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="nav-number">2.5.</span> <span class="nav-text">使用指针&#x2F;引用来进行参数传递</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%B1%BB%E6%9D%A5%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.6.</span> <span class="nav-text">使用类来创建线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E7%BA%BF%E7%A8%8B%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="nav-number">2.7.</span> <span class="nav-text">使用成员函数作为线程入口函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%BA%BF%E7%A8%8B%E7%B1%BB"><span class="nav-number">2.8.</span> <span class="nav-text">封装一个简易线程类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">2.9.</span> <span class="nav-text">使用lambda表达式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%92%8C%E5%90%8C%E6%AD%A5"><span class="nav-number">3.</span> <span class="nav-text">三、多线程通信和同步</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-number">3.1.</span> <span class="nav-text">1 多线程状态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%AF%B4%E6%98%8E"><span class="nav-number">3.1.1.</span> <span class="nav-text">1.1 线程状态说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E7%AB%9E%E4%BA%89%E7%8A%B6%E6%80%81%E5%92%8C%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="nav-number">3.1.2.</span> <span class="nav-text">1.2 竞争状态和临界区</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%BA%92%E6%96%A5%E4%BD%93%E5%92%8C%E9%94%81mutex"><span class="nav-number">3.2.</span> <span class="nav-text">2 互斥体和锁mutex</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E4%BA%92%E6%96%A5%E9%94%81-mutex"><span class="nav-number">3.2.1.</span> <span class="nav-text">2.1 互斥锁 mutex</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E4%BD%BF%E7%94%A8%E9%94%81%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">不使用锁的情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%94%81"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">使用锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#try-lock"><span class="nav-number">3.2.1.3.</span> <span class="nav-text">try_lock</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E5%9D%91-%E7%BA%BF%E7%A8%8B%E6%8A%A2%E5%8D%A0%E4%B8%8D%E5%88%B0%E8%B5%84%E6%BA%90"><span class="nav-number">3.2.2.</span> <span class="nav-text">2.2 互斥锁的坑_线程抢占不到资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E8%B6%85%E6%97%B6%E9%94%81-timed-mutex"><span class="nav-number">3.2.3.</span> <span class="nav-text">2.3 超时锁 timed_mutex</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#try-lock-for"><span class="nav-number">3.2.3.1.</span> <span class="nav-text">try_lock_for</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#try-lock-until"><span class="nav-number">3.2.3.2.</span> <span class="nav-text">try_lock_until</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E9%80%92%E5%BD%92%E9%94%81-%E5%8F%AF%E9%87%8D%E5%85%A5-recursive-mutex-%E5%92%8C-recursive-timed-mutex"><span class="nav-number">3.2.4.</span> <span class="nav-text">2.4 递归锁(可重入) recursive_mutex 和 recursive_timed_mutex</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#recursive-mutex"><span class="nav-number">3.2.4.1.</span> <span class="nav-text">recursive_mutex</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#recursive-timed-mutex"><span class="nav-number">3.2.4.2.</span> <span class="nav-text">recursive_timed_mutex</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E5%85%B1%E4%BA%AB%E9%94%81-shared-mutex"><span class="nav-number">3.2.5.</span> <span class="nav-text">2.5 共享锁 shared_mutex</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E9%94%81-%E6%8E%92%E4%BB%96%E6%80%A7%E9%94%81%E5%AE%9A"><span class="nav-number">3.2.5.1.</span> <span class="nav-text">写锁(排他性锁定)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E9%94%81%EF%BC%88%E5%85%B1%E4%BA%AB%E9%94%81%E5%AE%9A%EF%BC%89"><span class="nav-number">3.2.5.2.</span> <span class="nav-text">读锁（共享锁定）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-std-call-once"><span class="nav-number">3.2.6.</span> <span class="nav-text">2.6 std::call_once</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%88%A9%E7%94%A8%E6%A0%88%E7%89%B9%E6%80%A7%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E9%94%81-RAII"><span class="nav-number">3.3.</span> <span class="nav-text">3 利用栈特性自动释放锁 RAII</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-RAII"><span class="nav-number">3.3.1.</span> <span class="nav-text">3.1 RAII</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-C-11-lock-guard"><span class="nav-number">3.3.2.</span> <span class="nav-text">3.2 C++11 lock_guard</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#std-adopt-lock"><span class="nav-number">3.3.2.1.</span> <span class="nav-text">std::adopt_lock</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-C-11-unique-lock"><span class="nav-number">3.3.3.</span> <span class="nav-text">3.3 C++11 unique_lock</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#std-adopt-lock-1"><span class="nav-number">3.3.3.1.</span> <span class="nav-text">std::adopt_lock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#std-try-to-lock"><span class="nav-number">3.3.3.2.</span> <span class="nav-text">std::try_to_lock</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#owns-lock"><span class="nav-number">3.3.3.2.1.</span> <span class="nav-text">owns_lock</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#std-defer-lock"><span class="nav-number">3.3.3.3.</span> <span class="nav-text">std::defer_lock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%8F%82%E6%95%B0"><span class="nav-number">3.3.3.4.</span> <span class="nav-text">其他参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lock"><span class="nav-number">3.3.3.5.</span> <span class="nav-text">lock()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unlock"><span class="nav-number">3.3.3.6.</span> <span class="nav-text">unlock()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#try-lock-1"><span class="nav-number">3.3.3.7.</span> <span class="nav-text">try_lock()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#release"><span class="nav-number">3.3.3.8.</span> <span class="nav-text">release()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%80%E6%9C%89%E6%9D%83%E7%9A%84%E4%BC%A0%E9%80%92"><span class="nav-number">3.3.3.9.</span> <span class="nav-text">所有权的传递</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#move"><span class="nav-number">3.3.3.9.1.</span> <span class="nav-text">move</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#return"><span class="nav-number">3.3.3.9.2.</span> <span class="nav-text">return</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B2%92%E5%BA%A6"><span class="nav-number">3.3.3.10.</span> <span class="nav-text">粒度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-C-14-shared-lock"><span class="nav-number">3.3.4.</span> <span class="nav-text">3.4 C++14 shared_lock</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">3.3.4.0.1.</span> <span class="nav-text">常用成员函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-C-17-scoped-lock"><span class="nav-number">3.3.5.</span> <span class="nav-text">3.5 C++17 scoped_lock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-condition-variable-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-number">3.3.6.</span> <span class="nav-text">3.6 condition_variable 条件变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#wait"><span class="nav-number">3.3.6.1.</span> <span class="nav-text">wait</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#notify"><span class="nav-number">3.3.6.2.</span> <span class="nav-text">notify</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#notify-one"><span class="nav-number">3.3.6.2.1.</span> <span class="nav-text">notify_one</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#notify-all"><span class="nav-number">3.3.6.2.2.</span> <span class="nav-text">notify_all</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85"><span class="nav-number">3.3.6.3.</span> <span class="nav-text">示例-生产者消费者</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92"><span class="nav-number">3.3.6.4.</span> <span class="nav-text">虚假唤醒</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BC%82%E6%AD%A5%E5%92%8C%E9%80%9A%E4%BF%A1"><span class="nav-number">3.4.</span> <span class="nav-text">4 线程的异步和通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-promise-%E5%92%8C-future"><span class="nav-number">3.4.1.</span> <span class="nav-text">4.1 promise 和 future</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">3.4.1.1.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-packaged-task%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E6%89%93%E5%8C%85"><span class="nav-number">3.4.2.</span> <span class="nav-text">4.2 packaged_task异步调用函数打包</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="nav-number">3.4.2.1.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#std-packaged-task-valid"><span class="nav-number">3.4.2.2.</span> <span class="nav-text">std::packaged_task::valid</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#std-packaged-task-swap"><span class="nav-number">3.4.2.3.</span> <span class="nav-text">std::packaged_task::swap</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-async"><span class="nav-number">3.4.3.</span> <span class="nav-text">4.3 async</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="nav-number">3.4.3.1.</span> <span class="nav-text">函数原型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-async"><span class="nav-number">3.4.3.2.</span> <span class="nav-text">示例-async</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-deferred"><span class="nav-number">3.4.3.3.</span> <span class="nav-text">示例-deferred</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="renmale-lv"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">renmale-lv</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/19/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="renmale-lv">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="renmale-lv blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="C++多线程基础 | renmale-lv blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++多线程基础
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-02-19 17:57:15" itemprop="dateCreated datePublished" datetime="2023-02-19T17:57:15+08:00">2023-02-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-04-07 15:28:31" itemprop="dateModified" datetime="2023-04-07T15:28:31+08:00">2023-04-07</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>28k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>26 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <meta name="referrer" content="no-referrer">

<label style="color:yellow">记笔记时翻阅了一些其他大佬的资料，如有侵权，联系我删除</label>

<h1 id="一、并发、进程、线程"><a href="#一、并发、进程、线程" class="headerlink" title="一、并发、进程、线程"></a>一、并发、进程、线程</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h2><p><strong>并发</strong>：两个或者更多的任务<del>同时发生</del>（实际上是多个任务轮流占有处理器），某一时刻只能执行一个任务：由于操作系统调度，每秒钟进行多次所谓的“任务切换”，这种切换（上下文切换）死有时间开销的。  </p>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202302272053004.png" alt="img"></p>
<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">并发是指一个处理器同时处理多个任务
并行是指多个处理器或者是多核的处理器同时处理多个不同的任务
并发是逻辑上的同时发生，而并行是物理上的同时发生
并发是一个人同时吃三个馒头，而并行的3个人同时吃三个馒头<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<span id="more"></span>
<p><strong>进程</strong>：正在运行的程序</p>
<p><strong>线程</strong>：线程是执行应用程序种的某个具体任务，比如一段程序、一个函数等</p>
<p><strong>进程和线程的关系</strong></p>
<p>进程和线程之间的关系类似于工厂和工人之间的关系，进程好比是工厂，线程就如同工厂中的工人，一个工厂可以容纳多个工人，工厂负责为所有工人提供必要的资源，所有工人<strong><em>共享这些资源</em></strong>，每个工人负责完成一项具体的任务，他们相互配合，共同保证整个工厂的平稳运行</p>
<p><strong>一个进程至少包含 1 个线程（主线程），可以包含多个线程，所有线程共享进程的资源，各个线程也可以拥有属于自己的私有资源</strong></p>
<p><strong>进程仅负责为各个线程提供所需的资源，真正执行任务的是线程，而不是进程</strong></p>
<p>线程并不是越多越好，每个线程，都需要一个独立的堆栈空间（1M），线程之间的切换要保存很多中间状态，会耗费本该属于程序运行的时间</p>
<hr>
<h2 id="2-并发的实现"><a href="#2-并发的实现" class="headerlink" title="2 并发的实现"></a>2 并发的实现</h2><p>实现方法：</p>
<ol>
<li>通过多个进程来实现并发</li>
<li>在单独的进程中，通过代码来创建除了主线程之外的其他线程来实现并发</li>
</ol>
<h3 id="2-1多进程并发"><a href="#2-1多进程并发" class="headerlink" title="2.1多进程并发"></a>2.1多进程并发</h3><p><strong>进程之间通信：</strong></p>
<p>同一台电脑上：管道，文件，消息队列，共享内存</p>
<p>不同的电脑上：socket通信技术</p>
<h3 id="2-2多线程并发"><a href="#2-2多线程并发" class="headerlink" title="2.2多线程并发"></a>2.2多线程并发</h3><p>线程：像是轻量级的进程，每个线程都有自己独立的运行路径，但是每一个进程中的所有线程共享地址空间（共享内存）</p>
<p>多线程之间的通信可以使用全局变量，指针，引用等，因此使用多线程的开销远远小于多进程</p>
<p>但是共享内存也带来了两个线程间数据一致性的问题</p>
<h1 id="二、线程的启动和结束"><a href="#二、线程的启动和结束" class="headerlink" title="二、线程的启动和结束"></a>二、线程的启动和结束</h1><p>主线程从main()开始执行，我们自己创建的线程，也需要<strong>从一个函数开始运行</strong>（初始函数），一旦这个函数运行完毕，就代表这个线程也运行结束了</p>
<p>整个进程是否执行完毕的标志是<strong>主线程是否执行完毕</strong>，如果主线程执行完毕了，就代表整个进程执行完毕了，此时，如果其他子线程还没有执行完毕，那么这些子线程会被系统<strong>强行终止</strong>，<strong>一般情况下</strong>，如果要保持子线程的运行状态的话，要让主线程保持运行</p>
<h2 id="thread-amp-join"><a href="#thread-amp-join" class="headerlink" title="thread & join"></a>thread &amp; join</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">
#include&lt;iostream&gt;
#include&lt;thread&gt; //C++标准线程库

void myprint(){
	std::cout&lt;&lt;"Hello ";
}

int main(){
	std::thread mythread(myprint); //初始化一个线程，并开始运行
	//阻塞子线程并等待myprint子线程执行完
	//当子线程执行完毕，join就执行完毕，主线程向下继续运行
	mythread.join();
	std::cout&lt;&lt;"World!"&lt;&lt;std::endl;
	return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注：线程初始化即运行，如果不如用join函数使主线程等待子线程，主线程可能比子线程先结束，导致异常</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">
#include&lt;iostream&gt;
#include&lt;thread&gt;

void doit(){
    std::cout&lt;&lt;"World!"&lt;&lt;std::endl;
}

int main(){
    std::thread a([]{
        std::cout&lt;&lt;"Hello, ";
    }),b(doit);
    a.join();
    b.join();
    return 0;
}

//输出结果为
Hello, World!
或者
World！
Hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="detach"><a href="#detach" class="headerlink" title="detach"></a>detach</h2><p>在传统的多线程程序中，主线程要等待子线程执行完毕，然后自己再退出，而在C++11新标准下，引入了detach（分离）函数，使得主线程不必再等待子线程结束，此时，子线程与主线程失去关联，子线程会驻留在后台运行</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">
#include&lt;iostream&gt;
#include&lt;thread&gt;

void myprint(){
	std::cout&lt;&lt;"Hello ";
}

int main(){
	std::thread mythread(myprint);
	mythread.detach();
	std::cout&lt;&lt;"World!"&lt;&lt;std::endl;
	return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202302282054227.png" alt="image-20230228205410147"></p>
<h2 id="joinable"><a href="#joinable" class="headerlink" title="joinable"></a>joinable</h2><p>joinable()函数：<strong>判断是否可以成功使用join()或detach()函数</strong>，返回<strong><em>true</em></strong>则可以使用join()和detach()函数，返回<strong><em>false</em></strong>则不行</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">	std::thread mythread(myprint);
	if(mythread.joinable()){
		mythread.detach();
	}
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="thread传入函数参数"><a href="#thread传入函数参数" class="headerlink" title="thread传入函数参数"></a>thread传入函数参数</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;thread&gt;
#include&lt;string&gt;
#include&lt;Windows.h&gt;

class A {
public:
	//构造
	A() { std::cout &lt;&lt; "CREATE\n"; }
	//拷贝构造
	A(const A&amp; a) { name = a.name; std::cout &lt;&lt; "COPY\n"; }
	//析构
	~A() { std::cout &lt;&lt; "DELETE\n"; }
	std::string name;
};

void ThreadMain(A a) {
	Sleep(100);
	std::cout &lt;&lt; a.name &lt;&lt; std::endl;
}

int main() {
	std::thread th;
	{
		A a;
		a.name = "test";
		th = std::thread(ThreadMain, a);
	}
	th.join();
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202303022218967.png" alt="image-20230302221754883"></p>
<p>可以发现发生了一次构造函数，两次拷贝构造函数，三次析构函数，总共生成了3次对象</p>
<p>第一次是在25行，第二次是将对象传入thread中时，第三次则是在子线程中传入ThreadMain函数时</p>
<h2 id="使用指针-引用来进行参数传递"><a href="#使用指针-引用来进行参数传递" class="headerlink" title="使用指针/引用来进行参数传递"></a>使用指针/引用来进行参数传递</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;thread&gt;
#include&lt;string&gt;
#include&lt;Windows.h&gt;

class A {
public:
	//构造
	A() { std::cout &lt;&lt; "CREATE\n"; }
	//拷贝构造
	A(const A&amp; a) { name = a.name; std::cout &lt;&lt; "COPY\n"; }
	//析构
	~A() { std::cout &lt;&lt; "DELETE\n"; }
	std::string name;
};

void ThreadMain(A *a) {
	Sleep(100);
	std::cout &lt;&lt; a-&gt;name &lt;&lt; std::endl;
}

int main() {
	std::thread th;
	{
		A a;
		a.name = "test";
		th = std::thread(ThreadMain, &amp;a);
		th.join();
	}
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202303032034746.png" alt="image-20230303203407693"></p>
<p>当使用指针来进行参数传递时，可以发现只进行了一次对象的构造以及析构，说明使用指针传递参数时，在子线程内访问的对象<strong><em>仍为外部主线程里构造的对象</em></strong></p>
<p>因此，使用指针传递参数时，应该注意让指针的生命周期<strong><em>大于</em></strong>子线程的生命周期，不然当指针过早被析构时，子线程访问不到指针所指向的空间</p>
<hr>
<p>使用<strong><em>引用</em></strong>的情况下，与使用指针的情况一样，如果引用的空间被过早释放，程序同样会出错</p>
<p>thread()函数是一个模板函数，因此在使用引用时，应该使用<strong><em>std::ref()</em></strong>特别注明该参数是一个引用</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Class A{...};

void ThreadMain(A &amp;a){...}

int main(){
    A a;
    thread th(ThreadMain,std::ref(a));
    th.join();
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="使用类来创建线程"><a href="#使用类来创建线程" class="headerlink" title="使用类来创建线程"></a>使用类来创建线程</h2><p>类需要重载()运算符，且重载函数不能包含参数</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">
class T{
public:
	void opeartor()(){
		std::cout&lt;&lt;"Hello, World!"&lt;&lt;std::endl;
	}
}

int main(){
	T tt;
	std::thread mythread(tt);
	mythread.join();
	std::cout&lt;&lt;"111"&lt;&lt;std::endl;
	return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote id="fn_注">
<sup>注</sup>. 类内不要引用外部的值，当使用detach时，主线程结束会回收变量。而引用外部的值也会出现错误，而在上面代码中，tt对象在主线程结束后也会被销毁，但由于拷贝函数的默默付出，所以并不会发生错误<a href="#reffn_注" title="Jump back to footnote [注] in the text."> ↩</a>
</blockquote>
<h2 id="使用成员函数作为线程入口函数"><a href="#使用成员函数作为线程入口函数" class="headerlink" title="使用成员函数作为线程入口函数"></a>使用成员函数作为线程入口函数</h2><p>当我们使用的函数参数过多，需要传过多的参数时，不如将参数都封装在一个类中，使用成员函数来作为线程的入口函数，当实例对象的生命周期在时，线程的生命周期就在</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;thread&gt;
#include&lt;string&gt;

class MyThread{
public:
    // 参数
    std::string str;
    // 入口函数
    void Main(){
        std::cout&lt;&lt;str&lt;&lt;std::endl;
    }
};

int main(){
    MyThread test;
    test.str="Hello World!";
    // 需要传入对象的地址
    std::thread th(&amp;MyThread::Main,&amp;test);
    th.join();
    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="封装一个简易线程类"><a href="#封装一个简易线程类" class="headerlink" title="封装一个简易线程类"></a>封装一个简易线程类</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class MyThread{
public:
	virtual void start(){
		th_=std::thread(&amp;MyThread::Main,this);
	}
private:
	std::thread th_;
	// 纯虚函数，子类必须重写该函数
	virtual void Main()=0;
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过自己封装一个简易的线程类，以后只需写一个类继承该类，重写Main方法，调用start方法就可以启动一个子线程</p>
<p>有需要的话，也可以在该类中添加<strong><em>等待</em></strong>、<strong><em>停止</em></strong>函数等</p>
<h2 id="使用lambda表达式"><a href="#使用lambda表达式" class="headerlink" title="使用lambda表达式"></a>使用lambda表达式</h2><p><strong><em>示例</em></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::thread th([](int i){
    std::cout&lt;&lt;i&lt;&lt;std::endl;},
    123
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="三、多线程通信和同步"><a href="#三、多线程通信和同步" class="headerlink" title="三、多线程通信和同步"></a>三、多线程通信和同步</h1><h2 id="1-多线程状态"><a href="#1-多线程状态" class="headerlink" title="1 多线程状态"></a>1 多线程状态</h2><h3 id="1-1-线程状态说明"><a href="#1-1-线程状态说明" class="headerlink" title="1.1 线程状态说明"></a>1.1 线程状态说明</h3><ul>
<li>初始化(Init)：该线程正在被创建</li>
<li>就绪(Ready)：该线程在就绪列表中，等待CPU调度</li>
<li>运行(Running)：该线程正在运行</li>
<li>阻塞(Blocked)：该线程被阻塞挂起；Blocked状态包括：pend(锁、事件、信号量等阻塞)、suspend(主动pend)、delay(延时阻塞)、pendtime(因为锁、事件、信号量时间等超时等待)</li>
<li>退出(Exit)：该线程运行结束，等待父线程回收其控制块资源</li>
</ul>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202303062233589.png" alt="image-20230306223321511"></p>
<h3 id="1-2-竞争状态和临界区"><a href="#1-2-竞争状态和临界区" class="headerlink" title="1.2 竞争状态和临界区"></a>1.2 竞争状态和临界区</h3><p><strong>竞争状态</strong></p>
<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">线程是非独立的，同一个进程里线程是数据共享的，当各个线程访问同一个数据资源是会出现竞争状态<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>临界区</strong></p>
<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">读写共享数据的代码片段<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong><em>避免竞争状态策略，对临界区进行保护，同时只能由一个线程进去临界区</em></strong></p>
<h2 id="2-互斥体和锁mutex"><a href="#2-互斥体和锁mutex" class="headerlink" title="2 互斥体和锁mutex"></a>2 互斥体和锁mutex</h2><h3 id="2-1-互斥锁-mutex"><a href="#2-1-互斥锁-mutex" class="headerlink" title="2.1 互斥锁 mutex"></a>2.1 互斥锁 mutex</h3><ul>
<li>lock 和 try_lock</li>
<li>unlock</li>
</ul>
<p>在各线程访问共享数据时，使用mutex.lock，这时只有先lock的线程能够访问共享数据，其他线程处于等待状态，直到该线程访问完共享数据使用mutex.unlock</p>
<h4 id="不使用锁的情况"><a href="#不使用锁的情况" class="headerlink" title="不使用锁的情况"></a>不使用锁的情况</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;thread&gt;
#include&lt;string&gt;

void ThreadMain(){
    std::cout&lt;&lt;"======================="&lt;&lt;std::endl;
    std::cout&lt;&lt;"test 001"&lt;&lt;std::endl;
    std::cout&lt;&lt;"test 002"&lt;&lt;std::endl;
    std::cout&lt;&lt;"test 003"&lt;&lt;std::endl;
    std::cout&lt;&lt;"======================="&lt;&lt;std::endl;
}

int main(){
    for(int i=0;i&lt;10;++i){
        std::thread th(ThreadMain);
        th.detach();
    }
    getchar();
    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202303072132660.png" alt="image-20230307213248578"></p>
<p>会出现不规则输出的情况</p>
<h4 id="使用锁"><a href="#使用锁" class="headerlink" title="使用锁"></a>使用锁</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">static std::mutex mux;

void ThreadMain(){
    mux.lock();
    std::cout&lt;&lt;"======================="&lt;&lt;std::endl;
    std::cout&lt;&lt;"test 001"&lt;&lt;std::endl;
    std::cout&lt;&lt;"test 002"&lt;&lt;std::endl;
    std::cout&lt;&lt;"test 003"&lt;&lt;std::endl;
    std::cout&lt;&lt;"======================="&lt;&lt;std::endl;
    mux.unlock();
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202303072134323.png" alt="image-20230307213457279"></p>
<h4 id="try-lock"><a href="#try-lock" class="headerlink" title="try_lock"></a>try_lock</h4><ul>
<li>如果互斥锁当前未被任何线程锁定，则调用线程将其锁定并返回true</li>
<li>如果互斥锁当前被另一个线程锁定，则该函数将失败并返回false，<strong><em>而不会阻塞</em></strong></li>
<li>如果互斥锁当前被调用此函数的同一线程锁定，则会产生死锁</li>
<li>在使用try_lock的时候，一定要判断其返回的值是否为true，只有在true的时候才能够执行unlock操作</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void ThreadMain()
{
    for (;;) {
        if (!mux.try_lock())
        {
            std::cout &lt;&lt; "try\n" &lt;&lt; std::flush;
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
            continue;
        }
        std::cout &lt;&lt; "==============================" &lt;&lt; std::endl;
        std::cout &lt;&lt; "test 001" &lt;&lt; std::endl;
        std::cout &lt;&lt; "test 002" &lt;&lt; std::endl;
        std::cout &lt;&lt; "test 003" &lt;&lt; std::endl;
        std::cout &lt;&lt; "==============================" &lt;&lt; std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        mux.unlock();
        std::this_thread::sleep_for(std::chrono::milliseconds(1));
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202303090958114.png" alt="image-20230309095841928"></p>
<h3 id="2-2-互斥锁的坑-线程抢占不到资源"><a href="#2-2-互斥锁的坑-线程抢占不到资源" class="headerlink" title="2.2 互斥锁的坑_线程抢占不到资源"></a>2.2 互斥锁的坑_线程抢占不到资源</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;thread&gt;
#include&lt;string&gt;
#include&lt;mutex&gt;

static std::mutex mux;

void ThreadMain(int i){
    for(;;){
        mux.lock();
        std::cout&lt;&lt;i&lt;&lt;"[in]"&lt;&lt;std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(1000));
        mux.unlock();
    }
}

int main(){
    for(int i=0;i&lt;3;++i){
        std::thread th(ThreadMain,i+1);
        th.detach();
    }
    getchar();
    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202303072336262.png" alt="image-20230307233615152"></p>
<p>有概率会出现一个线程一直抢占着资源，其他线程一直处于等待状态</p>
<p>调用unlock后，系统还来不及释放资源，就被该线程又给lock锁上了</p>
<hr>
<p>解决方法：在线程执行完毕后使其等待一会</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void ThreadMain(int i){
    for(;;){
        mux.lock();
        std::cout&lt;&lt;i&lt;&lt;"[in]"&lt;&lt;std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(1000));
        mux.unlock();
        std::this_thread::sleep_for(std::chrono::milliseconds(1));
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202303072339137.png" alt="image-20230307233916090"></p>
<h3 id="2-3-超时锁-timed-mutex"><a href="#2-3-超时锁-timed-mutex" class="headerlink" title="2.3 超时锁 timed_mutex"></a>2.3 超时锁 timed_mutex</h3><p>可以记录锁获取情况，多次超时，可以记录日志，获取错误情况</p>
<p>timed_mutex增加了带时限的try_lock，即<strong><em>try_lock_for</em></strong>和<strong><em>try_lock_until</em></strong></p>
<h4 id="try-lock-for"><a href="#try-lock-for" class="headerlink" title="try_lock_for"></a>try_lock_for</h4><p>尝试上锁，如果在规定时间内没能够上锁，则返回false，否则返回true</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;

static std::timed_mutex mutex;

void ThreadMain(int i) {
	if (!mutex.try_lock_for(std::chrono::microseconds(100))) {
		std::cout &lt;&lt; "Thread [" &lt;&lt; i &lt;&lt; "] fail to lock!" &lt;&lt; std::endl;
	}
	else {
		std::cout &lt;&lt; "Thread [" &lt;&lt; i &lt;&lt; "] success!" &lt;&lt; std::endl;
		std::this_thread::sleep_for(std::chrono::microseconds(100));
		mutex.unlock();
	}
}

int main() {
	for (int i = 1; i &lt;= 3; ++i) {
		std::thread th(ThreadMain, i);
		th.detach();
	}
	getchar();
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202303101203317.png" alt="image-20230310120307267"></p>
<h4 id="try-lock-until"><a href="#try-lock-until" class="headerlink" title="try_lock_until"></a>try_lock_until</h4><p>提供一个时间点作为参数，在到达该时间点之前如果仍未能上锁，则返回false，否则返回true</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;

static std::timed_mutex mutex;

void ThreadMain(int i) {
	if (!mutex.try_lock_until(std::chrono::steady_clock::now()+std::chrono::microseconds(100))) {
		std::cout &lt;&lt; "Thread [" &lt;&lt; i &lt;&lt; "] fail to lock!" &lt;&lt; std::endl;
	}
	else {
		std::cout &lt;&lt; "Thread [" &lt;&lt; i &lt;&lt; "] success!" &lt;&lt; std::endl;
		std::this_thread::sleep_for(std::chrono::microseconds(100));
		mutex.unlock();
	}
}

int main() {
	for (int i = 1; i &lt;= 3; ++i) {
		std::thread th(ThreadMain, i);
		th.detach();
	}
	getchar();
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="2-4-递归锁-可重入-recursive-mutex-和-recursive-timed-mutex"><a href="#2-4-递归锁-可重入-recursive-mutex-和-recursive-timed-mutex" class="headerlink" title="2.4 递归锁(可重入) recursive_mutex 和 recursive_timed_mutex"></a>2.4 递归锁(可重入) recursive_mutex 和 recursive_timed_mutex</h3><p>和互斥锁一样，递归锁也是一种锁类型，但递归锁允许同一个线程对同一个锁对象多次上锁，获得多层所有权，避免线程函数递归调用自身产生死锁；当解锁时，unlock函数调用的次数需要与lock函数调用的次数相同，即上多少次锁就应该解锁多少次</p>
<h4 id="recursive-mutex"><a href="#recursive-mutex" class="headerlink" title="recursive_mutex"></a>recursive_mutex</h4><p><strong>recursive_mutex::lock</strong></p>
<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">1、若recursive_mutex对象当前处于未上锁状态，则调用线程会对其上锁
2、若recursive_mutex对象会被其他线程上锁，则调用线程将阻塞，直到该对象被解锁
3、若recursive_mutex对象已经被该调用线程上锁，调用线程再次调用该函数，会获得对该recursive_mutex对象新的所有权级。而完全解锁该recursive_mutex对象需要调用相同次数的unlock函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><strong>recursive_mutex::try_lock</strong></p>
<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">bool try_lock() noexcept;
1、若该对象没有被其他线程上锁，则调用线程对其上锁，并返回true
2、若已被其他线程上锁，则返回false，但不阻塞调用线程
3、若锁住该recursive_mutex对象的线程与调用该函数的线程是同一个线程，则该线程会获得新的所有权级。同样地，需要调用相同次数的unlock函数才能完全解锁<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>recursive_mutex::unlock</strong></p>
<pre class="line-numbers language-none"><code class="language-none">1、解锁，并释放一个所有权级
2、若该对象未被调用线程上锁，调用该函数会导致undefine behavior<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong>示例</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;

static std::recursive_mutex mutex;

void Task1() {
    mutex.lock();
    std::cout &lt;&lt; "Task1" &lt;&lt; std::endl;
    mutex.unlock();
}

void Task2() {
    mutex.lock();
    std::cout &lt;&lt; "Task2" &lt;&lt; std::endl;
    mutex.lock();
}

void ThreadMain(int i) {
    for (;;) {
        mutex.lock();
        //如果不是递归锁，此时则会死锁，没法进入Task1函数
        //普通锁需要先解锁再进入，但此时可能被其他线程乘虚而入
        Task1();
        std::cout &lt;&lt; "Thread[" &lt;&lt; i &lt;&lt; "]" &lt;&lt; std::endl;
        std::this_thread::sleep_for(std::chrono::microseconds(1000));
        Task2();
        mutex.unlock();
        std::this_thread::sleep_for(std::chrono::microseconds(1));
    }
}

int main() {
    for (int i = 0; i &lt; 3; ++i) {
        std::thread th(ThreadMain, i + 1);
        th.detach();
    }
    getchar();
    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="recursive-timed-mutex"><a href="#recursive-timed-mutex" class="headerlink" title="recursive_timed_mutex"></a>recursive_timed_mutex</h4><p>递归定时互斥锁，将recursive_mutex和timed_mutex的功能结合到一个类中，它既支持通过单个线程获取多个锁定级别又支持定时的 try_lock 请求</p>
<h3 id="2-5-共享锁-shared-mutex"><a href="#2-5-共享锁-shared-mutex" class="headerlink" title="2.5 共享锁 shared_mutex"></a>2.5 共享锁 shared_mutex</h3><p>C++14提供了shared_mutex来解决读者—写者问题，也就是读写锁（共享锁），和普通锁不一样，读写锁同时能够拥有一个写者或者多个读者，但是不能同时存在读者和写者</p>
<h4 id="写锁-排他性锁定"><a href="#写锁-排他性锁定" class="headerlink" title="写锁(排他性锁定)"></a>写锁(排他性锁定)</h4><pre class="line-numbers language-none"><code class="language-none">1、lock
2、try_lock
3、unlock<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h4 id="读锁（共享锁定）"><a href="#读锁（共享锁定）" class="headerlink" title="读锁（共享锁定）"></a>读锁（共享锁定）</h4><pre class="line-numbers language-none"><code class="language-none">1、lock_shared
2、try_lock_shared
3、unlock_shared<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="2-6-std-call-once"><a href="#2-6-std-call-once" class="headerlink" title="2.6 std::call_once"></a>2.6 std::call_once</h3><p>在多线程编程中，有时某个函数只需要被执行一次，某些变量只需要初始化一次，此时可以考虑添加锁来控制，而在C++11中，提供了<strong><em>std::call_once</em></strong>函数来解决该问题，<strong><em>std::call_once</em></strong>函数需要配合<strong><em>std::once_flag</em></strong>来实现，也可以解决多线程安全的单例模式</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;mutex&gt;
#include&lt;thread&gt;

std::once_flag flag;

void display() {
	std::cout &lt;&lt; "Hello,World!" &lt;&lt; std::endl;
}

void ThreadOnce() {
	std::call_once(flag, display);
}

int main() {
	std::thread th1(ThreadOnce);
	std::thread th2(ThreadOnce);
	std::thread th3(ThreadOnce);
	th1.join();
	th2.join();
	th3.join();
	getchar();
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/img/202303091013309.png" alt="image-20230309101317218"></p>
<p>可以看到使用了三个线程，但是只打印了一遍   “Hello,World!”</p>
<h2 id="3-利用栈特性自动释放锁-RAII"><a href="#3-利用栈特性自动释放锁-RAII" class="headerlink" title="3 利用栈特性自动释放锁 RAII"></a>3 利用栈特性自动释放锁 RAII</h2><h3 id="3-1-RAII"><a href="#3-1-RAII" class="headerlink" title="3.1 RAII"></a>3.1 RAII</h3><pre class="line-numbers language-none"><code class="language-none">RAII(Resource Acquisition Is Initialization)是C++之父Bjarne Stroustrup提出的使用局部对象来管理资源的技术，称为资源获取即初始化；它的生命周期是由操作系统来管理的，无需人工介入；资源的销毁容易忘记，造成死锁或内存泄漏<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class XMutex {
public:
    XMutex(std::mutex&amp; mux) :mux_(mux) {
        std::cout &lt;&lt; "Lock" &lt;&lt; std::endl;
        mux.lock();
    }
    ~XMutex() {
        std::cout &lt;&lt; "Unlock" &lt;&lt; std::endl;
        mux_.unlock();
    }
private:
    std::mutex&amp; mux_;
};

static std::mutex mux;

void ThreadMain() {
    XMutex lock(mux);

    /*
    线程代码实现
    */
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>你可能会发现，这样写不是变得更麻烦了吗？</strong></p>
<p>其实不然，在你这样定义之后，你就不需再去管锁的释放问题，在一些时候，如果我们进行条件判断语句，需要在中途return，这样我们就需要在每个return，即每个可以退出线程的点之前都要进行一遍unlock，而使用RAII之后，只需要进行一遍上锁，就不需再去管后面的解锁的事了</p>
<p>如下面伪代码：</p>
<pre class="line-numbers language-none"><code class="language-none">void ThreadMain(){
	mutex.lock();
	if(条件一){
		......
		mutex.unlock();
		return;
	}else if(条件二){
		......
		mutex.unlock();
		return;
	}else if
	......
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如上面这种情况，如果改成RAII，就不需要去释放锁，更加方便，不会发生return时忘记释放锁的情况</p>
<h3 id="3-2-C-11-lock-guard"><a href="#3-2-C-11-lock-guard" class="headerlink" title="3.2 C++11 lock_guard"></a>3.2 C++11 lock_guard</h3><p><strong><em>lock_guard</em></strong>是C++11提出的新特性，是一个mutex封装者，使用了上述的RAII机制，在创建时加锁，析构时解锁，类似于智能指针，可以有效防止在线程使用mutex加锁后异常退出导致死锁的问题</p>
<p>使用方法跟上一节相差无几</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;mutex&gt;

std::mutex mux;
//创建时上锁
std::lock_guard&lt;std::mutex&gt; lock(mux);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="std-adopt-lock"><a href="#std-adopt-lock" class="headerlink" title="std::adopt_lock"></a>std::adopt_lock</h4><p><strong><em>lock_guard</em></strong>的第二参数只有<strong><em>std::adopt_lock</em></strong>这一种，表示在锁管理器即<strong><em>lock_guard</em></strong>构造的时候不会对锁对象进行上锁操作，有锁对象自己上锁，等锁管理器析构的时候自动化解锁</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::mutex mux;
{
	mux.lock();
	std::lock_guard&lt;std::mutex&gt; lock(mux,std::adopt_lock);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="3-3-C-11-unique-lock"><a href="#3-3-C-11-unique-lock" class="headerlink" title="3.3 C++11 unique_lock"></a>3.3 C++11 unique_lock</h3><p><strong>独占互斥所有权包装器</strong></p>
<p>C++11还提出了<strong><em>unique_lock</em></strong>的概念，<strong><em>unique_lock</em></strong>要比<strong><em>lock_guard</em></strong>灵活很多，可以手动进行解锁和上锁，因此在其内部会维护一个锁的状态，所以效率会差一点，内存占用也会多一点</p>
<h4 id="std-adopt-lock-1"><a href="#std-adopt-lock-1" class="headerlink" title="std::adopt_lock"></a>std::adopt_lock</h4><p>与<strong><em>lock_guard</em></strong>的<strong><em>std::adopt_lock</em></strong>含义相同</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">_NODISCARD_CTOR unique_lock(_Mutex&amp; _Mtx, adopt_lock_t)
       : _Pmtx(_STD addressof(_Mtx)), _Owns(true) {} // construct and assume already locked<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h4 id="std-try-to-lock"><a href="#std-try-to-lock" class="headerlink" title="std::try_to_lock"></a>std::try_to_lock</h4><p>初始化锁管理器，并尝试对锁进行上锁</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">_NODISCARD_CTOR unique_lock(_Mutex&amp; _Mtx, try_to_lock_t)
        : _Pmtx(_STD addressof(_Mtx)), _Owns(_Pmtx-&gt;try_lock()) {} // construct and try to lock<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h5 id="owns-lock"><a href="#owns-lock" class="headerlink" title="owns_lock"></a>owns_lock</h5><p>返回锁的上锁情况</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">_NODISCARD bool owns_lock() const noexcept {
        return _Owns;
    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>可以与<strong><em>try_to_lock</em></strong>配合使用</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::mutex mux;
std::unique_lock&lt;std::mutex&gt; lock(mux,std::try_to_lock);
if(lock.owns_lock){
    ......
}else{
	......
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="std-defer-lock"><a href="#std-defer-lock" class="headerlink" title="std::defer_lock"></a>std::defer_lock</h4><p>不同于<strong><em>std::adopt_lock</em></strong>和<strong><em>std::try_to_lock</em></strong>：</p>
<ul>
<li>std::adopt_lock在初始化时已经将成员 _Owns 置为true，表示处于上锁状态</li>
<li>std::try_to_lock则会在创建时对锁对象进行尝试上锁</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">unique_lock(_Mutex&amp; _Mtx, defer_lock_t) noexcept
        : _Pmtx(_STD addressof(_Mtx)), _Owns(false) {} // construct but don't lock<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong><em>std::defer_lock</em></strong>参数在初始化锁管理器时不会对锁进行上锁，方便与<strong><em>unique_lock</em></strong>的成员函数进行配合使用</p>
<h4 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h4><p>在观看unique_lock的源码时，发现他还提供了另外两种构造函数：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//传入时间数，使用try_lock_for
_NODISCARD_CTOR unique_lock(_Mutex&amp; _Mtx, const chrono::duration&lt;_Rep, _Period&gt;&amp; _Rel_time)
        : _Pmtx(_STD addressof(_Mtx)), _Owns(_Pmtx-&gt;try_lock_for(_Rel_time)) {} // construct and lock with timeout

//传入时间点，使用try_lock_until
_NODISCARD_CTOR unique_lock(_Mutex&amp; _Mtx, const chrono::time_point&lt;_Clock, _Duration&gt;&amp; _Abs_time)
        : _Pmtx(_STD addressof(_Mtx)), _Owns(_Pmtx-&gt;try_lock_until(_Abs_time)) {
        // construct and lock with timeout<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="lock"><a href="#lock" class="headerlink" title="lock()"></a>lock()</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::mutex mux;
std::unique_lock&lt;std::mutex&gt; lock(mux,std::defer_lock);
lock.lock();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>对锁进行上锁</p>
<h4 id="unlock"><a href="#unlock" class="headerlink" title="unlock()"></a>unlock()</h4><p><strong><em>unique_lock</em></strong>可以使用<strong><em>unlock</em></strong>函数来对锁进行解锁，提前解锁来运行一些不需要共享数据的代码，这可以使我们的代码更加效率和灵活</p>
<h4 id="try-lock-1"><a href="#try-lock-1" class="headerlink" title="try_lock()"></a>try_lock()</h4><p>类似于参数<strong><em>std::try_to_lock</em></strong>，在不阻塞的情况下进行<strong><em>lock</em></strong>，如果加锁成功，那么返回<strong><em>true</em></strong>，如果没有加锁成功，那么返回false</p>
<p><strong><em>unique_lock</em></strong>也有<strong><em>try_lock_for</em></strong>和<strong><em>try_lock_until</em></strong>成员函数</p>
<h4 id="release"><a href="#release" class="headerlink" title="release()"></a>release()</h4><p><strong><em>release()</em></strong>会返回它所管理的<strong><em>mutex</em></strong>对象指针，并释放所有权（也就是说，这个<strong><em>unique_lock</em></strong>和<strong><em>mutex</em></strong>不再有关系）</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">_Mutex* release() noexcept {
        _Mutex* _Res = _Pmtx;
        _Pmtx        = nullptr;
        _Owns        = false;
        return _Res;
    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>需要注意的是：==release的时候，并不会对锁的上锁情况进行改变==，所以需要对锁进行手动解锁</p>
<h4 id="所有权的传递"><a href="#所有权的传递" class="headerlink" title="所有权的传递"></a>所有权的传递</h4><p><strong><em>unique_lock</em></strong>和<strong><em>mutex</em></strong>是绑定在一起的，即<strong><em>unique_lock</em></strong>拥有该<strong><em>mutex</em></strong>的所有权，而这个所有权是可以转移的</p>
<p>==一般一个锁管理器对应一个锁，如果出现一对多或者多对一的情况，容易造成死锁==</p>
<h5 id="move"><a href="#move" class="headerlink" title="move"></a>move</h5><p>通过move来转移所有权</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::mutex mux;
std::unique_lock&lt;std::mutex&gt; lock1(mux,std::defer_lock);
std::unique_lock&lt;std::mutex&gt; lock2(std::move(lock1));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h5 id="return"><a href="#return" class="headerlink" title="return"></a>return</h5><p>通过return来转移</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::mutex mux;
std::unique_lock&lt;std::mutex&gt; lock1(){
	std::unique_lock&lt;std::mutex&gt; lock2(mux);
	return lock2;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="粒度"><a href="#粒度" class="headerlink" title="粒度"></a>粒度</h4><p>为什么我们使用了锁管理器后还要有unlock方法</p>
<p>对于一个程序来所，你lock()锁住的代码越少，执行越快，整个程序的效率就会越高，一般把锁住代码的多少称为<strong><em>锁的粒度</em></strong>，用粗细来描述</p>
<ul>
<li>锁住的代码少，这个粒度叫细，执行效率高</li>
<li>锁住的代码多，这个粒度叫粗，执行效率低</li>
</ul>
<p>在使用锁的时候，应该选择合适的粒度</p>
<h3 id="3-4-C-14-shared-lock"><a href="#3-4-C-14-shared-lock" class="headerlink" title="3.4 C++14 shared_lock"></a>3.4 C++14 shared_lock</h3><p><strong>共享互斥所有权包装器</strong></p>
<p><strong>shared_lock需要与shared_mutex配合使用</strong>，被锁后允许其他线程继续对其进行上锁，但不允许同一个线程在已经上锁的情况下继续上锁</p>
<p>同<strong><em>unqiue_lock</em></strong>一样，同样拥有在<strong><em>unique_lock</em></strong>中提到的五个构造函数，并且与<strong><em>unique_lock</em></strong>一样能进行所有权的转移</p>
<h5 id="常用成员函数"><a href="#常用成员函数" class="headerlink" title="常用成员函数"></a>常用成员函数</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void lock();
bool try_lock();
bool try_lock_for(const chrono::duration&lt;_Rep, _Period&gt;&amp; _Rel_time);
bool try_lock_until(const chrono::time_point&lt;_Clock, _Duration&gt;&amp; _Abs_time)
void unlock();
bool owns_lock();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="3-5-C-17-scoped-lock"><a href="#3-5-C-17-scoped-lock" class="headerlink" title="3.5 C++17 scoped_lock"></a>3.5 C++17 scoped_lock</h3><p><strong>区域锁</strong></p>
<p><strong><em>scoped_lock</em></strong>与<strong><em>lock_guard</em></strong>完全等价，只不过<strong><em>scoped_lock</em></strong>是可变参数模板，可以在构造时一次性接受多个锁进行统一上锁</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::mutex mux1, mux2, mux3;
std::scoped_lock lock1(mux1,mux2,mux3);
//或
std::scoped_lock &lt;std::mutex,std::mutex,std::mutex&gt; lock1(mux1,mux2,mux3);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用了<strong><em>std::lock_guard&lt;&gt;</em></strong>模板，C++17具有隐式类模板参数推导，会自动根据参数进行匹配</p>
<p><strong>源码</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#if _HAS_CXX17
template &lt;class... _Mutexes&gt;
class _NODISCARD scoped_lock { // class with destructor that unlocks mutexes
public:
    explicit scoped_lock(_Mutexes&amp;... _Mtxes) : _MyMutexes(_Mtxes...) { // construct and lock
        _STD lock(_Mtxes...);
    }

    explicit scoped_lock(adopt_lock_t, _Mutexes&amp;... _Mtxes) : _MyMutexes(_Mtxes...) {} // construct but don't lock

    ~scoped_lock() noexcept {
        _STD apply([](_Mutexes&amp;... _Mtxes) { (..., (void) _Mtxes.unlock()); }, _MyMutexes);
    }

    scoped_lock(const scoped_lock&amp;) = delete;
    scoped_lock&amp; operator=(const scoped_lock&amp;) = delete;

private:
    tuple&lt;_Mutexes&amp;...&gt; _MyMutexes;
};

template &lt;class _Mutex&gt;
class _NODISCARD scoped_lock&lt;_Mutex&gt; {
public:
    using mutex_type = _Mutex;

    explicit scoped_lock(_Mutex&amp; _Mtx) : _MyMutex(_Mtx) { // construct and lock
        _MyMutex.lock();
    }

    explicit scoped_lock(adopt_lock_t, _Mutex&amp; _Mtx) : _MyMutex(_Mtx) {} // construct but don't lock

    ~scoped_lock() noexcept {
        _MyMutex.unlock();
    }

    scoped_lock(const scoped_lock&amp;) = delete;
    scoped_lock&amp; operator=(const scoped_lock&amp;) = delete;

private:
    _Mutex&amp; _MyMutex;
};

template &lt;&gt;
class scoped_lock&lt;&gt; {
public:
    explicit scoped_lock() {}
    explicit scoped_lock(adopt_lock_t) {}
    ~scoped_lock() noexcept {}

    scoped_lock(const scoped_lock&amp;) = delete;
    scoped_lock&amp; operator=(const scoped_lock&amp;) = delete;
};
#endif // _HAS_CXX17<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="3-6-condition-variable-条件变量"><a href="#3-6-condition-variable-条件变量" class="headerlink" title="3.6 condition_variable 条件变量"></a>3.6 condition_variable 条件变量</h3><p>互斥量是多线程间同时访问某一个共享变量时候，保证变量可以被<strong><em>安全访问</em></strong>的手段，但是，单靠互斥量是无法保证多个线程间的同步</p>
<p>在生产者消费者模型中，生产者线程将 “消息” 写入到公共队列中，消费者线程则从公共队列中取出 “消息” ，如果只使用互斥量mutex， 我们最容易想到的就是设置一个时间间隔，让消费者线程每过一段时间就去判断公共队列中是否有 “消息” ，如果有就读取，没有就sleep一个时间间隔</p>
<p>而上述方法有一个很大的缺点，你无法来设置一个合适的时间间隔，如果时间间隔太短，就会进行多次无效的查询，减低程序的性能；如果时间间隔太长，就会使用户无法及时收到消息，降低用户的体验</p>
<p>C++11提供了条件变量来解决这种情况，条件变量位于头文件 condition_variable 下</p>
<hr>
<h4 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h4><p>函数原型</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void wait(unique_lock&lt;mutex&gt;&amp; _Lck) { // wait for signal
    // Nothing to do to comply with LWG-2135 because std::mutex lock/unlock are nothrow
    _Cnd_wait(_Mycnd(), _Lck.mutex()-&gt;_Mymtx());
}
template &lt;class _Predicate&gt;
void wait(unique_lock&lt;mutex&gt;&amp; _Lck, _Predicate _Pred) { // wait for signal and test predicate
    while (!_Pred()) {
        wait(_Lck);
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong><em>condition_variable</em></strong>提供了两种wait函数，当前线程调用了<strong><em>wait</em></strong>函数后会被阻塞（<strong>在此之前当前线程应该已经获得锁</strong>），直到另一个线程调用<strong><em>notify</em></strong>函数来唤醒该线程</p>
<p>值得注意的是，在调用完wait函数后，当前线程会先释放锁，使得其他线程得以执行，再将该线程挂起，而在该线程被唤醒时，会尝试重新去获得锁</p>
<p>第二个<strong><em>wait</em></strong>函数，多了一个条件<strong>_pred</strong>（lambda表达式），只有当<strong>_pred</strong>条件为false时，调用<strong>wait</strong>才会挂起当前线程，在被通知唤醒时，只有<strong>_pred</strong>条件为<strong>true</strong>时才会解除阻塞，可以用来解决一些 <strong><em>虚假唤醒</em></strong> 的问题</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//以下两种表达等价

wait(lck,_pred);
//==============
while(_pred){wait(lck);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>另外，<strong><em>condition_variable</em></strong>还提供了 <strong>wait_for</strong> 和 <strong>wait_until</strong> 函数</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class _Rep, class _Period&gt;
    cv_status wait_for(unique_lock&lt;mutex&gt;&amp; _Lck, const chrono::duration&lt;_Rep, _Period&gt;&amp; _Rel_time);

template &lt;class _Rep, class _Period, class _Predicate&gt;
    bool wait_for(unique_lock&lt;mutex&gt;&amp; _Lck, const chrono::duration&lt;_Rep, _Period&gt;&amp; _Rel_time, _Predicate _Pred);
    
template &lt;class _Clock, class _Duration&gt;
    cv_status wait_until(unique_lock&lt;mutex&gt;&amp; _Lck, const chrono::time_point&lt;_Clock, _Duration&gt;&amp; _Abs_time);

template &lt;class _Clock, class _Duration, class _Predicate&gt;
bool wait_until(unique_lock&lt;mutex&gt;&amp; _Lck, const chrono::time_point&lt;_Clock, _Duration&gt;&amp; _Abs_time, _Predicate _Pred);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="notify"><a href="#notify" class="headerlink" title="notify"></a>notify</h4><h5 id="notify-one"><a href="#notify-one" class="headerlink" title="notify_one"></a>notify_one</h5><p>唤醒当前正在等待的某一个线程，如果当前没有线程在等待，则该函数什么都不做</p>
<p><strong>而如果同时存在多个等待线程，则唤醒某一个线程是不确定的</strong></p>
<h5 id="notify-all"><a href="#notify-all" class="headerlink" title="notify_all"></a>notify_all</h5><p>唤醒正在等待的<strong>所有</strong>线程</p>
<h4 id="示例-生产者消费者"><a href="#示例-生产者消费者" class="headerlink" title="示例-生产者消费者"></a>示例-生产者消费者</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;condition_variable&gt;
#include&lt;mutex&gt;
#include&lt;iostream&gt;
#include&lt;thread&gt;
#include&lt;deque&gt;
#include&lt;string&gt;

std::condition_variable cv; //条件变量
std::mutex mux; //全局互斥锁
std::deque&lt;int&gt; dq; //消息队列

//生产者
void producer() {
	int i = 0;
	while (true) {
		std::unique_lock&lt;std::mutex&gt;lock(mux); 
		dq.push_back(i);
		cv.notify_one();//唤醒消费者线程
		++i;
	}
}

//消费者
void consumer() {
	int data;
	while (true) {
		std::unique_lock&lt;std::mutex&gt;lock(mux);
		if (dq.empty()) cv.wait(lock); //进入等待
		data = dq.front();
		dq.pop_front();
		//打印消息
		std::cout &lt;&lt; "Get Value: " &lt;&lt; data &lt;&lt; std::endl;
	}
}

int main() {
	std::thread th1(consumer);
	std::thread th2(producer);

	th1.join();
	th2.join();

	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/image-20230402220515173.png" alt="image-20230402220515173"></p>
<h4 id="虚假唤醒"><a href="#虚假唤醒" class="headerlink" title="虚假唤醒"></a>虚假唤醒</h4><p>对于生产者-消费者模型来说，如果我们有两个消费者来接收生产者的消息，如下程序所示</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;condition_variable&gt;
#include&lt;mutex&gt;
#include&lt;iostream&gt;
#include&lt;thread&gt;
#include&lt;deque&gt;
#include&lt;string&gt;

std::condition_variable cv; //条件变量
std::mutex mux; //全局互斥锁
std::deque&lt;int&gt; dq; //消息队列

//生产者
void producer() {
	int i = 0;
	while (true) {
		std::unique_lock&lt;std::mutex&gt;lock(mux); 
		dq.push_back(i);
		cv.notify_one();//唤醒消费者线程
		++i;
	}
}

//消费者
void consumer(int index) {
	int data;
	while (true) {
		std::unique_lock&lt;std::mutex&gt;lock(mux);
		if (dq.empty()) cv.wait(lock); //进入等待
		data = dq.front();
		dq.pop_front();
		//打印消息
		std::cout &lt;&lt; "Consumer " &lt;&lt; index &lt;&lt; " Get Value: " &lt;&lt; data &lt;&lt; std::endl;
	}
}

int main() {
	std::thread th1(consumer,1);//消费者1
	std::thread th2(consumer,2);//消费者2
	std::thread th3(producer);//生产者

	th1.join();
	th2.join();
	th3.join();

	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="C:\Users\lvxr\AppData\Roaming\Typora\typora-user-images\image-20230406170429481.png" alt="image-20230406170429481"></p>
<p>为什么会出现这种原因？可以注意到提示是从一个空的deque中去取值</p>
<p>分析可得，</p>
<ul>
<li>生产者生产一条消息</li>
<li>生产者唤醒消费者1</li>
<li>消费者1尝试获得锁失败，生产者再次获得锁</li>
<li>生产者再提供一条消息</li>
<li>生产者唤醒消费者2</li>
<li>消费者1连续获得两次锁，打印两条消息</li>
<li>消费者2获得锁，此时队列中没有消息，程序错误</li>
</ul>
<p>这就是利用<strong>if包裹的wait函数</strong>产生的虚假唤醒问题，改用<strong>while包裹或者使用第二种wait函数</strong>可以有效解决该问题</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;condition_variable&gt;
#include&lt;mutex&gt;
#include&lt;iostream&gt;
#include&lt;thread&gt;
#include&lt;deque&gt;
#include&lt;string&gt;

std::condition_variable cv; //条件变量
std::mutex mux; //全局互斥锁
std::deque&lt;int&gt; dq; //消息队列

//生产者
void producer() {
	int i = 0;
	while (true) {
		std::unique_lock&lt;std::mutex&gt;lock(mux); 
		dq.push_back(i);
		cv.notify_all();//唤醒消费者线程
		++i;
	}
}

//消费者
void consumer(int index) {
	int data;
	while (true) {
		std::unique_lock&lt;std::mutex&gt;lock(mux);
		cv.wait(lock, [=]() {return !dq.empty(); });//进入等待
		data = dq.front();
		dq.pop_front();
		//打印消息
		std::cout &lt;&lt; "Consumer " &lt;&lt; index &lt;&lt; " Get Value: " &lt;&lt; data &lt;&lt; std::endl;
	}
}

int main() {
	std::thread th1(consumer,1);//消费者1
	std::thread th2(consumer,2);//消费者2
	std::thread th3(producer);//生产者

	th1.join();
	th2.join();
	th3.join();

	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/image-20230406171909775.png" alt="image-20230406171909775"></p>
<p>如果是一次性的生产，即生产者只通知一次，需保证消费者先执行，否则可能生产者通知了，消费者还未执行到wait语句</p>
<h2 id="4-线程的异步和通信"><a href="#4-线程的异步和通信" class="headerlink" title="4 线程的异步和通信"></a>4 线程的异步和通信</h2><h3 id="4-1-promise-和-future"><a href="#4-1-promise-和-future" class="headerlink" title="4.1 promise 和 future"></a>4.1 promise 和 future</h3><p><strong><em>promise</em></strong>和<strong><em>future</em></strong>的作用是在不同线程之间传递数据，使用指针也可以完成数据的传递，但是指针非常危险，因为斥量不能阻止指针的访问，而且指针的方式传递的数据是固定的，如果更改数据类型，那么还需要更改有关的接口，比较麻烦；promise支持泛型的操作，更加方便编程处理</p>
<hr>
<p><strong><em>promise</em></strong>和<strong><em>future</em></strong>是一种单向的数据传递，promise是数据的输入端，future是数据的输入端</p>
<hr>
<p>在使用时，先创建一个promise对象，从promise对象调用get_future得到future对象，将promise对象或future对像作为线程参数传给另一个线程，这样future对象可以通过get函数来获得promise对象设定得值，如果使用get时promise对象还未设定值，则future会阻塞该线程直到获得值</p>
<blockquote id="fn_注">
<sup>注</sup>. future和promise对象不能够拷贝，所以要使用std::move/std::ref<a href="#reffn_注" title="Jump back to footnote [注] in the text."> ↩</a>
</blockquote>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;

void TestThread(std::promise&lt;int&gt;&amp; promiseobj) {
	std::this_thread::sleep_for(std::chrono::milliseconds(1000));
	std::cout &lt;&lt; "IN TestThread" &lt;&lt; std::endl;
	std::this_thread::sleep_for(std::chrono::milliseconds(1000));
	std::cout &lt;&lt; "Set Value" &lt;&lt; std::endl;
	promiseobj.set_value(101);
	std::this_thread::sleep_for(std::chrono::milliseconds(1000));
	std::cout &lt;&lt; "Out TestThread" &lt;&lt; std::endl;
}

int main() {
	std::promise&lt;int&gt; promiseobj;
	std::future&lt;int&gt; futureobj = promiseobj.get_future();
	std::thread th(TestThread, std::ref(promiseobj));
	std::cout &lt;&lt; "Get Value" &lt;&lt; std::endl;
	std::cout &lt;&lt; futureobj.get() &lt;&lt; std::endl;
	th.join();
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/image-20230407141410301.png" alt="image-20230407141410301"></p>
<h3 id="4-2-packaged-task异步调用函数打包"><a href="#4-2-packaged-task异步调用函数打包" class="headerlink" title="4.2 packaged_task异步调用函数打包"></a>4.2 packaged_task异步调用函数打包</h3><p><strong><em>packaged_task</em></strong>和<strong><em>promise</em></strong>十分相似，packaged_task封装了可调用实体（即函数，lambda函数或函数对象）</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">std::packaged_task&lt;F&gt; 
//类似于
std::promise&lt;T= std::function&lt;F&gt;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;future&gt;
#include &lt;thread&gt;

int Test(int a, int b) {
	std::cout &lt;&lt; "START" &lt;&lt; std::endl;
	std::this_thread::sleep_for(std::chrono::milliseconds(1000));
	return a + b;
}

int main() {
	std::packaged_task&lt;int(int, int)&gt; pt(Test);
	std::future&lt;int&gt; futureobj = pt.get_future();
	std::thread th1(std::move(pt), 1, 2);
    //packaged_task也禁用了拷贝函数，所以要使用std::move
	std::this_thread::sleep_for(std::chrono::milliseconds(100));
	std::cout &lt;&lt; "GET VALUE = " &lt;&lt; futureobj.get() &lt;&lt; std::endl;
	th1.join();
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/image-20230407144323255.png" alt="image-20230407144323255"></p>
<h4 id="std-packaged-task-valid"><a href="#std-packaged-task-valid" class="headerlink" title="std::packaged_task::valid"></a>std::packaged_task::valid</h4><p>该函数用于判断std::packaged_task对象是否是有效状态。当通过缺省构造初始化时，由于其未设置任何可调用对象或函数，valid会返回false。只有当std::packaged_task设置了有效的函数或可调用对象，valid才返回true</p>
<h4 id="std-packaged-task-swap"><a href="#std-packaged-task-swap" class="headerlink" title="std::packaged_task::swap"></a>std::packaged_task::swap</h4><p>将两个<code>std::packaged_task</code>对象所关联的共享状态和存储任务的所有权进行交换</p>
<h3 id="4-3-async"><a href="#4-3-async" class="headerlink" title="4.3 async"></a>4.3 async</h3><p><strong><em>std::async</em></strong>是一个接受回调（函数/函数对象）作为参数的函数模板，并且<strong><em>有可能异步</em></strong>执行该函数，返回一个future对象</p>
<h4 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class _Fty, class... _ArgTypes&gt;
_NODISCARD future&lt;_Invoke_result_t&lt;decay_t&lt;_Fty&gt;, decay_t&lt;_ArgTypes&gt;...&gt;&gt; async(
    launch _Policy, _Fty&amp;&amp; _Fnarg, _ArgTypes&amp;&amp;... _Args) {
    // manages a callable object launched with supplied policy
    using _Ret   = _Invoke_result_t&lt;decay_t&lt;_Fty&gt;, decay_t&lt;_ArgTypes&gt;...&gt;;
    using _Ptype = typename _P_arg_type&lt;_Ret&gt;::type;
    _Promise&lt;_Ptype&gt; _Pr(
        _Get_associated_state&lt;_Ret&gt;(_Policy, _Fake_no_copy_callable_adapter&lt;_Fty, _ArgTypes...&gt;(
                                                 _STD forward&lt;_Fty&gt;(_Fnarg), _STD forward&lt;_ArgTypes&gt;(_Args)...)));

    return future&lt;_Ret&gt;(_Pr._Get_state_for_future(), _Nil());
}

template &lt;class _Fty, class... _ArgTypes&gt;
_NODISCARD future&lt;_Invoke_result_t&lt;decay_t&lt;_Fty&gt;, decay_t&lt;_ArgTypes&gt;...&gt;&gt; async(_Fty&amp;&amp; _Fnarg, _ArgTypes&amp;&amp;... _Args) {
    // manages a callable object launched with default policy
    return _STD async(launch::async | launch::deferred, _STD forward&lt;_Fty&gt;(_Fnarg), _STD forward&lt;_ArgTypes&gt;(_Args)...);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到第一个提供三个参数，第一个为std::launch中的两个标志位：</p>
<ul>
<li>launch::async：创建异步线程并绑定future对象，一定会创建线程</li>
<li>launch::deferred：延时绑定，等待future对象调用get函数时才开始同步执行，不创建线程，属于同步任务</li>
<li>launch::async|launch::deferred：默认值，可以异步执行或者不异步，取决于系统的负载，即系统资源不够创建一个新线程时，那么就创建一个同步任务（deferred）</li>
</ul>
<h4 id="示例-async"><a href="#示例-async" class="headerlink" title="示例-async"></a>示例-async</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;thread&gt;
#include &lt;iostream&gt;
#include &lt;future&gt;


int Test()
{
	std::cout &lt;&lt; "START,THREAD ID IS " &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
	return 1;
}

int main()
{
	std::cout &lt;&lt; "MAIN THREAD ID IS " &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
	std::this_thread::sleep_for(std::chrono::microseconds(1000));
	std::future&lt;int&gt; result = std::async(std::launch::async, Test);
	//异步执行，一定会创建线程
	int res = result.get();
	std::cout &lt;&lt; res &lt;&lt; std::endl;
	return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/image-20230407152252132.png" alt="image-20230407152252132"></p>
<h4 id="示例-deferred"><a href="#示例-deferred" class="headerlink" title="示例-deferred"></a>示例-deferred</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;thread&gt;
#include &lt;iostream&gt;
#include &lt;future&gt;


int Test()
{
	std::cout &lt;&lt; "START,THREAD ID IS " &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
	return 1;
}

int main()
{
	std::future&lt;int&gt; result = std::async(std::launch::deferred, Test);
	//延时调用，不创建线程
	std::this_thread::sleep_for(std::chrono::microseconds(1000));
	//可以看到改行将先输出
	std::cout &lt;&lt; "MAIN THREAD ID IS " &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
	int res = result.get();
	std::cout &lt;&lt; res &lt;&lt; std::endl;
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://gitee.com/renmale-sztu/image/raw/master/image-20230407152502311.png" alt="image-20230407152502311"></p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>Post author:  </strong>renmale-lv
  </li>
  <li class="post-copyright-link">
      <strong>Post link: </strong>
      <a href="http://example.com/2023/02/19/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/" title="C++多线程基础">http://example.com/2023/02/19/C++多线程基础/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/12/02/%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA-PAM/" rel="prev" title="回文自动机(PAM)">
                  <i class="fa fa-chevron-left"></i> 回文自动机(PAM)
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/03/22/Day-Plan/" rel="next" title="Day_Plan">
                  Day_Plan <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">renmale-lv</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>Word count total: </span>
    <span title="Word count total">50k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>Reading time total &asymp;</span>
    <span title="Reading time total">45 mins.</span>
  </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>
<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>  Sometimes your whole life boils down to one insame move.
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("11/05/2022 00:00:00");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
}
setInterval("createtime()",250);
</script>
    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"renmale-lv","repo":"renmale-lv.github.io","client_id":"a7032a206391d1242a3c","client_secret":"5beb16ecce13a96a943bce7252eab7ab77218b9d","admin_user":"renmale-lv","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"94d7abf9f282e4876c2bf0fc9dd3c4c0"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/clicklove.js"></script>
