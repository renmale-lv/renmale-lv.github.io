<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="3.1 内存管理概念3.1.1内存管理的基本原理和要求内存管理的功能  内存空间的分配与回收  由操作系统完成主存储器空间的分配和管理，使程序员摆脱存储分配的麻烦，提高编程效率   地址转换  在多道程序环境下，程序中的逻辑地址与内存中的物理地址不可能一致，因此存储管理必须提供地址变换功能，把逻辑地址转换成相应的物理地址   内存空间的扩充  利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统—第三章—内存管理">
<meta property="og:url" content="http://example.com/2023/09/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/index.html">
<meta property="og:site_name" content="renmale-lv blog">
<meta property="og:description" content="3.1 内存管理概念3.1.1内存管理的基本原理和要求内存管理的功能  内存空间的分配与回收  由操作系统完成主存储器空间的分配和管理，使程序员摆脱存储分配的麻烦，提高编程效率   地址转换  在多道程序环境下，程序中的逻辑地址与内存中的物理地址不可能一致，因此存储管理必须提供地址变换功能，把逻辑地址转换成相应的物理地址   内存空间的扩充  利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/202309031608870.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/202309031607409.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/202309031607273.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/202309031937364.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/202309041913870.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/202309041917922.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/202309041924860.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/202309041922520.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/202309041930281.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/202309041936325.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/202309041951525.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/202309041952608.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/202309041958378.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/202309042000900.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/202309042001366.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/202309042023970.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/202309042027016.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/202309051537126.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/202309051541445.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/202309051710784.png">
<meta property="og:image" content="https://gitee.com/renmale-sztu/image/raw/master/202309051930871.png">
<meta property="article:published_time" content="2023-09-06T04:27:13.000Z">
<meta property="article:modified_time" content="2023-09-10T06:39:46.208Z">
<meta property="article:author" content="renmale-lv">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/renmale-sztu/image/raw/master/202309031608870.png">

<link rel="canonical" href="http://example.com/2023/09/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>操作系统—第三章—内存管理 | renmale-lv blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="renmale-lv blog" type="application/atom+xml">
<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">renmale-lv blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录学习点滴</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="renmale-lv">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="renmale-lv blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统—第三章—内存管理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-09-06 12:27:13" itemprop="dateCreated datePublished" datetime="2023-09-06T12:27:13+08:00">2023-09-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-09-10 14:39:46" itemprop="dateModified" datetime="2023-09-10T14:39:46+08:00">2023-09-10</time>
              </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>9.3k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>8 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <meta name="referrer" content="no-referrer">

<h2 id="3-1-内存管理概念"><a href="#3-1-内存管理概念" class="headerlink" title="3.1 内存管理概念"></a>3.1 内存管理概念</h2><h3 id="3-1-1内存管理的基本原理和要求"><a href="#3-1-1内存管理的基本原理和要求" class="headerlink" title="3.1.1内存管理的基本原理和要求"></a>3.1.1内存管理的基本原理和要求</h3><p><strong>内存管理的功能</strong></p>
<ul>
<li><p>内存空间的分配与回收</p>
<ul>
<li>由操作系统完成主存储器空间的分配和管理，使程序员摆脱存储分配的麻烦，提高编程效率</li>
</ul>
</li>
<li><p>地址转换</p>
<ul>
<li>在多道程序环境下，程序中的逻辑地址与内存中的物理地址不可能一致，因此存储管理必须提供地址变换功能，把逻辑地址转换成相应的物理地址</li>
</ul>
</li>
<li><p>内存空间的扩充</p>
<ul>
<li>利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存</li>
</ul>
</li>
<li><p>内存共享</p>
<ul>
<li>指允许多个进程访问内存的同一部分</li>
</ul>
</li>
<li><p>存储保护</p>
<ul>
<li>保证各道作业在各自的存储空间内运行，互不干扰</li>
</ul>
</li>
</ul>
<span id="more"></span>
<p><strong>程序装入和链接</strong></p>
<ul>
<li>步骤<ul>
<li>编译<ul>
<li>由编译程序将用户源代码编译成若干目标模块</li>
</ul>
</li>
<li>链接<ul>
<li>由链接程序将编译后形成的一组目标模块及™所需的库函数链接在一起，形成一个完整的装入模块</li>
</ul>
</li>
<li>装入<ul>
<li>由转装入程序将装入模块装入内存运行</li>
</ul>
</li>
</ul>
</li>
<li>程序的链接方式<ul>
<li>静态链接<ul>
<li>在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开</li>
</ul>
</li>
<li>装入时动态链接<ul>
<li>将各目标模块装入内存时，边装入边链接的链接方式，其优点是便于修改和更新，便于实现对目标模块的共享</li>
</ul>
</li>
<li>运行时动态链接<ul>
<li>在程序执行中需要该目标模块时，才对它进行链接，其优点是能加快程序的装入过程，还可节省大量的内存空间</li>
</ul>
</li>
</ul>
</li>
<li>内存的装入<ul>
<li>绝对装入<ul>
<li>概念<ul>
<li>在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存</li>
<li>编译和链接时就改变地址</li>
</ul>
</li>
<li>只适用于单道程序环境</li>
</ul>
</li>
<li>可重定位装入<ul>
<li>概念<ul>
<li>又称静态重定位</li>
<li>编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址</li>
<li>可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“重定位”，将逻辑地址变换为物理地址</li>
<li>地址变换是在装入时一次完成的</li>
</ul>
</li>
<li>必须分配其要求的全部内存空间</li>
<li>在运行期间就不能再移动</li>
</ul>
</li>
<li>动态运行时装入<ul>
<li>概念<ul>
<li>也称动态重定位</li>
<li>装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行</li>
<li>装入内存后所有的地址依然是逻辑地址</li>
<li>需要一个重定位寄存器的支持。</li>
</ul>
</li>
<li>可以将程序分配道不连续的存储区</li>
<li>在程序运行之前可以指装入部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存</li>
<li>便于程序段的共享</li>
</ul>
</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309031608870.png" alt="image-20230903160809914"></li>
</ul>
</li>
</ul>
<p><strong>逻辑地址空间与物理地址空间</strong></p>
<ul>
<li>相对地址（逻辑地址）<ul>
<li>编译后，每个目标模块都从0号单元开始编制，这称为目标模块的相对地址</li>
<li>链接程序顺序一次按各个模块的相对地址构成统一的从0号单元开始编址的逻辑地址空间（虚拟地址空间），对于32位系统，逻辑地址空间的范围为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="11.466ex" height="2.072ex" role="img" focusable="false" viewBox="0 -833.9 5068.1 915.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mo" transform="translate(777.8,0)"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g><g data-mml-node="msup" transform="translate(2055.6,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path></g></g></g><g data-mml-node="mo" transform="translate(3567.9,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(4568.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container></li>
</ul>
</li>
<li>物理地址空间<ul>
<li>内存中物理单元的集合，地址转换的最终地址</li>
</ul>
</li>
<li>地址重定位<ul>
<li>逻辑地址转换为物理地址的过程</li>
<li>通过内存管理部件（MMU）来实现</li>
</ul>
</li>
</ul>
<p><strong>进程的内存映像</strong></p>
<ul>
<li>组成<ul>
<li>代码段<ul>
<li>即程序的二进制代码，代码段是只读的，可以被多个进程共享</li>
</ul>
</li>
<li>数据段<ul>
<li>即程序运行时加工处理的对象，包括全局变量和静态变量</li>
</ul>
</li>
<li>进程控制块（PCB）<ul>
<li>存放在系统区。操作系统通过PCB来控制和管理进程</li>
</ul>
</li>
<li>栈<ul>
<li>用来存放动态分配的变量。通过调用mall oc函数动态地向高地址分配空间</li>
</ul>
</li>
<li>堆<ul>
<li>用来实现函数调用。从用户空间的最大地址往低地址方向增长</li>
</ul>
</li>
</ul>
</li>
<li>代码段和数据段在程序调入内存时就指定了大小，而堆和栈不一样</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309031607409.png" alt="image-20230903160738499"></li>
</ul>
<p><strong>内存保护</strong></p>
<ul>
<li>设置一对上、下限寄存器<ul>
<li>存放用户作业在主存中的下限和上限</li>
</ul>
</li>
<li>采用重定位寄存器（基地址寄存器）和界地址寄存器（限长寄存器）<ul>
<li>重定位地址含最小的物理地址值</li>
<li>界地址寄存器含逻辑地址的最大值</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309031607273.png" alt="image-20230903160713214"></li>
</ul>
</li>
</ul>
<p><strong>内存共享</strong></p>
<p><strong>内存分配与回收</strong></p>
<ul>
<li>单一连续分配——固定分区分配——动态分区分配</li>
<li>连续分配方式——离散分配方式（页式存储管理）</li>
<li>引入分段存储管理的目的<ul>
<li>满足用户在编程和使用方面的要求</li>
</ul>
</li>
</ul>
<h3 id="3-1-2-覆盖与交换（不要求）"><a href="#3-1-2-覆盖与交换（不要求）" class="headerlink" title="*3.1.2 覆盖与交换（不要求）"></a>*3.1.2 覆盖与交换（不要求）</h3><h3 id="3-1-3连续分配管理方式"><a href="#3-1-3连续分配管理方式" class="headerlink" title="3.1.3连续分配管理方式"></a>3.1.3连续分配管理方式</h3><ul>
<li>连续分配方式是指为一个用户程序分配一个连续的内存空间</li>
<li><p>内部碎片</p>
<ul>
<li>分配给某进程的内存区域中，有些部分没有用上</li>
</ul>
</li>
<li><p>外部碎片</p>
<ul>
<li>内存中的某些空闲分区由于太小而难以利用</li>
</ul>
</li>
</ul>
<p><strong>单一连续分配</strong></p>
<ul>
<li><p>内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据。内存中只能有一道用户程序，用户程序独占整个用户区空间</p>
</li>
<li><p>优点：</p>
<ul>
<li>简单、无外部碎片，无须进行内存保护</li>
</ul>
</li>
<li>缺点<ul>
<li>只能用于单用户、单任务的操作系统中，有内部碎片，存储器的利用率极低</li>
</ul>
</li>
</ul>
<p><strong>固定分区分配</strong></p>
<ul>
<li><p>将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式</p>
</li>
<li><p>分区方法</p>
<ul>
<li><p>分区大小相等</p>
<ul>
<li>程序太小会造成浪费，太大又无法装入，缺乏灵活性</li>
</ul>
</li>
<li><p>分区大小不等</p>
<ul>
<li>划分为多个较小的分区、适量的中等分区和少量的大分区</li>
</ul>
</li>
</ul>
</li>
<li><p>空闲分区链</p>
</li>
<li><p>分区使用表（空闲分区表）</p>
<ul>
<li>记录每个分区的起始地址、大小以及状态（是否已分配）</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309031937364.png" alt="image-20230903193754349"></li>
</ul>
</li>
<li><p>存在两个问题</p>
<ul>
<li>程序过大放不进任何一个分区中</li>
<li>主存利用率低，存在内部碎片</li>
</ul>
</li>
</ul>
<p><strong>动态分区分配（可变分区分配）</strong></p>
<ul>
<li><p>在进程装入内存时，根据进程的实际需要，动态地为之分配内存，并使分区的大小正好适合进程的需要</p>
</li>
<li><p>紧凑技术</p>
<ul>
<li>解决外部碎片问题</li>
<li>操作系统不时对进程进行移动和整理</li>
<li>需要动态重定位寄存器的支持，相对费时</li>
</ul>
</li>
<li>动态分区的分配策略<ul>
<li>首次适应算法 First Fit<ul>
<li>空闲分区以地址递增的次序链接，分配内存时，从链首开始顺序查找，找到大小能满足要求的第一个空闲分区分配作业</li>
<li>优点<ul>
<li>最简单、最快、最好</li>
</ul>
</li>
<li>缺点<ul>
<li>内存的低地址部分出现很多小的空闲分区，每次查找都要绕开这些分区，增加了开销</li>
</ul>
</li>
</ul>
</li>
<li>邻近适应算法 Next Fit<ul>
<li>又称循环首次适应算法</li>
<li>分配内存时从上次查找结束的位置开始继续查找</li>
<li>缺点<ul>
<li>可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，性能比首次适应算法差</li>
</ul>
</li>
</ul>
</li>
<li>最佳适应算法 Best Fit<ul>
<li>空闲分区以容量递增的次序形成空闲分区链，找到第一个能满足要求且最小的分区分配给作业</li>
<li>缺点<ul>
<li>每次分配会留下很小的难以利用的内存块，产生很多的外部碎片，性能很差</li>
</ul>
</li>
</ul>
</li>
<li>最坏适应算法 Worst Fit<ul>
<li>空闲分区以容量递减的次序链接，找到第一个能满足要求的，即最大的分区，从中分割一部分存储空间给作业</li>
<li>缺点：<ul>
<li>快速消耗大分区，导致后面无大分区可用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="非连续分配管理方式"><a href="#非连续分配管理方式" class="headerlink" title="非连续分配管理方式"></a>非连续分配管理方式</h3><ul>
<li>分页存储管理<ul>
<li>基本分页存储管理</li>
<li>请求分页存储管理</li>
</ul>
</li>
<li>分段存储管理</li>
</ul>
<h3 id="3-1-4-基本分页存储管理方式"><a href="#3-1-4-基本分页存储管理方式" class="headerlink" title="3.1.4 基本分页存储管理方式"></a>3.1.4 基本分页存储管理方式</h3><ul>
<li><p>从计算机角度考虑，提高内存的利用率和计算机的性能，通过硬件机制实现，对用户完全透明</p>
</li>
<li><p>把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位，每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存的块空间</p>
</li>
<li>不会产生外部碎片</li>
<li>每个进程平均只产生半个块大小的内部碎片（页内碎片）</li>
<li>不方便按照逻辑模块实现信息的共享和保护</li>
</ul>
<p><strong>分页存储的几个基本概念</strong></p>
<ul>
<li>页面和页面大小<ul>
<li>进程中的块称为页/页面（Page）<ul>
<li>大小应是2的整数幂<ul>
<li>逻辑地址的拆分更加迅速</li>
<li>物理地址的计算更加迅速</li>
</ul>
</li>
<li>过小<ul>
<li>使进程的页面数过多，这样页表就会过长，占用大量内存，而且增加硬件地址转换的开销。，降低页面换入/换出的效率</li>
</ul>
</li>
<li>过大<ul>
<li>使页内碎片增多，降低主存的利用率</li>
</ul>
</li>
</ul>
</li>
<li>内存中的块称为页框（Page Frame，或页帧）</li>
<li>外存直接称为块/盘块（Block）</li>
</ul>
</li>
<li>地址结构<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309041913870.png" alt="image-20230904191338566"><ul>
<li>上图地址长度为32位，其中0-11位为页内地址，即每页大小为4KB；12-31位为页号，即最多允许<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.919ex" height="1.887ex" role="img" focusable="false" viewBox="0 -833.9 1290.1 833.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path></g></g></g></g></g></svg></mjx-container>页</li>
</ul>
</li>
</ul>
</li>
<li>页表<ul>
<li>实现从页号到物理块号的地址映射</li>
<li>由页表项组成</li>
<li>第一部分为页号（隐藏），第二部分是物理内存中的块号</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309041917922.png" alt="image-20230904191756167"></li>
</ul>
</li>
</ul>
<p><strong>基本地址变换机构</strong></p>
<ul>
<li>页表寄存器（PTR）<ul>
<li>存放页表在内存的起始地址F和页表长度M</li>
</ul>
</li>
<li>过程<ul>
<li>设页面大小为L，逻辑地址为A，物理地址为E</li>
<li>页号P = L/A；页内偏移量W = A%L</li>
<li>比较页号P与页面长度M，若P≥M则产生越界中断</li>
<li>页表中页号P对应的页表项地址 = 页表始址F + 页号P × 页表项长度，取出该页表项内容b，即物理块号</li>
<li>计算 物理地址E = b × L + W</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309041924860.png" alt="image-20230904192440613"></li>
</ul>
</li>
<li>页表项的大小<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309041922520.png" alt="image-20230904192202285"></li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309041930281.png" alt="image-20230904193029310"></li>
</ul>
</li>
<li>分页管理方式存在的主要问题<ul>
<li>地址转换必须足够快，否咋访存速度会降低<ul>
<li>每次访存操作都需要进行逻辑地址到物理地址的转换</li>
</ul>
</li>
<li>页表不能过大，否则内存利用率会降低<ul>
<li>每个进程都要引入页表，用于存储映射机制</li>
</ul>
</li>
</ul>
</li>
<li>两次访存</li>
</ul>
<p><strong>具有快表的地址变换机构</strong></p>
<ul>
<li>高速缓冲存储器——快表（相联存储器TLB），主存中的页表常称为慢表</li>
<li>地址变换过程<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309041936325.png" alt="image-20230904193657148"></li>
<li>CPU给出逻辑地址后，由硬件进行地址转换，将页号送入高速缓存寄存器，并将此页号与快表中的所有页号进行比较</li>
<li>若找到匹配的页号，说明所要访问的页表项在快表中，则直接从中取出该页对应的页框号，与页内偏移量拼接形成物理地址。这样，存取数据仅一次访存便可实现</li>
<li>若未找到匹配的页号，则需要访问主存中的页表，读出页表项后，应同时将其存入快表，以便后面可能的再次访问。若快表已满，则须按特定的算法淘汰一个旧页表项</li>
</ul>
</li>
<li>给定快表命中率a和快表访问时间b，慢表访问时间c，求平均耗时T<ul>
<li>先块表后慢表<ul>
<li>$T=(b+c)<em>a+(b+c+c)</em>(1-a)$</li>
</ul>
</li>
<li>块表慢表同时查询<ul>
<li>$T=(b+c)<em>a+(c+c)</em>(1-a)$</li>
</ul>
</li>
</ul>
</li>
<li>基于局部性原理</li>
<li>快表命中——一次访存；未命中——两次</li>
</ul>
<p><strong>两级页表</strong></p>
<ul>
<li><p>单级页表的问题</p>
<ul>
<li>页表必须连续存放，当页表很大时，需要占用很多个连续的页框</li>
<li>没有必要让整个页表常驻内存，因为进程在一段时间内只需要访问某几个特点的页面</li>
</ul>
</li>
<li><p>==顶级页表最多只能有一个页面==</p>
</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309041951525.png" alt="image-20230904195152347"></li>
<li>访存次数（假设没有快表）<ul>
<li>二级——三次</li>
<li>三级——四次</li>
<li>……</li>
</ul>
</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309041952608.png" alt="image-20230904195239664"></li>
</ul>
<h3 id="3-1-5基本分段存储管理方式"><a href="#3-1-5基本分段存储管理方式" class="headerlink" title="3.1.5基本分段存储管理方式"></a>3.1.5基本分段存储管理方式</h3><ul>
<li>从用户和程序员的角度考虑，以满足方便编程、信息保护和共享、动态增长及动态链接等多方面的需要</li>
<li>分配大的连续空间不方便，会产生外部碎片</li>
</ul>
<p><strong>分段</strong></p>
<ul>
<li>按照用户进程中的自然段划分逻辑空间</li>
<li>段内要求连续，段间无要求</li>
<li>二维（标识一个地址，既要给出段名，也要给出段内地址）<ul>
<li>段长不固定</li>
<li>分页——一维</li>
<li>二级分页——一维<ul>
<li>页长固定，给定一个整数能自己推算出偏移等</li>
</ul>
</li>
</ul>
</li>
<li>每段都从0开始编址</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309041958378.png" alt="image-20230904195812180"></li>
</ul>
<p><strong>段表</strong></p>
<ul>
<li>组成<ul>
<li>段号（隐藏）</li>
<li>段长（不固定）</li>
<li>本段在主存中的起始地址</li>
</ul>
</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309042000900.png" alt="image-20230904200058714"></li>
</ul>
<p><strong>地址变换机构</strong></p>
<ul>
<li>段表寄存器<ul>
<li>存放段表起始地址F和段表长度M</li>
</ul>
</li>
<li>过程<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309042001366.png" alt="image-20230904200155470"></li>
<li>取出逻辑地址A的前几位为段号S，后几位为段内偏移量W</li>
<li>比较段号S和段表长度M，若<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.312ex;" xmlns="http://www.w3.org/2000/svg" width="6.854ex" height="1.907ex" role="img" focusable="false" viewBox="0 -705 3029.6 843"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path></g><g data-mml-node="mo" transform="translate(922.8,0)"><path data-c="2265" d="M83 616Q83 624 89 630T99 636Q107 636 253 568T543 431T687 361Q694 356 694 346T687 331Q685 329 395 192L107 56H101Q83 58 83 76Q83 77 83 79Q82 86 98 95Q117 105 248 167Q326 204 378 228L626 346L360 472Q291 505 200 548Q112 589 98 597T83 616ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(1978.6,0)"><path data-c="1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"></path></g></g></g></svg></mjx-container>，则产生越界中断</li>
<li>段号S对应的段表项地址 = 段表始址F + 段号S * 段表项长度，取出该段表项的前几位得到段长C，若段内偏移量<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.312ex;" xmlns="http://www.w3.org/2000/svg" width="4.108ex" height="1.907ex" role="img" focusable="false" viewBox="0 -705 1815.8 843"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2265" d="M83 616Q83 624 89 630T99 636Q107 636 253 568T543 431T687 361Q694 356 694 346T687 331Q685 329 395 192L107 56H101Q83 58 83 76Q83 77 83 79Q82 86 98 95Q117 105 248 167Q326 204 378 228L626 346L360 472Q291 505 200 548Q112 589 98 597T83 616ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(1055.8,0)"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g></g></g></svg></mjx-container>，则产生越界中断</li>
<li>取出段表项中该段的始址b，计算物理地址<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="10.853ex" height="1.756ex" role="img" focusable="false" viewBox="0 -694 4797 776"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"></path></g><g data-mml-node="mo" transform="translate(1041.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(2097.6,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(2748.8,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(3749,0)"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"></path></g></g></g></svg></mjx-container></li>
</ul>
</li>
</ul>
<p><strong>段的共享和保护</strong></p>
<ul>
<li>段的共享<ul>
<li>两个作业的段表中相应表项指向被共享的段的同一个物理副本</li>
</ul>
</li>
<li>纯代码/可重入代码<ul>
<li>不属于临界资源</li>
<li>不能被修改</li>
<li>可修改的代码和数据不能共享</li>
</ul>
</li>
<li>存取控制保护</li>
<li>地址越界保护<ul>
<li>比较段表寄存器中的段长与逻辑地址中的段号</li>
<li>比较段表项中的段长和逻辑地址中的段内偏移</li>
<li>分页管理只需判断页号是否越界</li>
</ul>
</li>
</ul>
<h3 id="3-1-6段页式管理方式"><a href="#3-1-6段页式管理方式" class="headerlink" title="3.1.6段页式管理方式"></a>3.1.6段页式管理方式</h3><ul>
<li><p>作业的逻辑地址</p>
<ul>
<li><p>段表项（定长）</p>
<ul>
<li><p>段号（隐藏）</p>
<ul>
<li>决定每个进程最多可以分为多少个段</li>
</ul>
</li>
<li><p>页号</p>
<ul>
<li>决定每个段最大有多少页</li>
</ul>
</li>
<li><p>页内偏移量</p>
<ul>
<li>决定页面大小</li>
</ul>
</li>
</ul>
</li>
<li><p><img src="https://gitee.com/renmale-sztu/image/raw/master/202309042023970.png" alt="image-20230904202356146"></p>
</li>
</ul>
</li>
<li><p>段表寄存器</p>
<ul>
<li>指出作业的段表始址和段表长度</li>
<li>段表寄存器和页表寄存器的作用都有两个<ul>
<li>在段表或页表中寻址</li>
<li>判断是否越界</li>
</ul>
</li>
</ul>
</li>
<li>在一个进程中，段表只有一个，而页表可能有多个</li>
<li>段页式管理的地址空间是二维的</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309042027016.png" alt="image-20230904202719134"><ul>
<li>三次访存</li>
<li>首先通过段表查询到页表始址</li>
<li>然后通过页表找到页帧号</li>
<li>最后形成物理地址</li>
</ul>
</li>
</ul>
<h2 id="3-2-虚拟内存管理"><a href="#3-2-虚拟内存管理" class="headerlink" title="3.2 虚拟内存管理"></a>3.2 虚拟内存管理</h2><h3 id="3-2-1虚拟内存的基本概念"><a href="#3-2-1虚拟内存的基本概念" class="headerlink" title="3.2.1虚拟内存的基本概念"></a>3.2.1虚拟内存的基本概念</h3><p><strong>传统存储管理方式的特征</strong></p>
<ul>
<li>一次性<ul>
<li>作业必须一次性全部装入内存，才能开始运行<ul>
<li>当作业量很大而不能全部装入内存时，将使该作业无法运行</li>
<li>当大量作业要求运行时，由于内存不足以容纳所有作业，只能使少数作业先运行，导致多道程序度的下降</li>
</ul>
</li>
</ul>
</li>
<li>驻留性<ul>
<li>作业被装入内存后，就一直驻留在内存中，其任何部分斗不会被换出，直至作业运行结束<ul>
<li>运行中的进程会因等待I/O而被阻塞，可能处于长期等待状态</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>局部性原理</strong></p>
<ul>
<li>时间局部性<ul>
<li>如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问（因为程序中存在大量的循环）</li>
</ul>
</li>
<li>空间局部性<ul>
<li>一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问（因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的）</li>
</ul>
</li>
<li>高速缓存技术<ul>
<li>依赖局部性原理<ul>
<li>快表</li>
<li>页高速缓存</li>
<li>虚拟内存</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>虚拟存储器的定义和特征</strong></p>
<ul>
<li>定义<ul>
<li>基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行。在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存</li>
</ul>
</li>
<li>特征<ul>
<li>多次性<ul>
<li>无须在作业运行时一次性地全部装入内存，而允许被分成多次调入内存运行，即只需将当前要运行地那部分程序和数据装入内存即可开始运行</li>
<li>多次性是虚拟存储器最重要的特征</li>
</ul>
</li>
<li>对换性<ul>
<li>无须在作业运行时一直常驻内存，在进程运行期间，允许将那些暂不使用的程序和数据从内存调至外存的对换区（换出），待以后需要时再将它们从外存调至内存（换入）</li>
</ul>
</li>
<li>虚拟性<ul>
<li>从逻辑上扩充内存的容量，使用户所看到的内存容量远大于实际的内存容量</li>
<li>虚拟存储器所表现出的最重要特征</li>
<li>实现虚拟存储器的最重要目标</li>
</ul>
</li>
</ul>
</li>
<li>容量<ul>
<li>最大容量<ul>
<li>有计算机的地址结构（CPU寻址范围）确定</li>
</ul>
</li>
<li>实际容量<ul>
<li>min(内存和外存容量之和，CPU寻址范围)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>虚拟内存技术的实现</strong></p>
<ul>
<li><p>建立在离散分配的内存管理方式的基础上</p>
</li>
<li><p>三种方式</p>
<ul>
<li>请求分页存储管理</li>
<li>请求分段存储管理</li>
<li>请求段页式存储管理</li>
</ul>
</li>
<li><p>虚拟内存的容量要满足两个条件</p>
<ul>
<li>虚存的实际容量 ≤ 内存容量和外存容量之和</li>
<li>虚存的最大容量 ≤ 计算机的地址位数能容纳的最大容量</li>
</ul>
</li>
</ul>
<h3 id="3-2-2-请求分页管理方式"><a href="#3-2-2-请求分页管理方式" class="headerlink" title="3.2.2 请求分页管理方式"></a>3.2.2 请求分页管理方式</h3><p><strong>页表机制</strong></p>
<ul>
<li>新增字段<ul>
<li>状态位P<ul>
<li>用户指示该页是否已调入内存</li>
<li>供程序访问时参考</li>
</ul>
</li>
<li>访问字段A<ul>
<li>用于记录本页在一段时间内被访问的次数或本页最近已有多长时间未被访问</li>
<li>供置换算法换出页面时参考</li>
</ul>
</li>
<li>修改位M<ul>
<li>标识该页在调入内存后是否被修改过，以确定页面置换时是否写回内存</li>
</ul>
</li>
<li>外存地址<ul>
<li>用于指出该页在外存上的地址，通常是物理块号，供调入该页时参考</li>
</ul>
</li>
</ul>
</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309051537126.png" alt="image-20230905153735003"></li>
</ul>
<p><strong>缺页中断机构</strong></p>
<ul>
<li>在指令执行期间而非一条指令执行完后产生和处理中断信号，属于内部中断（内中断）</li>
<li>一条指令在执行期间，可能产生多次缺页中断</li>
</ul>
<p><strong>地址变换机构</strong></p>
<ul>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309051541445.png" alt="image-20230905154122573"><ul>
<li>先检查快表</li>
<li>若找到要访问的页，则修改页表项中的访问位（写指令还需要重置修改位），然后利用页表项中给出的物理块号和页内地址形成物理地址</li>
<li>若未找到该页的页表项，则应到内存中去查找页表，再对比页表项中的状态位P，看该页是否已调入内存，若页面已调入，则将该页的页表写入快表，若快表已满，则需采用某种算法替换。若页面未调入，则产生缺页中断，请求从外存把该页调入内存</li>
</ul>
</li>
<li>只有“写指令”才需要修改“修改位”。并且，一般来说只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表。这样可以减少访存次数。</li>
<li>和普通的中断处理一样，缺页中断处理依然需要保留CPU现场</li>
<li>需要用某种“页面置换算法”来决定一个换出页面</li>
<li>换入/换出页面都需要启动慢速的I/O操作，可见，如果换入/换出太频繁，会有很大的开销。</li>
<li>页面调入内存后，需要修改慢表，同时也需要将表项复制到快表中。</li>
</ul>
<h3 id="3-2-3页框分配"><a href="#3-2-3页框分配" class="headerlink" title="3.2.3页框分配"></a>3.2.3页框分配</h3><p><strong>驻留集大小</strong></p>
<ul>
<li>给一个进程分配的物理页框的集合就是这个进程的驻留集</li>
<li>分配给一个进程的页框越少，驻留在主存中的进程就越多，从而可提高CPU的利用率</li>
<li>若一个进程在主存中的页面过少，则尽管有局部性原理，缺页率仍相对较高</li>
<li>若分配的页框过多，则由于局部性原理，对该进程的缺页率没有太明显的影响</li>
</ul>
<p><strong>内存分配策略</strong></p>
<ul>
<li><p>概念</p>
<ul>
<li>固定分配<ul>
<li>操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，驻留集大小不变</li>
</ul>
</li>
<li>可变分配<ul>
<li>先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即，驻留集大小可变</li>
</ul>
</li>
<li>局部置换<ul>
<li>发生缺页时只能选进程自己的物理块进行置换</li>
</ul>
</li>
<li>全局置换<ul>
<li>可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程</li>
</ul>
</li>
</ul>
</li>
<li><p>策略</p>
<ul>
<li><p>固定分配局部置换</p>
<ul>
<li>系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面</li>
<li>这种策略的缺点是：很难在刚开始就确定应为每个进程分配多少个物理块才算合理。<ul>
<li>太少会频繁出现缺页中断，太多又会降低CPU和其他资源的利用率</li>
</ul>
</li>
</ul>
</li>
<li><p>可变分配全局置换</p>
<ul>
<li>刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程；若已无空闲物理块，则可选择一个未锁定（锁定的页面不能换出外存）的页面换出外存，再将该物理块分配给缺页的进程。采用这种策略时，只要某进程发生缺页，都将获得新的物理块，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出。被选择调出的页可能是系统中任何一个进程中的页，因此这个被选中的进程拥有的物理块会减少，缺页率会增加。</li>
<li>盲目地给进程增加物理块，从而导致系统多道程序的并发能力下降</li>
</ul>
</li>
<li><p>可变分配局部置换</p>
<ul>
<li>刚开始会为每个进程分配一定数量的物理块。当某进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存。如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当程度；反之，如果进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。</li>
<li>这种方法在保证进程不会过多地调页的同时，也保持了系统的多道程序并发能力。当然它需要更复杂的实现，也需要更大的开销，但对比频繁地换入/换出所浪费的计算机资源，这种牺牲是值得的</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>物理块调入算法</strong></p>
<ul>
<li>固定分配分配算法<ul>
<li>平均分配算法<ul>
<li>将系统中所有可供分配的物理块平均分配给各个进程</li>
</ul>
</li>
<li>按比例分配算法<ul>
<li>根据进程的大小按比例分配物理块</li>
</ul>
</li>
<li>优先权分配算法<ul>
<li>为重要和紧迫的进程分配较多的物理块</li>
<li>通常采取把所有可分配的物理块分成两部分，一部分按比例，一部分按优先权</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>调入页面的时机</strong></p>
<ul>
<li>预调页策略（运行前调入）<ul>
<li>主要用户进程的首次调入</li>
</ul>
</li>
<li>请求调页策略<ul>
<li>在运行期间发现缺页时才将所缺页面调入内存</li>
</ul>
</li>
</ul>
<p><strong>从何处调入页面</strong></p>
<ul>
<li>外存分为两部分<ul>
<li>用于存放文件的文件区：通常采用离散分配方式</li>
<li>用于存放对换页面的对换区：通常采用连续分配方式</li>
</ul>
</li>
<li>三种情况<ul>
<li>系统拥有足够的对换区空间<ul>
<li>可以全部从对换区调入所需页面，以提高调页速度。为此在进程运行前，需将与该进程有关的文件从文件区复制到对换区</li>
</ul>
</li>
<li>系统缺少足够的对换区空间<ul>
<li>凡是不会被修改的文件都直接从文件区调入；而当换出这些页面时，由于它们未被修改而不必再将它们换出。但对于那些可能被修改的部分，在将它们换出时须调到对换区，以后需要时再从对换区调入（因为读比写的速度快）</li>
</ul>
</li>
<li>UNIX方式<ul>
<li>与进程有关的文件都放在文件区，因此未运行过的页面都应从文件区调入曾经运行过但又被换出的页面，由于是放在对换区，因此在下次调入时应从对换区调入进程请求的共享页面若被其他进程调入内存，则无须再从对换区调入</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>如何调入页面</strong></p>
<ol>
<li>缺页</li>
<li>缺页中断</li>
<li>缺页中断处理程序</li>
<li>…….</li>
</ol>
<h3 id="3-2-4页面置换算法"><a href="#3-2-4页面置换算法" class="headerlink" title="3.2.4页面置换算法"></a>3.2.4页面置换算法</h3><p><strong>最佳（OPT）置换算法</strong></p>
<ul>
<li>每次选择的页面是以后永不使用的页面，或者最长时间内不再被访问的页面，以确保最低的缺页率</li>
<li>该算法无法实现</li>
</ul>
<p><strong>先进先出（FIFO）算法</strong></p>
<ul>
<li><p>优先淘汰最早进入内存的页面，即淘汰在内存中驻留最久的页面</p>
</li>
<li><p>Belady异常</p>
<ul>
<li>当为进程分配的物理块数增大时，缺页次数不减反增的异常现象</li>
<li>只有FIFO算法会产生Belady异常</li>
</ul>
</li>
<li>实现简单，算法性能差</li>
</ul>
<p><strong>最近最久未使用（LRU）算法</strong></p>
<ul>
<li>每次选择最近最长时间未访问过的页面淘汰，该算法未每个页面设置一个访问字段，用来记录页面上一次被访问以来所经历的时间，淘汰页面时选择现有页面中值最大的淘汰</li>
<li>性能好，当需要寄存器和栈的硬件支持，开销大（需要对所有的页进行排序）</li>
</ul>
<p><strong>时钟（CLOCK）置换算法</strong></p>
<ul>
<li><p>简单的CLOCK置换算法</p>
<ul>
<li>为每帧设置一位访问位，当某页首次被装入或被访问时，其访问位被置为1</li>
<li>将内存中的所有页面视为一个循环队列，并有一个替换指针与之相关联，当某一页被替换时，该指针被设置指向被替换页面的下一页。在选择一页淘汰时，只需检查页的访问位。若为0，就选择该页换出：若为1，则将它置为0，暂不换出，给予该页第二次驻留内存的机会，再依次顺序检查下一个页面。当检查到队列中的最后一个页面时，若其访问位仍为1，则返回到队首去循环检查</li>
<li>该算法是循环地检查各个页面的使用情况，故称CLOCK算法但是，因为该算法只有一位访问位，而置换时将未使用过的页面换出，故又称最近未用(N RU）算法</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309051710784.png" alt="image-20230905171026827"></li>
</ul>
</li>
<li><p>改进型CLOCK置换算法</p>
<ul>
<li>将一个页面换出时，若该页已被修改过，则要将该页写回磁盘，若该页未被修改过，则不必将它写回磁盘。可见，对于修改过的页面，替换代价更大。在改进型CLOCK算法中，除考虑页面使用情况外，还增加了置换代价——修改位</li>
<li></li>
<li>访问位A和修改位M<ul>
<li>A=0,M=0；最近未被访问且未被修改，是最佳淘汰页</li>
<li>A=0，M=1；最近未被访问，但已被修改，不是很好的淘汰页</li>
<li>A=1.M=0:最近已被访问，但未被修改，可能再被访问</li>
<li>A=1,M=1:最近已被访问且已被修改，可能再被访问</li>
</ul>
</li>
<li>过程<ol>
<li>从指针的当前位置开始，扫描循环队列，寻找A=0且M=0的1类页面，将遇到的第一个1类页面作为选中的淘汰页。在第一次扫描期间不改变访问位A</li>
<li>若第1）步失败，则进行第二轮扫描，寻找A=0且M=1的2类页面。将遇到的第一个2类页面作为淘汰页。在第二轮扫描期间，将所有扫描过的页面的访问位都置0</li>
<li>若第2）步也失败，则将指针返回到开始的位置，并将所有帧的访问位复0。重复第1）步，并且若有必要，重复第2）步，此时一定能找到被淘汰的页</li>
</ol>
</li>
<li>最多进行4轮循环</li>
<li>改进型CLOCK算法优于简单CLOCK算法的地方在于，可减少磁盘的I/O操作次数。但为了找到一个可置换的页，可能要经过几轮扫描，即实现算法本身的开销将有所增加</li>
</ul>
</li>
</ul>
<h3 id="3-2-5抖动和工作集"><a href="#3-2-5抖动和工作集" class="headerlink" title="3.2.5抖动和工作集"></a>3.2.5抖动和工作集</h3><p><strong>抖动（颠簸）</strong></p>
<ul>
<li>发生的原因：某个进程频繁访问的页面数目高于可用的物理页帧数目</li>
</ul>
<p><strong>工作集</strong></p>
<ul>
<li>某段时间间隔内，进程要访问的页面集合</li>
<li>驻留集大小不能小于工作集大小</li>
<li><img src="https://gitee.com/renmale-sztu/image/raw/master/202309051930871.png" alt="image-20230905193013779"></li>
</ul>
<h3 id="3-2-6内存映射文件"><a href="#3-2-6内存映射文件" class="headerlink" title="3.2.6内存映射文件"></a>3.2.6内存映射文件</h3><ul>
<li>将磁盘文件的全部或部分内容与进程虚拟地址空间的某个区域建立映射关系，便可以直接访问被映射的文件，而不必执行文件I/O操作，也无须对文件内容进行缓存处理</li>
<li>使用内存映射文件所进行的任何实际交互都是在内存中进行的，并且是以标准的内存地址形式来访问的</li>
<li>系统内存中的所有页面都由虚拟存储器负责管理，虚拟存储器以统一的方式处理所有磁盘I/O.当进程退出或显式地解除文件映射时，所有被改动的页面会被写回磁盘文件。</li>
<li>多个进程允许并发地内存映射同一文件，以便允许数据共享，共享内存是通过内存映射来实现的</li>
</ul>
<h3 id="3-2-7虚拟存储器性能影响因素"><a href="#3-2-7虚拟存储器性能影响因素" class="headerlink" title="3.2.7虚拟存储器性能影响因素"></a>3.2.7虚拟存储器性能影响因素</h3><ul>
<li>缺页率（缺页率高即为抖动）是影响虚拟存储器性能的主要因素<ul>
<li>页面大小<ul>
<li>根据局部性原理，页面较大则缺页率较低，页面较小则缺页率较高。页面较小时，一方面减少了内存碎片，有利于提高内存利用率；另一方面，也会使每个进程要求较多的页面，导致页表过长，占用大量内存。页面较大时，虽然可以减少页表长度，但会使页内碎片增大</li>
</ul>
</li>
<li>工作集<ul>
<li>分配给进程的物理块数越多，缺页率就越低，但是当物理块超过某个数目时，再为进程增加一个物理块对缺页率的改善是不明显的</li>
</ul>
</li>
<li>页面置换算法<ul>
<li>好的页面置换算法可使进程在运行过程中具有较低的缺页率</li>
</ul>
</li>
<li>程序的编制方法<ul>
<li>编写程序的局部化程度越高，执行时的缺页率就越低。如果存储采用的是按行存储，访问时就要尽量采用相同的访问方式，避免按列访问造成缺页率过高的现象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-2-8-地址翻译"><a href="#3-2-8-地址翻译" class="headerlink" title="3.2.8 地址翻译"></a>3.2.8 地址翻译</h3><ul>
<li>计算机组成原理结合</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 操作系统</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/09/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" rel="prev" title="操作系统—第二章—进程与线程">
      <i class="fa fa-chevron-left"></i> 操作系统—第二章—进程与线程
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/09/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E7%AC%AC%E5%9B%9B%E7%AB%A0%E2%80%94%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/" rel="next" title="操作系统—第四章—文件系统基础">
      操作系统—第四章—文件系统基础 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5"><span class="nav-text">3.1 内存管理概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%92%8C%E8%A6%81%E6%B1%82"><span class="nav-text">3.1.1内存管理的基本原理和要求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-2-%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2%EF%BC%88%E4%B8%8D%E8%A6%81%E6%B1%82%EF%BC%89"><span class="nav-text">*3.1.2 覆盖与交换（不要求）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-3%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-text">3.1.3连续分配管理方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-text">非连续分配管理方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-4-%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-text">3.1.4 基本分页存储管理方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-5%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-text">3.1.5基本分段存储管理方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-6%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-text">3.1.6段页式管理方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">3.2 虚拟内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">3.2.1虚拟内存的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-text">3.2.2 请求分页管理方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-3%E9%A1%B5%E6%A1%86%E5%88%86%E9%85%8D"><span class="nav-text">3.2.3页框分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-4%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-text">3.2.4页面置换算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-5%E6%8A%96%E5%8A%A8%E5%92%8C%E5%B7%A5%E4%BD%9C%E9%9B%86"><span class="nav-text">3.2.5抖动和工作集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-6%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6"><span class="nav-text">3.2.6内存映射文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-7%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D%E5%9B%A0%E7%B4%A0"><span class="nav-text">3.2.7虚拟存储器性能影响因素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-8-%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91"><span class="nav-text">3.2.8 地址翻译</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">renmale-lv</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">renmale-lv</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">110k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">1:40</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
